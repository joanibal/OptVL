{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OptVL Documentation","text":"<p>Welcome to the official documentation for OptVL! OptVL builds on Mark Drela and Harold Youngren's famous AVL code. The goal of OptVL is to make it easy to include the physics of AVL into a parameter sweep or design optimization loop. This is achieved by extending the AVL's Fortran source code with derivative routines and modifications for <code>f2py</code>-based python wrapping.</p> <p>Dive in to learn about installation, analysis, and optimization with <code>OptVL</code>.</p> <p>Get started with installation or an overview</p> <p>Before working with OptVL, it is useful to familiarize yourself with AVL. More information about AVL can be found at its website.  If you already know AVL well, then I'd advise starting with a comparison of the interfaces here.</p>"},{"location":"alpha_cl_sweep/","title":"Running alpha and CL sweeps","text":"<p>After initializing and setting up your <code>OVLSolver</code>, you can perform analysis tasks such as alpha and CL sweeps. This is done by specifying new parameters and re-executing the run.  The iterations over Mach number take longer to run, because the matrix defining the influence of the vortices needs to be reconstructed for each new Mach number. </p> <pre><code>from optvl import OVLSolver\nimport numpy as np\n\novl = OVLSolver(geo_file=\"aircraft.avl\", debug=False)\n\n# set the angle of attack\novl.set_constraint(\"alpha\", 0.00)\n\n# set the deflection of the elevator to trim the pitching moment\novl.set_constraint(\"Elevator\", 0.00, con_var=\"Cm pitch moment\")\n\novl.set_parameter(\"Mach\", 0.3)\n\n\nprint(\"----------------- alpha sweep ----------------\")\nprint(\"   Angle        Cl           Cd          Cdi          Cdv          Cm\")\nfor alpha in range(10):\n    ovl.set_constraint(\"alpha\", alpha)\n    ovl.execute_run()\n    run_data = ovl.get_total_forces()\n    print(\n        f\" {alpha:10.6f}   {run_data['CL']:10.6f}   {run_data['CD']:10.6f}   {run_data['CDi']:10.6f}   {run_data['CDv']:10.6f}   {run_data['CM']:10.6f}\"\n    )\n\novl.set_constraint(\"alpha\", 0.00)\n\nprint(\"----------------- beta sweep ----------------\")\nprint(\"   Angle        Cl           Cd          Cdi          Cdv          Cm\")\nfor beta in range(10):\n    ovl.set_constraint(\"beta\", beta)\n    ovl.execute_run()\n    run_data = ovl.get_total_forces()\n    print(\n        f\" {beta:10.6f}   {run_data['CL']:10.6f}   {run_data['CD']:10.6f}   {run_data['CDi']:10.6f}   {run_data['CDv']:10.6f}   {run_data['CM']:10.6f}\"\n    )\n\novl.set_constraint(\"beta\", 0.00)\n\nprint(\"----------------- Mach sweep ----------------\")\nprint(\"    Mach        Cl           Cd          Cdi          Cdv          Cm\")\nfor mach in np.arange(0.0, 0.7, 0.1):\n    ovl.set_parameter(\"Mach\", mach)\n    ovl.execute_run()\n    run_data = ovl.get_total_forces()\n    print(\n        f\" {mach:10.6f}   {run_data['CL']:10.6f}   {run_data['CD']:10.6f}   {run_data['CDi']:10.6f}   {run_data['CDv']:10.6f}   {run_data['CM']:10.6f}\"\n    )\n\n\nprint(\"----------------- CL sweep ----------------\")\nprint(\"   Angle        Cl           Cd          Cdff          Cdv          Cm\")\nfor cl in np.arange(0.6, 1.6, 0.1):\n    ovl.set_trim_condition(\"CL\", cl)\n    ovl.execute_run()\n    run_data = ovl.get_total_forces()\n    alpha = ovl.get_parameter(\"alpha\")\n    print(\n        f\" {alpha:10.6f}   {run_data['CL']:10.6f}   {run_data['CD']:10.6f}   {run_data['CDi']:10.6f}   {run_data['CDv']:10.6f}   {run_data['CM']:10.6f}\"\n    )\n</code></pre>"},{"location":"avl_changes/","title":"Avl changes","text":"<p>OptVL is double precision by default whereas AVL is single precision</p> <p>Add mach number reading</p> <p>Control surface deflection derivative fix</p>"},{"location":"building_optvl_locally/","title":"Building OptVL Locally","text":"<p>If you are developing OptVL you will want to install OptVL locally. After cloning the repo and navigating to the root directory there are two methods to actually build the python package, the meson way or the make way. </p>"},{"location":"building_optvl_locally/#using-meson","title":"Using Meson","text":"<p>This method exists to integrate with the tools necessary to package the binaries into wheels for distribution on PYPI,  The steps are </p> <ol> <li>install meson and ninja</li> <li>run <code>pip install .</code></li> </ol> <p>The <code>pyproject.toml</code> should hold all the information pip needs to use the meson backend for compiling the code.  To modify aspects of the build, such as the compilation flags, see the <code>meson.build</code> file. </p>"},{"location":"building_optvl_locally/#using-make","title":"Using Make","text":"<p>This method is more convenient for quick compilation during editing, but only works on Mac and Linux. The steps are</p> <ol> <li>Copy a config file from <code>config/defaults</code> to the config directory, i.e. <code>cp  config/defaults/config.LINUX_GFORTRAN.mk config/config.mk</code></li> <li>Create the shared library file with <code>make</code></li> <li>Install the python wrapper with <code>pip install -e ./dev_make_install</code></li> </ol> <p>After modifying the Fortran code only <code>make</code> needs to be run again.  If you only modify the python code then there is no need to rerun anything. </p>"},{"location":"common_developement_tasks/","title":"Common Development Task","text":"<p>Below is some information on a few development tasks that you may be interested in. </p>"},{"location":"common_developement_tasks/#modify-the-python-wrapper-or-openmdao-wrapper","title":"Modify the python wrapper or OpenMDAO wrapper.","text":"<p>The file <code>optvl_class.py</code> wraps the Fortran object file and is where the user API is defined.  For most development tasks this is what you will need to modify.  The file <code>om_wrapper.py</code> wraps the <code>OVLSolver</code> class for use with OpenMDAO.  If you want to change something about the OpenMDAO interface, you'll need to start here. </p>"},{"location":"common_developement_tasks/#run-ad-on-modified-code","title":"Run AD on modified code","text":"<p>Tapenade 3.16 is used to generate the derivative routines.  After installing Tapenade (only really works on Linux), navigate to the <code>/src/ad_src</code>. From here run <code>make -f Makefile_tapenade</code>. This will make both the forward and reverse routines by default.  After Tapenade generates the routines a few loop dimensions will need to be changed for speed.  I can do this step for you if you make a pull request. But in general there are a few places where we can loop over NVOR instead of NVMAX.</p>"},{"location":"common_developement_tasks/#expose-an-additional-variable-from-the-fortran-level","title":"Expose an additional variable from the Fortran level","text":"<ol> <li>in <code>AVL.INC.in</code> add it to the COMMON line AND declare its type above</li> <li>replace instances of the local variable in the code with the global variable from the COMMON block</li> <li>navigate to <code>src/includes</code> and run <code>gen_ad_inc.py</code> </li> <li>rebuild the library </li> </ol>"},{"location":"common_developement_tasks/#releasing-a-new-version","title":"Releasing a new version","text":"<ol> <li>Bump the version number in <code>pyproject.toml</code> AND in <code>meson.build</code>.<ul> <li>I cannot figure out a way to single source this so it will have to be done in two steps for now.</li> </ul> </li> <li>Then create a new release on GitHub. Create a new tagged version as part of the release</li> <li>Check that that new version has been released on PyPI as intended</li> </ol>"},{"location":"dev_docs/","title":"Development Overview","text":"<p>OptVL is an ongoing project done entirely in my free time.  Pull requests are welcome if you have something that you would like to contribute. Suggestions are also welcome, but I can't promise that I will ever have time to address them.  I'm using Github to track issues and bugs so open a new issue there with any concerns.</p>"},{"location":"dev_docs/#code-philosophy","title":"Code philosophy","text":"<p>OptVL should be easy to install and use.  To make it easy to install, OptVL should always be pip installable and only rely on core scientific Python packages like NumPy, and Matplotlib. The user could have additional programs like Tecplot and ParaView, but they should never be required. To keep OptVL easy to use, it is import to keep the required level of Python knowledge low as most users will be aerospace engineers first and may not have much Python experience.</p>"},{"location":"dev_docs/#development-roadmap","title":"Development roadmap","text":"<p>Below are some features I'm considering implementing.</p> <ul> <li>Make it easier to use Camber and thickness as design variables</li> <li>Flush out OpenMDAO geometry component that makes it easy to set geometric variables via splines</li> <li>Add body components to geometry plots and Cp surface output</li> <li>Add actuator disk model of Conway similar to VSPAERO</li> <li>Add interface to AeroSandbox</li> </ul>"},{"location":"installation/","title":"Installation Guide for OptVL","text":""},{"location":"installation/#installing-with-pip","title":"Installing with pip","text":"<p>The recommended method to install <code>optvl</code> is via pip:</p> <p><pre><code>pip install optvl\n</code></pre> This package is packaged with an OpenBLAS linear solver for quicker analysis.</p>"},{"location":"installation/#supported-platforms","title":"Supported Platforms","text":"<p>Currently, <code>optvl</code> supports Linux, macOS (Apple Silicon and Intel), and Windows!</p>"},{"location":"installation/#building-locally","title":"Building Locally","text":"<p>If you would like to build <code>optvl</code> manually, follow the steps below:</p> <ol> <li>Clone the repository to your local machine.</li> <li>Navigate to the root directory and run:    <pre><code>pip install .\n</code></pre> You will need the following dependencies</li> <li>meson</li> <li>meson-python</li> <li>ninja</li> </ol>"},{"location":"installation/#post-processing","title":"Post-processing","text":"<p>You can use <code>matplotlib</code> for viewing the geometry and 3D surface CP data.  You can also install it with <code>pip</code>.  You can also write out 3D data in the ASCII tecplot format that can be opened in either Tecplot or Paraview. </p> <p>See the section on post-processing for more details about how each of these are used. </p>"},{"location":"limitations/","title":"Limitations","text":"<ul> <li>OptVL does not support multiple run cases</li> <li>There is no floating point version of OptVL</li> </ul>"},{"location":"making_a_movie/","title":"How to make a movie","text":"<p>There are many methods to do this, the one that I cover here will use ParaView. </p>"},{"location":"making_a_movie/#getting-the-data-files","title":"Getting the data files","text":"<p>The 0-th step to making a movie/animation is to save the data that you want to visualize.  This data could come from a parameter sweep or optimization run for example.  The data read in by Tecplot and ParaView can be output using <code>ovl_solver.write_tecplot()</code>.  That is not a typo, ParaView can read in the Tecplot file format too, but unlike Tecplot is Free.  To make your life much easier in ParaView you should name your files with numbered suffix like <code>f'wing_{idx_iter}'</code>.  If you are using OptVL via the OpenMDAO group simply set the <code>write_grid</code> option to <code>True</code> when creating the group to write out these files, i.e. <code>OVLGroup(geom_file=\"rectangle.avl\", write_grid=True)</code>.</p>"},{"location":"making_a_movie/#load-the-data","title":"Load the data","text":"<p>When importing data into ParaView if you named your files file_001, file_0002, ... you will see them displayed as a stack (file_001, file_0002, ...).  Load the stack of data to bring all the iterations of your data into ParaView. </p> <p></p> <p>While loading that data be sure that the Tecplot reader is used. </p> <p></p>"},{"location":"making_a_movie/#setting-up-the-view","title":"Setting up the view","text":"<p>At first you won't be able to see that data. You will need to confirm that you want to load in the Cp data by hitting 'apply' and then clicking the eye to see your surface. </p> <p></p> <p>Setting the surface coloring to 'Cp' will show contours of 'Cp' on the surface. </p> <p></p> <p>To set the contours to your liking you will want to adjust it with the contour control bar.  To set the range manually you will need to click the icon with the 'C'.</p> <p></p> <p>If you loaded in the data as a stack you will be able to flip through it by stepping forward in time. </p> <p></p>"},{"location":"making_a_movie/#exporting-the-data-as-a-movieanimation","title":"Exporting the data as a movie/animation.","text":"<p>The final step is to export the data as a movie or animation.  From the file menu, simply select 'save animation'.</p> <p> </p> <p>I had some trouble exporting the data as a .avi file from ParaView 12.0, but version 13.4 worked well.  Following this process with the data from the planform optimization example, I get something like this. </p> <p></p>"},{"location":"making_a_script/","title":"Building a run script","text":"<p>Here we will go over the elements of setting up and running a basic analysis in OptVL in more detail.  To see a complete example of a run script see the one in the overview page or the examples on GitHub</p>"},{"location":"making_a_script/#initializing-and-setting-up-avl-solver","title":"Initializing and Setting up AVL Solver","text":"<p>To begin with <code>OptVL</code>, start by initializing the <code>OVLSolver</code> class:</p> <pre><code>ovl = OVLSolver(geo_file=\"aircraft.avl\")\n</code></pre> <p>Like AVL, you can also add a mass file as well. </p> <pre><code>ovl = OVLSolver(geo_file=\"aircraft.avl\", mass_file=\"aircraft.mass\")\n</code></pre>"},{"location":"making_a_script/#constraints","title":"Constraints","text":"<p>After initializing, you can set up various constraints directly. You can set <code>alpha</code>, <code>beta</code>, <code>roll rate</code>, <code>pitch rate</code>, and <code>yaw rate</code> as well as any control surface in this way. </p> <pre><code>ovl.set_constraint(\"alpha\", 0.00)\n</code></pre> <p>You can also set a variable in order to meet a specific constraint value.  The valid constraint options are <code>CL</code>, <code>CY</code>, <code>Cl roll moment</code>, <code>Cm pitch moment</code>, <code>Cn yaw moment</code>.</p> <p>Warning</p> <p>Be careful to state a constraint variable, <code>con_var</code>, that is affected by the input. For example if you accidentally specify that the pitching moment should be trimmed by the rudder the analysis will not converge. </p> <pre><code># set the Elevator to trim Cm to zero\novl.set_constraint(\"Elevator\", 0.00, con_var=\"Cm pitch moment\")\n# set the Rudder to trim Cn to zero\novl.set_constraint(\"Rudder\", 0.00, con_var=\"Cn yaw moment\")\n</code></pre> <p>You can also set parameters of the run case.  The list of parameters you can set are <code>CD0</code>, <code>bank</code>, <code>elevation</code>, <code>heading</code>, <code>Mach</code>, <code>velocity</code>, <code>density</code>, <code>grav.acc.</code>, <code>turn rad.</code>, <code>load fac.</code>, <code>X cg</code>, <code>Y cg</code>, <code>Z cg</code>, <code>mass</code>, <code>Ixx</code>, <code>Iyy</code>, <code>Izz</code>, <code>Ixy</code>, <code>Iyz</code>, <code>Izx</code>, <code>visc CL_a</code>, <code>visc CL_u</code>, <code>visc CM_a</code>, <code>visc CM_u</code>, <pre><code># set the flow parameters like mach numbers\novl.set_parameter(\"Mach\", 0.3)\n</code></pre></p>"},{"location":"making_a_script/#running-analysis","title":"Running Analysis","text":"<p>Once you've set up the solver, running the analysis is straightforward:</p> <pre><code>ovl.execute_run()\n</code></pre> <p>For a more detailed example and advanced use cases, see the analysis guide.</p>"},{"location":"making_a_script/#looking-at-data","title":"Looking at Data","text":"<p>After executing the run, then you can extract various output data from the solver. The methods for extracting data return a dictionary of data. </p> <p>To get things like CL, CD, CM, etc., use  <pre><code>force_data = ovl.get_total_forces()\n</code></pre> For stability derivatives such as <code>dCm/dAlpha</code> use <pre><code>stab_deriv = ovl.get_stab_derivs()\n</code></pre> And finally for control surface derivatives like <code>dCm/dElevator</code> use <pre><code>consurf_derivs = ovl.get_control_stab_derivs()\n</code></pre></p>"},{"location":"making_a_script/#running-an-optimization","title":"Running an Optimization","text":"<p>See optimization</p>"},{"location":"making_a_script/#visualization","title":"Visualization","text":"<p>The visualizations described in this section rely on the <code>matplotlib</code> package. </p>"},{"location":"making_a_script/#looking-at-the-geometry","title":"Looking at the geometry","text":"<p>To quickly look at your geometry you can use the <pre><code>ovl.plot_geom()\n</code></pre> command, which will produce a figure that looks like this.  </p>"},{"location":"making_a_script/#cp-plots","title":"Cp plots","text":"<p>To get a quick view of the coefficient of pressure on the surfaces of the aircraft you can use  <pre><code>ovl.plot_cp()\n</code></pre> Which will produce a plot like this. </p> <p> You can rotate, zoom, and pan in the window to look at different parts for the aircraft. </p>"},{"location":"modal_analysis/","title":"Modal Analysis","text":"<p>You can also perform eigenvalue analysis of the aircraft to characterize its dynamic stability.  Instead of calling <code>execute_run</code>, call <code>execute_eigen_mode_calc</code>. To run this type of analysis the aircraft should be in trim, so here we determine the CL necessary for lift = weight.  You must also set a velocity before the analysis with <code>ovl.set_parameter(\"velocity\", &lt;velocity&gt;)</code> You can retrieve the eigenvalues and vectors after the analysis with <code>get_eigenvalues</code> and <code>get_eigenvectors</code>. </p> <pre><code>from optvl import OVLSolver\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef syssho(asys):\n    \"\"\"\n    Prints out state-system matrix A in an organized manner.\n\n    Parameters\n    ----------\n    asys : ndarray (nsys x nsys)\n        State matrix A.\n    \"\"\"\n    nsys = asys.shape[0]\n\n    # Header\n    state_labels = [\"u\", \"w\", \"q\", \"the\", \"v\", \"p\", \"r\", \"phi\", \"x\", \"y\", \"z\", \"psi\"]\n    header = \" \".join(f\"{lab:&gt;10}\" for lab in state_labels) + \"   |\"\n    print(header)\n\n    # Rows\n    for i in range(nsys):\n        row_str = \"\".join(f\"{val:11.4f}\" for val in asys[i, :12])\n        print(row_str)\n\n\novl = OVLSolver(geo_file=\"aircraft.avl\", mass_file=\"aircraft.mass\", debug=False)\n\nvel = 10.0\n\novl.set_trim_condition(\"velocity\", 10.0)\novl.set_constraint(\"Elevator\", 0.00, con_var=\"Cm pitch moment\")\n\novl.execute_eigen_mode_calc()\nAmat = ovl.get_system_matrix(in_body_axis=True)\nsyssho(Amat)\n\n\nvals_ovl = ovl.get_eigenvalues()\n\n# plot the eigenvalues\nplt.plot(np.real(vals_ovl), np.imag(vals_ovl), \"o\")\nplt.xlabel(\"real\")\nplt.ylabel(\"imag\")\nplt.title(\"Eigenvalues\")\nplt.grid(\"on\")\nplt.show()\n# ----------------------------------------------------\n</code></pre> <p>The eigenvalues should look like this </p> <p></p>"},{"location":"optimization_overview/","title":"Optimization Overview","text":"<p>In general, you could connect OptVL to any gradient-free or gradient-based solver.  In these docs, I focus on gradient-based methods due to their greater efficiency.  OptVL provides the derivatives, but to perform gradient-based optimization you need to pass those derivatives to an optimizer.  However, here I'm going to show you the two ways I recommend connecting OptVL to an optimizer, Scipy and OpenMDAO. </p> <p>Between the two, I recommend Scipy if you are doing something with few design variables and do not already know OpenMDAO.  However, once you start incorporating more design variables and constraints or want to use a custom geometric parameterization, you are probably better off learning OpenMDAO.  If you are on the fence, I recommend giving OpenMDAO a try.  Your optimization problem will likely only grow more complex with time and OpenMDAO will make it easier to accommodate the growth in complexity.</p> <p>See optimization setup with Scipy see this page and to see optimization setup with OpenMDAO see this page</p>"},{"location":"optimization_overview/#tips","title":"Tips","text":"<ul> <li>Don't set trim constraints (e.g. CL = 0.5) on the OptVL solver; instead, set it as a constraint at the optimization level. The examples all show this. </li> <li>Some variables (like chord, dihedral, x and z leading edge position) can lead to local minima.     To help fix this, add a constraint that keeps the variable monotonic, or use a custom parameterization.</li> <li>Discontinuities can appear when moving flaps or ailerons due to sparse paneling. Use section paneling for this case to preserve good paneling at the edges of the control surfaces.  </li> </ul>"},{"location":"optimization_setup_om/","title":"Optimizing with OpenMDAO","text":"<p>If you don't already have OpenMDAO, you can install it with <code>pip install OpenMDAO</code></p> <p>OpenMDAO doesn't actually do any of the optimization, it is simply a convenient framework for forming models for optimization.  It installs SciPy along with its optimizer as a dependency during the installation process.  If you want access to additional optimizers, I recommend the pyOptSparse library.</p>"},{"location":"optimization_setup_om/#adding-optvl-to-a-model","title":"Adding OptVL to a model","text":"<p>OptVL comes with OpenMDAO components to make it simple to include it into an OpenMDAO model.  All the hard/tedious work of specifying how the gradient functions should be called is already done for you in this group.  Simply import the group and add it to your model.  <pre><code>import openmdao.api as om\nfrom optvl import OVLGroup\n\nmodel = om.Group()\nmodel.add_subsystem(\"ovlsolver\", OVLGroup(geom_file=\"aircraft.avl\", mass_file=\"aircraft.mass\"))\n</code></pre> All the geometric variables and <code>alpha</code> and <code>beta</code> are automatically exposed as inputs to the group.  The geometric variables of each surface are added as inputs of the form <code>&lt;surface name&gt;:&lt;geo variable&gt;</code>. To turn on other inputs such as the reference values and case parameters, use the \"input_param_vals\" and \"input_ref_vals\" keywords to the group, respectively. <pre><code>model.add_subsystem(\"ovlsolver\", OVLGroup(geom_file=\"aircraft.avl\",input_param_vals=True, input_ref_vals=True))\n</code></pre> The force coefficients such as <code>CL</code>, <code>CD</code>, and <code>CM</code> are automatically added as outputs. To add stability derivatives or control surface derivatives as outputs, just use the <code>output_stability_derivs</code> and <code>output_con_surf_derivs</code> keyword arguments to the group to turn them on.  <pre><code>model.add_subsystem(\"ovlsolver\", OVLGroup(geom_file=\"aircraft.avl\", output_stability_derivs=True, output_con_surf_derivs=True))\n</code></pre></p>"},{"location":"optimization_setup_om/#output-options","title":"Output options","text":"<p>To write out the AVL geometry and the TecPlot surface CP file at every time step, use the option <code>write_grid=True</code>.  Additionally, if you are not interested in viewing the files in ParaView and instead only want to use TecPlot 360, then I also recommend adding <code>write_grid_sol_time=True</code>.</p> <pre><code>model.add_subsystem(\"ovlsolver\", OVLGroup(geom_file=\"aircraft.avl\", write_grid=True))\n# for easier postprocessing in TecPlot 360 (not compatible with ParaView)\nmodel.add_subsystem(\"ovlsolver\", OVLGroup(geom_file=\"aircraft.avl\", write_grid=True, write_grid_sol_time=True ))\n</code></pre>"},{"location":"optimization_setup_om/#setting-design-variables","title":"Setting design variables","text":"<p>For simple optimization problems, the inputs and outputs can be directly added as design variables, objective functions, and constraints. </p> <pre><code># directly setting the inputs as design variables\nmodel.add_design_var(\"ovlsolver.Wing:aincs\", lower=-10, upper=10)\nmodel.add_design_var(\"ovlsolver.Elevator\", lower=-10, upper=10)\n\n# the outputs of OptVL can be used as constraints\nmodel.add_constraint(\"ovlsolver.CL\", equals=1.5)\nmodel.add_constraint(\"ovlsolver.CM\", equals=0.0, scaler=1e3)\n\n# the scaler values bring the objective function to ~ order 1 for the optimizer\nmodel.add_objective(\"ovlsolver.CD\", scaler=1e3)\n</code></pre>"},{"location":"optimization_setup_om/#setting-optimizer-options-and-running","title":"Setting Optimizer options and running","text":"<p>After you have set up your model you will have to apply a driver.  In our case our driver is the SLSQP optimizer of SciPy, but you could also apply other drivers to the model such as the DOE driver.</p> <p>The next step is to tell OpenMDAO we are done with our problem, and it can be set up with <code>prob.setup(mode='rev')</code></p> <p>Warning</p> <p>When using the OptVL group we must setup the problem with <code>mode='rev'</code>.  OptVL uses reverse mode derivatives because in general we will have more geometric variables than output functions of interest.</p> <p>The line with <code>om.n2</code> creates an N2 diagram, which is helpful for examining our model.  See this page for more information on the N2 diagram.</p> <pre><code>prob = om.Problem(model)\n\nprob.driver = om.ScipyOptimizeDriver()\nprob.driver.options['optimizer'] = 'SLSQP'\nprob.driver.options['debug_print'] = [\"desvars\", \"ln_cons\", \"nl_cons\", \"objs\"]\nprob.driver.options['tol'] = 1e-6\nprob.driver.options['disp'] = True\n\nprob.setup(mode='rev')\nom.n2(prob, show_browser=False, outfile=\"vlm_opt.html\")\nprob.run_driver()\n</code></pre>"},{"location":"optimization_setup_om/#example-script","title":"Example script","text":"<p>Below is an OpenMDAO script analogous to the SciPy-based example. </p> <p><pre><code>\"\"\"A openmdao based optimization for an aicraft using optvl\"\"\"\n\nimport openmdao.api as om\nfrom optvl import OVLGroup\n\nmodel = om.Group()\nmodel.add_subsystem(\"ovlsolver\", OVLGroup(geom_file=\"aircraft.avl\"))\n\n# look at vlm_opt.html to see all the design variables and add them here\nmodel.add_design_var(\"ovlsolver.Wing:aincs\", lower=-15, upper=15)\nmodel.add_design_var(\"ovlsolver.Elevator\", lower=-10, upper=10)\n\n# the outputs of OptVL can be used as contraints\nmodel.add_constraint(\"ovlsolver.CL\", equals=1.5)\nmodel.add_constraint(\"ovlsolver.CM\", equals=0.0, scaler=1e3)\n\n# the scaler values bring the objective functinon to ~ order 1 for the optimizer\nmodel.add_objective(\"ovlsolver.CD\", scaler=1e3)\n\nprob = om.Problem(model)\n\nprob.driver = om.ScipyOptimizeDriver()\nprob.driver.options[\"optimizer\"] = \"SLSQP\"\nprob.driver.options[\"debug_print\"] = [\"desvars\", \"ln_cons\", \"nl_cons\", \"objs\"]\nprob.driver.options[\"tol\"] = 1e-10\nprob.driver.options[\"disp\"] = True\n\nprob.setup(mode=\"rev\")\n# this causes and error with OpenMDAO 3.38 (https://github.com/OpenMDAO/OpenMDAO/issues/3521)\n# om.n2(prob, show_browser=False, outfile=\"vlm_opt.html\")\nprob.run_driver()\nom.n2(prob, show_browser=False, outfile=\"vlm_opt.html\")\n\ndel_ele = prob.get_val(\"ovlsolver.Elevator\")\nprint(f\"ovlsolver.Elevator {del_ele}\")\naincs = prob.get_val(\"ovlsolver.Wing:aincs\")\nprint(f\"ovlsolver.Wing:aincs {aincs}\")\ncd = prob.get_val(\"ovlsolver.CD\")\nprint(f\"ovlsolver.CD {cd}\")\n# do this instead if you want to check derivatives\n# prob.run_model()\n# prob.check_totals()\n</code></pre> Which outputs</p> <p><pre><code>Optimization terminated successfully    (Exit mode 0)\n            Current function value: 85.54669279688602\n            Iterations: 19\n            Function evaluations: 19\n            Gradient evaluations: 19\nOptimization Complete\n-----------------------------------\novlsolver.Elevator [0.10802368]\novlsolver.Wing:aincs [11.46493221  1.92748591  2.14445549  2.27131259 -4.81944669]\novlsolver.CD [0.08554669]\n</code></pre> Which is about the same optimized result we got from the SciPy-only based optimization. </p>"},{"location":"optimization_setup_scipy/","title":"Optimizing with SciPy","text":"<p>Before we can use SciPy, we have to install it.  Thankfully, SciPy is one of the best supported python packages in the world, so to install it one can just use <code>pip install scipy</code>.</p> <p>SciPy has many optimizers available, but I'm going to focus on using SLSQP since it can use the gradient information from OptVL and supports constraints.  To use SciPy's SLSQP, we will need to supply it with custom objective and constraint functions as well as the derivatives for each.  These functions need to take in the design variables and apply them to our OptVL solver.  The snippet below provides an example of an objective function. <pre><code> def objective_function(x):\n    ovl.set_constraint(\"Elevator\", x[0])\n    ovl.set_surface_params({\"Wing\":{\"aincs\":x[1:]}})\n\n    ovl.execute_run()\n    cd = ovl.get_total_forces()['CD']\n    print(x, cd)\n\n    return cd\n</code></pre> Note: the objective function is specified by the return value of the function.  If you wanted to save data about each iteration or write output, the objective function would be a good place to add that functionality.  To supply the gradient information to SLSQP, we have to define another function that returns the gradients for a given design variable vector. <pre><code>def objective_gradient(x):\n    # Partial derivatives of the objective_function\n    ovl.set_constraint(\"Elevator\", x[0])\n    ovl.set_surface_params({\"Wing\":{\"aincs\":x[1:]}})\n\n    ovl.execute_run()\n\n    sens = ovl.execute_run_sensitivities(['CD'])\n    dcd_dele = sens['CD']['Elevator']\n    dcd_daincs = sens['CD']['Wing']['aincs']\n\n    # concatinate the two and return the derivs\n    return np.concatenate(([dcd_dele], dcd_daincs))\n</code></pre> The function <code>ovl.execute_run_sensitivities(['CD'])</code> does all the necessary work to compute the derivatives for the given list of functions.  We just need to parse the <code>sens</code> dictionary for the derivatives with respect to the design variables we are interested in.</p> <p>One also needs to repeat the process for the constraints. This involves creating functions for both the constraint values and their corresponding gradients.</p>"},{"location":"optimization_setup_scipy/#example-script","title":"Example script","text":"<p>The script below shows the full optimization script for minimizing the drag of the example aircraft in trim, with respect to the wing twist and elevator position. </p> <pre><code>\"\"\"A scipy based optimization to trim an aircraft for an aicraft using optvl\"\"\"\n\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom optvl import OVLSolver\n\novl_solver = OVLSolver(geo_file=\"aircraft.avl\", debug=False)\n\n# setup OptVL\novl_solver.set_parameter(\"Mach\", 0.0)\n\n\n# Define your custom objective function with outputs from OptVL\ndef objective_function(x):\n    ovl_solver.set_constraint(\"Elevator\", x[0])\n    ovl_solver.set_surface_params({\"Wing\": {\"aincs\": x[1:]}})\n\n    ovl_solver.execute_run()\n    cd = ovl_solver.get_total_forces()[\"CD\"]\n    print(x, cd)\n\n    return cd\n\n\ndef objective_gradient(x):\n    # Partial derivatives of the objective_function\n\n    # we are trusting that the design variables have already been applied\n    # and propogated through by the objective_function.\n\n    ovl_solver.set_constraint(\"Elevator\", x[0])\n    ovl_solver.set_surface_params({\"Wing\": {\"aincs\": x[1:]}})\n\n    ovl_solver.execute_run()\n\n    sens = ovl_solver.execute_run_sensitivities([\"CD\"])\n    dcd_dele = sens[\"CD\"][\"Elevator\"]\n    dcd_daincs = sens[\"CD\"][\"Wing\"][\"aincs\"]\n\n    # concatinate the two and return the derivs\n    return np.concatenate(([dcd_dele], dcd_daincs))\n\n\n# Define equality constraint: h(x) = 0\ndef eq_constraint(x):\n    ovl_solver.set_constraint(\"Elevator\", x[0])\n    ovl_solver.set_surface_params({\"Wing\": {\"aincs\": x[1:]}})\n\n    ovl_solver.execute_run()\n\n    # the objective must always be run first\n    coeff = ovl_solver.get_total_forces()\n\n    cl_target = 1.5\n    cm_target = 0.0\n\n    cl_con = coeff[\"CL\"] - cl_target\n    cm_con = coeff[\"CM\"] - cm_target\n\n    return np.array([cl_con, cm_con])\n\n\n# Define the gradient of the equality constraint\ndef eq_constraint_jac(x):\n    sens = ovl_solver.execute_run_sensitivities([\"CL\", \"CM\"])\n    dcl_dele = sens[\"CL\"][\"Elevator\"]\n    dcl_daincs = sens[\"CL\"][\"Wing\"][\"aincs\"]\n    dcl_dx = np.concatenate(([dcl_dele], dcl_daincs))\n\n    dcm_dele = sens[\"CM\"][\"Elevator\"]\n    dcm_daincs = sens[\"CM\"][\"Wing\"][\"aincs\"]\n    dcm_dx = np.concatenate(([dcm_dele], dcm_daincs))\n\n    # concatinate the two and return the derivs\n    return np.array([dcl_dx, dcm_dx])\n\n\nnum_sec = 5\n# Initial guess for the variables\nx0 = np.zeros(1 + num_sec)\n\n# Define constraints with their gradients\nconstraints = [\n    {\"type\": \"eq\", \"fun\": eq_constraint, \"jac\": eq_constraint_jac},  # Equality constraint\n]\n\n# Call the minimize function with constraints and their gradients\nresult = minimize(\n    fun=objective_function,  # The objective function to minimize\n    jac=objective_gradient,  # The gradient function of the objective\n    x0=x0,  # Initial guess\n    constraints=constraints,  # Constraints with gradients\n    method=\"SLSQP\",  # Optimization method that supports constraints\n    options={\"disp\": True},  # Display convergence messages\n    tol=1e-10,\n)\n\n# Print the result\nprint(\"Optimization result:\")\nopt_x = result.x\nprint(f\"Elevator: {opt_x[0]}\")\nprint(f\"Wing twist: {opt_x[1:]}\")\nprint(f\"Final CD: {result.fun}\")  # Final value of the objective function\n</code></pre> <p>Which should produce the output after the optimization <pre><code>Optimization terminated successfully    (Exit mode 0)\n            Current function value: 0.08551861616299436\n            Iterations: 56\n            Function evaluations: 58\n            Gradient evaluations: 56\nOptimization result:\nElevator: 0.09925034689068805\nWing twist: [11.51424344  2.00085521  2.20301866  2.32160102 -4.79748301]\nFinal CD: 0.08551861616299436\n</code></pre></p>"},{"location":"optvl_api/","title":"Comparison of Interface with AVL","text":"<p>The API was made to mirror that of AVL. However, instead of using nested layers of options, users call the methods for getting/setting options and running analysis on <code>OVLSolver</code> objects. The tables below relate AVL commands and the corresponding method in OptVL. See the limitations sections for more information about commands that are not available in OptVL.</p> action AVL's  \"AVL\" level command OptVL API call load a geometry LOAD  OVLSolver(geo_file=) load a mass file MASS  OVLSolver(geo_file=, mass_file=) load a run case file CASE  not supported apply mass file MSET 0 done automatically action AVL's \"OPER\" command OptVL API call setting the angle of attack a a  ovl.set_constraint(\"alpha\", ) set variable such that constraint = val ovl.set_constraint(, , con_var=) set CL  constraint c1; c 1.3 ovl.set_trim_condition(\"CL\", 1.3) run an analysis x ovl.execute_run() after an analysis FT ovl.get_total_forces() get strip force data ST ovl.get_strip_forces() get shear moment distribution VM ovl.get_strip_forces() get control surface derivatives (e.g. dCL/dElevator) ST ovl.get_control_derivs() get stability derivatives ST ovl.get_stab_derivs() get stability derivatives in the body axis SB - get/set reference data RE ovl.get_reference_data/set_reference_data() get/set  design variables specified in AVL file DE - get surface forces FN ovl.get_surface_forces() get force distribution on strips FS ovl.get_strip_forces() get force distribution on elements FE - get body forces FB - get high moments HM ovl.get_hinge_moments() action AVL's mode level command OptVL API call get/set case parameters M  ovl.get_reference_data()/set_reference_data(, ) get system matrix S ovl.get_system_matrix() get eigenvalues W ovl.get_eigen_values() get eigenvectors not supported ovl.get_eigen_vectors() execute eigenmode calculation N ovl.execute_eigen_mode_calc()"},{"location":"optvl_api/#limitations","title":"Limitations","text":"<ol> <li>OptVL does not support multiple run cases since this would make the wrapping and derivative code more complex. Instead, create multiple solver instances and apply different parameters to each to replicate this functionality. </li> <li>There is no single precision version of OptVL available for download. You could compile one yourself if you really need this.</li> <li>No support for working with design variables set in the AVL geometry file since we use a different system for modifying the geometry that allows the user to change any geometric parameter.</li> </ol>"},{"location":"optvl_changes_from_avl/","title":"Changes in OptVL relative to AVL","text":"<p>Overall OptVL maintains the exact same behavior as the original AVL source codes with the following explicit exceptions. Any other observed differences between OptVL and AVL beyond what is listed here is a bug and should be reported here.</p>"},{"location":"optvl_changes_from_avl/#mach-number-from-geometry-file-is-set","title":"Mach number from geometry file is set","text":"<p>AVL does not use the Mach number specified in the geometry file. I believe this is a bug and have set the initial Mach number used for an anlysis to the value in the geometry file</p>"},{"location":"optvl_changes_from_avl/#x-cg-y-cg-z-cg-of-mass-file-always-set","title":"X cg, Y cg, Z cg of mass file always set","text":"<p>For some reason if you try to implicitly load the mass file into AVL using <code>avl aircraft</code> the cg location parameters would not be updated.  If you used the more traditional <code>mass aircraft.mass</code> and <code>mset 0</code> approach then AVL would set the cg parameters correctly. OptVL always sets the all the data from the mass file including the cg location.</p>"},{"location":"optvl_changes_from_avl/#the-modal-system-matrix","title":"The modal system matrix","text":"<p>Before writing the system matrix used for the modal analysis to screen, AVL multiplies rows and columns associates with u,w,p,r,x, and z by -1.  I believe this is done to change the frame from the geometry-axis to the body-axis, which is usually the frame of the equations of motion. However, the eigenvectors found correspond to the unmodified matrix in AVL and OptVL. I have chosen to return the matrix that fits the eigenvectors returned and thus does not have the sign changes. One can get the modified matrix by using the <code>in_body_axis</code> option when getting the matrix from OptVL like this`get_system_matrix(in_body_axis=True)</p>"},{"location":"overview/","title":"Basic Usage Overview","text":"<p><code>OptVL</code> offers a Python API mirroring AVL's text interface. The typical workflow involves loading a geometry file, adding constraints, and executing analysis runs. In addition to this, though, OptVL also offers unique optimization functionality. </p> <p>Below is an example of a basic analysis run, to give you an idea of the workflow. </p> <pre><code>from optvl import OVLSolver\n\novl = OVLSolver(geo_file=\"aircraft.avl\", debug=False)\nimport pdb; pdb.set_trace()\n\n# look at the geometry to see that everything is right\novl.plot_geom()\n\n# set the angle of attack\novl.set_constraint(\"alpha\", 0.00)\n\n# set the deflection of the elevator to trim the pitching moment\novl.set_constraint(\"Elevator\", 0.00, con_var=\"Cm pitch moment\")\n\novl.set_parameter(\"Mach\", 0.3)\n\n# This is the method that acutally runs the analysis\novl.execute_run()\n\n# print data about the run\nforce_data = ovl.get_total_forces()\nprint(f\"CL:{force_data['CL']:10.6f}   CD:{force_data['CD']:10.6f}   CM:{force_data['CM']:10.6f}\")\n\n# lets look at the cp countours\novl.plot_cp()\n</code></pre> <p>The script will plot the geometry, set parameters, run an analysis, and then show a CP surface plot.</p> <p>The geometry plot should look like this   and the CP surface plot should look like this  You can rotate, zoom, and pan in the window to look at different parts for the aircraft. </p>"},{"location":"overview/#limitations","title":"Limitations","text":"<ol> <li>OptVL does not support multiple run cases</li> </ol> <ol> <li>No support for the DESIGN keyword for setting twist in the avl geometry file since we use a different system for modifying all aspects of the geometry.</li> <li>OptVL on Windows can only use a maximum of 5000 vortices compared to the default of 6000. </li> </ol>"},{"location":"parameter_sweeps/","title":"Modifying Geometry for Parameter Sweeps","text":"<p>OptVL not only offers aerodynamic analysis capabilities but also provides tools to access and modify geometric parameters of your aircraft models. This page shows how users can retrieve and set geometry parameters for parameter sweeps.</p>"},{"location":"parameter_sweeps/#getting-geometry-parameters","title":"Getting geometry parameters","text":"<p>To retrieve surface parameters from your AVL model, use the <code>get_surface_params</code> method. By default, this method only returns data about the geometry of the surface, but information about the paneling and control surfaces can also be included by passing the corresponding flags, like so:  <pre><code>surf_data = ovl.get_surface_params(\n    include_geom=True,\n    include_paneling=True,\n    include_con_surf=True\n)\n</code></pre> The data from <code>get_surface_params</code> come directly from the geometry file used by AVL. See the AVL user guide for more information about all the possible variables. If you only want to get a specific design variable, then you can instead use: <pre><code>ovl.get_surface_param( &lt;surf_name&gt;, &lt;param&gt;)\n</code></pre> For most use cases, you will only need to interact with the geometric variables below. </p> Variable Description scale Scale factor. translate Translation vector. angle Surface angle. aincs Array of angle increments. chords Array of chord lengths. xyzles Array of leading edge coordinates."},{"location":"parameter_sweeps/#setting-geometry-parameters","title":"Setting geometry parameters","text":"<p>To apply geometry changes to the OVLSolver object, use the <code>set_surface_params</code> method. <pre><code>ovl_solver.set_surface_params(data)\n</code></pre> This method sets the surface parameters of the AVL model based on the provided dictionary data. The data passed to this method must be a dictionary of surface names whose values are a dictionary of surface and section keywords. An example of such a dictionary is: <pre><code>data = {\n    'Wing': {\n        'angle': 3.5,  # a surface keyword example\n        \"chords\": np.array([0.5, 0.4, 0.3, 0.2, 0.1]) #section keyword example\n    }\n}\n</code></pre> The structure of the data dictionary must be the same as that returned by the <code>get_surface_params</code> method, so I recommend calling <code>get_surface_params</code> and looking at the output if you get confused: Similar to the getting methods, you can also set values one at a time like so: <pre><code>ovl.set_surface_param( &lt;surf_name&gt;, &lt;param&gt;, &lt;value&gt;)\n</code></pre></p>"},{"location":"parameter_sweeps/#example-modifying-y-scale","title":"Example modifying y scale","text":"<p>To increase the span of our wing, we can stretch it in the y direction by adjusting the y scale. </p> <pre><code>from optvl import OVLSolver\nimport numpy as np\n\nwrite_tecplot_files = True\n\novl_solver = OVLSolver(geo_file=\"aircraft.avl\", debug=False, timing=False)\n\n# set the angle of attack\novl_solver.set_constraint(\"alpha\", 5.00)\n\nfor idx_scale, y_scale in enumerate(np.linspace(0.5, 1.5, 5)):\n    ovl_solver.set_surface_params({\"Wing\": {\"scale\": np.array([1, y_scale, 1])}})\n\n    ovl_solver.execute_run()\n    stab_derivs = ovl_solver.get_stab_derivs()\n\n    print(f\"----------------- y_scale: {y_scale} ----------------\")\n    for key in stab_derivs:\n        print(f\"{key:16}: {stab_derivs[key]:.6f}\")\n\n    if write_tecplot_files:\n        # this way works on tecplot and paraview\n        ovl_solver.write_tecplot(f\"wing_scale_{idx_scale}\")\n\n        # Warning: The solution time does not work on paraview\n        # ovl_solver.write_tecplot(f'wing_scale_{y_scale}', solution_time=idx_scale)\n</code></pre>"},{"location":"parameter_sweeps/#example-modifying-the-leading-edge-coordinates","title":"Example modifying the leading edge coordinates","text":"<p>The example below modifies the array of leading edge points to modify the planform. </p> <pre><code>from optvl import OVLSolver\nimport numpy as np\nfrom pprint import pprint\nimport matplotlib.pyplot as plt\n\n\novl_solver = OVLSolver(geo_file=\"rectangle.avl\", debug=False, timing=False)\n\n# set the angle of attack\n# ovl_solver.set_constraint(\"alpha\", 5.00)\nyles = ovl_solver.get_surface_param(\"Wing\", \"yles\")\nxles = ovl_solver.get_surface_param(\"Wing\", \"xles\")\nzles = ovl_solver.get_surface_param(\"Wing\", \"zles\")\nspan = yles[-1]\nrelative_span = yles / span\n\n\n# Parameters\n# params = ['xles', 'zles', 'yles']\nvalues = {\"xles\": xles, \"zles\": zles, \"yles\": yles}\n\n# Loop over each parameter type\nfor param, value in values.items():\n    # Create subplots\n    ax1 = plt.subplot(2, 1, 1)\n    ax2 = plt.subplot(2, 1, 2)\n    ax2.set_ylabel(\"Z\", rotation=0)\n    ax2.set_xlabel(\"Y\")\n    ax1.set_ylabel(\"X\", rotation=0)\n    ax1.set_title(f\"Modifying {param}\")\n\n    # Perform parameter sweep\n    for d in np.linspace(-0.33 * span, 0.33 * span, 3):\n        new_value = value + d * relative_span\n        ovl_solver.set_surface_param(\"Wing\", param, new_value)\n        ovl_solver.plot_geom(axes=[ax1, ax2])\n\n    # Reset to baseline\n    ovl_solver.set_surface_param(\"Wing\", param, value)\n\n    # Show plot\n    plt.show()\n</code></pre> <p>Running the script generates the following plots showing the modifications to the geometry.</p> <p> </p>"},{"location":"planform_optimization/","title":"Planform optimization","text":"<p>This is a considerably more advanced tutorial that aims to represent a more realistic optimization problem.  We are going to optimize the planform of a flying wing for maximum glide duration. In this example, we are going to walk through the planform optimization starting from a rectangular wing.  We are going to modify the sweep of the wing with a custom parameterization that takes in the sweep design variable and sets the y coordinates of the leading edge accordingly.  We add additional OpenMDAO components to add this additional functionality to our optimization.  This is the power of OpenMDAO!</p>"},{"location":"planform_optimization/#custom-parameterization","title":"Custom parameterization","text":"<p>AVL defines the geometry at each section; however, wing planforms are generally defined with parameters that affect all sections such as sweep and taper ratio.  To modify the geometry according to traditional planform variables we need to define a custom geometry component.  The OpenMDAO Component below takes in the root chord, quarter chord sweep angle, and taper ratio and produces the sectional geometry needed by OptVL: <pre><code>class GeometryParametrizationComp(om.ExplicitComponent):\n    def setup(self):\n        # Input variables\n        self.add_input(\"yles_in\", shape_by_conn=True, desc=\"Baseline y leading edge coordinates\")\n        self.add_input(\"root_chord\", val=1.0, desc=\"Baseline y leading edge coordinates\")\n        self.add_input(\"c/4_sweep\", val=0.0, desc=\"shear Sweep\")\n        self.add_input(\"taper_ratio\", val=1.0, desc=\"taper ratio of the wing\")\n        self.add_input(\"dihedral\", val=0.0, desc=\"dihedral of wing\")\n\n        # Output variables\n        self.add_output(\"xles_out\", copy_shape=\"yles_in\", desc=\"Transformed xyz leading edge coordinates\")\n        self.add_output(\"zles_out\", copy_shape=\"yles_in\", desc=\"Transformed xyz leading edge coordinates\")\n        self.add_output(\"chords_out\", copy_shape=\"yles_in\", desc=\"Transformed chord array\")\n\n        # Finite difference partials\n        self.declare_partials(\"*\", \"*\", method=\"cs\")\n\n    def compute(self, inputs, outputs):\n        # Extracting input values\n        yles = inputs[\"yles_in\"]\n        span = yles[-1]\n        relative_span = yles / span\n        chord_root = inputs[\"root_chord\"]\n\n        tr = inputs[\"taper_ratio\"]\n        chords = ((tr - 1) * relative_span + 1) * chord_root\n\n        zles = inputs[\"dihedral\"] * relative_span\n\n        # do some math to figure out the quarter chord sweeep\n        outputs[\"xles_out\"] = inputs[\"c/4_sweep\"] * relative_span + (chord_root - chords) / 4\n        outputs[\"zles_out\"] = zles\n        outputs[\"chords_out\"] = chords\n</code></pre></p> <p>However, the component also needs the baseline section y coordinates. To supply this value we add a mesh component upstream of the geometry parameterization.  If the parameterization did not rely on these baseline values this would not be necessary. The N2 diagram below shows how by placing a mesh component upstream of the geometry component, we can use the baseline values in our parameterization. </p> <p></p>"},{"location":"planform_optimization/#mass-properties","title":"Mass properties","text":"<p>When modifying the planform, it is important to consider how the center of gravity and overall weight will be affected by the modification.  To incorporate these effects into the model, a basic mass properties component recomputes these properties based on the planform.  This component assumes that the aircraft is cut from a material of uniform density (such as foam) to make the calculation easier.  <pre><code>class MassProperties(om.ExplicitComponent):\n    # compute the new estimated center of gravity\n    # the weight of each section is proportional to the planform area\n\n    def initialize(self):\n        self.options.declare(\"density\", types=float, default=1.0, desc=\"volume density of building material in kg/m**3\")\n\n    def setup(self):\n        # input variables\n        self.add_input(\"xles\", shape_by_conn=True, desc=\"Baseline x leading edge coordinates\", units=\"m\")\n        self.add_input(\"yles\", shape_by_conn=True, desc=\"Baseline y leading edge coordinates\", units=\"m\")\n        self.add_input(\"chords\", shape_by_conn=True, desc=\"chord distribution\", units=\"m\")\n\n        self.add_output(\"x_cg\", desc=\"x postion of the CG in the same axis as the xles coordinate\", units=\"m\")\n        self.add_output(\"weight\", desc=\"estimated weight of the airplane\", units=\"N\")\n        self.add_output(\"area\", desc=\"planform area\", units=\"m**2\")\n\n        # Finite difference partials\n        self.declare_partials(\"*\", \"*\", method=\"cs\")\n\n    def compute(self, inputs, outputs):\n        xles = inputs[\"xles\"]\n        yles = inputs[\"yles\"]\n        chords = inputs[\"chords\"]\n\n        density = self.options[\"density\"]\n        g = 9.81  # acceleration due to gravity\n\n        k = 0.680883333333  # areea of a NACA 4 digit airfoil for unit chord divied by thickness from http://louisgagnon.com/scBlog/airfoilCenter.html\n        t = 0.12  # thicknes of airfoil\n        f = 0.4  # approximate centroid of an airfoil\n        # area is  t*c = 0.680883333333*(0.12*c)*c\n\n        # we are going to find the mass, and center of mass for each of the wing sections\n        # we assume that the wing is of uniform density\n        x_cg = 0\n        mass = 0\n        xcg_numerator = 0\n        planform_area = 0\n        for idx in range(len(xles) - 1):\n            x1 = xles[idx]\n            y1 = yles[idx]\n            c1 = chords[idx]\n\n            x2 = xles[idx + 1]\n            y2 = yles[idx + 1]\n            c2 = chords[idx + 1]\n            dy = y2 - y1\n\n            planform_area += 0.5 * (c1 + c2) * dy  # area of trapizoid\n\n            s = (c2 - c1) / dy  # change in chord per span\n\n            mass += density * k * t * (s**2 * dy**3 / 3 + s * c1 * dy**2 + c1**2 * dy)\n\n            m = (x2 - x1) / dy  # change in xles per span\n\n            A = m + f * s\n            B = x1 + f * c1\n\n            xcg_numerator += (\n                density\n                * t\n                * k\n                * (\n                    A / 4 * s**2 * dy**4\n                    + 2 * A / 3 * s * c1 * dy**3\n                    + A / 2 * c1**2 * dy**2\n                    + B / 3 * s**2 * dy**3\n                    + 2 * B / 2 * s * c1 * dy**2\n                    + B * c1**2 * dy\n                )\n            )\n\n        x_cg = xcg_numerator / mass\n\n        if not self.under_approx:\n            print(\"Weight \", mass * g, \"x_cg\", x_cg)\n\n        outputs[\"weight\"] = mass * g\n        outputs[\"x_cg\"] = x_cg\n        outputs[\"area\"] = planform_area\n</code></pre></p>"},{"location":"planform_optimization/#custom-objective","title":"Custom Objective","text":"<p>Instead of minimizing drag like the prior optimization examples, here I use the outputs of OptVL to compute the glide duration. This is done with another OpenMDAO component that uses the mass properties and CL and CD of the candidate design.  The glide duration is calculated assuming a steady glide from a fixed height (100 meters).</p> <pre><code>class GlidingFlight(om.ExplicitComponent):\n    def setup(self):\n        self.add_input(\"weight\", desc=\"weight of the aircraft\", units=\"N\")\n        self.add_input(\"CL\", desc=\"lift coefficent of the aicraft\")\n        self.add_input(\"CD\", desc=\"drag coefficent\")\n        self.add_input(\"Sref\", desc=\"planform area\", units=\"m**2\")\n        self.add_input(\"height\", val=100, desc=\"height of the glider from the ground\", units=\"m\")\n        self.add_input(\"density_air\", val=1.225, desc=\"density of air you are gliding in\", units=\"kg/m**3\")\n\n        self.add_output(\"glide_angle\", desc=\"the glide angle of the descent\")\n        self.add_output(\"duration\", desc=\"the glide angle of the descent\", units=\"s\")\n\n        self.declare_partials(\"*\", \"*\", method=\"cs\")\n\n    def compute(self, inputs, outputs):\n        cl = inputs[\"CL\"]\n        cd = inputs[\"CD\"]\n        rho = inputs[\"density_air\"]\n        weight = inputs[\"weight\"]\n        Sref = inputs[\"Sref\"]\n\n        # determine the glide angle from the lift to drag\n        theta = np.arctan(cd / cl)\n\n        # based on the weight deterimne the rate of descent such that lift = cos(theta)*weight - sind(theta)*cd\n        a = rho / 2 * Sref\n        coef = cl * np.cos(theta) + cd * np.sin(theta)\n\n        v_mag = np.sqrt((weight / (a * coef)))\n        v_descent = v_mag * np.sin(theta)\n\n        # the duration is the height divied by the descent velocity\n        duration = inputs[\"height\"] / v_descent\n\n        outputs[\"glide_angle\"] = theta * 180 / np.pi\n        outputs[\"duration\"] = duration\n\n        if not self.under_approx:\n            print(\"L/D\", cl / cd, \"glide_angle\", np.rad2deg(theta), \"duration\", duration)\n</code></pre>"},{"location":"planform_optimization/#example-script","title":"Example Script","text":"<p>Combining all these components into the OpenMDAO model we get the following script. </p> <pre><code>\"\"\"A openmdao based optimization for an aicraft using optvl\"\"\"\n\n# the x-start and x-end comments are for integration with the documentation\n# they are not necessary for normal scripts\nimport openmdao.api as om\nfrom optvl import OVLGroup, Differencer, OVLMeshReader\nimport numpy as np\n\n\n# geom-start\nclass GeometryParametrizationComp(om.ExplicitComponent):\n    def setup(self):\n        # Input variables\n        self.add_input(\"yles_in\", shape_by_conn=True, desc=\"Baseline y leading edge coordinates\")\n        self.add_input(\"root_chord\", val=1.0, desc=\"Baseline y leading edge coordinates\")\n        self.add_input(\"c/4_sweep\", val=0.0, desc=\"shear Sweep\")\n        self.add_input(\"taper_ratio\", val=1.0, desc=\"taper ratio of the wing\")\n        self.add_input(\"dihedral\", val=0.0, desc=\"dihedral of wing\")\n\n        # Output variables\n        self.add_output(\"xles_out\", copy_shape=\"yles_in\", desc=\"Transformed xyz leading edge coordinates\")\n        self.add_output(\"zles_out\", copy_shape=\"yles_in\", desc=\"Transformed xyz leading edge coordinates\")\n        self.add_output(\"chords_out\", copy_shape=\"yles_in\", desc=\"Transformed chord array\")\n\n        # Finite difference partials\n        self.declare_partials(\"*\", \"*\", method=\"cs\")\n\n    def compute(self, inputs, outputs):\n        # Extracting input values\n        yles = inputs[\"yles_in\"]\n        span = yles[-1]\n        relative_span = yles / span\n        chord_root = inputs[\"root_chord\"]\n\n        tr = inputs[\"taper_ratio\"]\n        chords = ((tr - 1) * relative_span + 1) * chord_root\n\n        zles = inputs[\"dihedral\"] * relative_span\n\n        # do some math to figure out the quarter chord sweeep\n        outputs[\"xles_out\"] = inputs[\"c/4_sweep\"] * relative_span + (chord_root - chords) / 4\n        outputs[\"zles_out\"] = zles\n        outputs[\"chords_out\"] = chords\n\n\n# geom-end\n\n\n# mass-start\nclass MassProperties(om.ExplicitComponent):\n    # compute the new estimated center of gravity\n    # the weight of each section is proportional to the planform area\n\n    def initialize(self):\n        self.options.declare(\"density\", types=float, default=1.0, desc=\"volume density of building material in kg/m**3\")\n\n    def setup(self):\n        # input variables\n        self.add_input(\"xles\", shape_by_conn=True, desc=\"Baseline x leading edge coordinates\", units=\"m\")\n        self.add_input(\"yles\", shape_by_conn=True, desc=\"Baseline y leading edge coordinates\", units=\"m\")\n        self.add_input(\"chords\", shape_by_conn=True, desc=\"chord distribution\", units=\"m\")\n\n        self.add_output(\"x_cg\", desc=\"x postion of the CG in the same axis as the xles coordinate\", units=\"m\")\n        self.add_output(\"weight\", desc=\"estimated weight of the airplane\", units=\"N\")\n        self.add_output(\"area\", desc=\"planform area\", units=\"m**2\")\n\n        # Finite difference partials\n        self.declare_partials(\"*\", \"*\", method=\"cs\")\n\n    def compute(self, inputs, outputs):\n        xles = inputs[\"xles\"]\n        yles = inputs[\"yles\"]\n        chords = inputs[\"chords\"]\n\n        density = self.options[\"density\"]\n        g = 9.81  # acceleration due to gravity\n\n        k = 0.680883333333  # areea of a NACA 4 digit airfoil for unit chord divied by thickness from http://louisgagnon.com/scBlog/airfoilCenter.html\n        t = 0.12  # thicknes of airfoil\n        f = 0.4  # approximate centroid of an airfoil\n        # area is  t*c = 0.680883333333*(0.12*c)*c\n\n        # we are going to find the mass, and center of mass for each of the wing sections\n        # we assume that the wing is of uniform density\n        x_cg = 0\n        mass = 0\n        xcg_numerator = 0\n        planform_area = 0\n        for idx in range(len(xles) - 1):\n            x1 = xles[idx]\n            y1 = yles[idx]\n            c1 = chords[idx]\n\n            x2 = xles[idx + 1]\n            y2 = yles[idx + 1]\n            c2 = chords[idx + 1]\n            dy = y2 - y1\n\n            planform_area += 0.5 * (c1 + c2) * dy  # area of trapizoid\n\n            s = (c2 - c1) / dy  # change in chord per span\n\n            mass += density * k * t * (s**2 * dy**3 / 3 + s * c1 * dy**2 + c1**2 * dy)\n\n            m = (x2 - x1) / dy  # change in xles per span\n\n            A = m + f * s\n            B = x1 + f * c1\n\n            xcg_numerator += (\n                density\n                * t\n                * k\n                * (\n                    A / 4 * s**2 * dy**4\n                    + 2 * A / 3 * s * c1 * dy**3\n                    + A / 2 * c1**2 * dy**2\n                    + B / 3 * s**2 * dy**3\n                    + 2 * B / 2 * s * c1 * dy**2\n                    + B * c1**2 * dy\n                )\n            )\n\n        x_cg = xcg_numerator / mass\n\n        if not self.under_approx:\n            print(\"Weight \", mass * g, \"x_cg\", x_cg)\n\n        outputs[\"weight\"] = mass * g\n        outputs[\"x_cg\"] = x_cg\n        outputs[\"area\"] = planform_area\n\n\n# mass-end\n# glide-start\nclass GlidingFlight(om.ExplicitComponent):\n    def setup(self):\n        self.add_input(\"weight\", desc=\"weight of the aircraft\", units=\"N\")\n        self.add_input(\"CL\", desc=\"lift coefficent of the aicraft\")\n        self.add_input(\"CD\", desc=\"drag coefficent\")\n        self.add_input(\"Sref\", desc=\"planform area\", units=\"m**2\")\n        self.add_input(\"height\", val=100, desc=\"height of the glider from the ground\", units=\"m\")\n        self.add_input(\"density_air\", val=1.225, desc=\"density of air you are gliding in\", units=\"kg/m**3\")\n\n        self.add_output(\"glide_angle\", desc=\"the glide angle of the descent\")\n        self.add_output(\"duration\", desc=\"the glide angle of the descent\", units=\"s\")\n\n        self.declare_partials(\"*\", \"*\", method=\"cs\")\n\n    def compute(self, inputs, outputs):\n        cl = inputs[\"CL\"]\n        cd = inputs[\"CD\"]\n        rho = inputs[\"density_air\"]\n        weight = inputs[\"weight\"]\n        Sref = inputs[\"Sref\"]\n\n        # determine the glide angle from the lift to drag\n        theta = np.arctan(cd / cl)\n\n        # based on the weight deterimne the rate of descent such that lift = cos(theta)*weight - sind(theta)*cd\n        a = rho / 2 * Sref\n        coef = cl * np.cos(theta) + cd * np.sin(theta)\n\n        v_mag = np.sqrt((weight / (a * coef)))\n        v_descent = v_mag * np.sin(theta)\n\n        # the duration is the height divied by the descent velocity\n        duration = inputs[\"height\"] / v_descent\n\n        outputs[\"glide_angle\"] = theta * 180 / np.pi\n        outputs[\"duration\"] = duration\n\n        if not self.under_approx:\n            print(\"L/D\", cl / cd, \"glide_angle\", np.rad2deg(theta), \"duration\", duration)\n\n\n# glide-end\n\n\nmodel = om.Group()\ngeom_dvs = model.add_subsystem(\"geom_dvs\", om.IndepVarComp())\n\ngeom_dvs.add_output(\"aincs\", shape_by_conn=True)\nmodel.connect(\"geom_dvs.aincs\", \"ovlsolver.Wing:aincs\")\n\nmodel.add_subsystem(\"mesh\", OVLMeshReader(geom_file=\"rectangle.avl\"))\nmodel.add_subsystem(\"geom_param\", GeometryParametrizationComp())\nmodel.connect(\"mesh.Wing:yles\", [\"geom_param.yles_in\"])\n\n# assuming we made everything out of pink insulation foam (20.8 kg/m**3)\n# https://dcpd6wotaa0mb.cloudfront.net/mdms/dms/EIS/10015703/10015703-FOAMULAR-SI-and-I-P-Units-for-Selected-Properties-Tech.-Bulletin.pdf\nmodel.add_subsystem(\"mass_props\", MassProperties(density=20.8))\nmodel.connect(\"geom_param.xles_out\", [\"mass_props.xles\"])\nmodel.connect(\"mesh.Wing:yles\", [\"mass_props.yles\"])\nmodel.connect(\"geom_param.chords_out\", [\"mass_props.chords\"])\n\n\nmodel.add_subsystem(\n    \"ovlsolver\",\n    OVLGroup(\n        geom_file=\"rectangle.avl\",\n        output_stability_derivs=True,\n        write_grid=True,\n        input_param_vals=True,\n        input_ref_vals=True,\n        output_dir=\"opt_output_sweep\",\n    ),\n)\nmodel.connect(\"geom_param.xles_out\", [\"ovlsolver.Wing:xles\"])\nmodel.connect(\"geom_param.zles_out\", [\"ovlsolver.Wing:zles\"])\nmodel.connect(\"geom_param.chords_out\", [\"ovlsolver.Wing:chords\"])\nmodel.connect(\"mass_props.x_cg\", [\"ovlsolver.X cg\"])\nmodel.connect(\"mass_props.area\", [\"ovlsolver.Sref\"])\n\nmodel.add_subsystem(\"glide\", GlidingFlight())\nmodel.connect(\"mass_props.weight\", [\"glide.weight\"])\nmodel.connect(\"mass_props.area\", [\"glide.Sref\"])\nmodel.connect(\"ovlsolver.CL\", [\"glide.CL\"])\nmodel.connect(\"ovlsolver.CD\", [\"glide.CD\"])\n\nmodel.add_subsystem(\"differ_aincs\", Differencer())\nmodel.connect(\"geom_dvs.aincs\", \"differ_aincs.input_vec\")\n\n# design variables modify the planform and twist distribution\nmodel.add_design_var(\"geom_param.c/4_sweep\", lower=0.0, upper=3.0)\nmodel.add_design_var(\"geom_param.taper_ratio\", lower=0.1, upper=1.0)\nmodel.add_design_var(\"geom_param.root_chord\", lower=0.5, upper=4.0)\nmodel.add_design_var(\"ovlsolver.Wing:aincs\", lower=-15, upper=15)\n\nmodel.add_constraint(\"ovlsolver.CM\", equals=0.0, scaler=1e2)\nmodel.add_constraint(\"ovlsolver.static margin\", upper=0.3, lower=0.1, scaler=1e1)\n\n# this spiral parameter makes the problem harder to solve but more realistic\n# model.add_constraint(\"ovlsolver.spiral parameter\", lower=1.0, scaler=1e0)\n\n# you can optionally add dihedral as a design variable too\n# model.add_design_var(\"geom_param.dihedral\", lower=0.0, upper=0.5)\n\n\n# make sure CL stays slightly positive to avoid\nmodel.add_constraint(\"ovlsolver.CL\", lower=0.1, scaler=1)\n\n\n# Some variables (like chord, dihedral, x and z leading edge position) can lead to local minimum.\n# To help fix this add a contraint that keeps the variable monotonic\nmodel.add_constraint(\"differ_aincs.diff_vec\", upper=0.0, linear=True)  # twist can only decrease\n\n# scale down the duration to be about order 1\n# negative scaler because the optimizer only minimizes\nmodel.add_objective(\"glide.duration\", scaler=-1e-3)\n\nprob = om.Problem(model)\n\n\nprob.driver = om.ScipyOptimizeDriver()\nprob.driver.options[\"optimizer\"] = \"SLSQP\"\nprob.driver.options[\"debug_print\"] = [\"desvars\", \"ln_cons\", \"nl_cons\", \"objs\"]\nprob.driver.options[\"tol\"] = 1e-6\nprob.driver.options[\"disp\"] = True\n\n\nprob.driver.add_recorder(om.SqliteRecorder(\"opt_history.sql\"))\n\n\nprob.driver.recording_options[\"includes\"] = [\"*\"]\nprob.driver.recording_options[\"record_objectives\"] = True\nprob.driver.recording_options[\"record_constraints\"] = True\nprob.driver.recording_options[\"record_desvars\"] = True\n\n\nprob.setup(mode=\"rev\")\nprob.run_driver()\nom.n2(prob, show_browser=False, outfile=\"vlm_opt.html\")\n\n# prob.run_model()\n# prob.check_totals()\n</code></pre>"},{"location":"planform_optimization/#results","title":"Results","text":"<p>The optimized design has a glide duration of over 1400 seconds. We can plot the objective function over the iterations using OpenMDAO's <code>CaseReader</code> class, using the recorder we made.  Additionally, we can load in the last <code>.avl</code> file written during the optimization to view the geometry of the optimized design.  <pre><code>import openmdao.api as om\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom optvl import OVLSolver\nimport glob\nimport os\n\n\ncr = om.CaseReader(\"./run_opt_om_planform_out/opt_history.sql\")\ndriver_cases = cr.list_cases(\"driver\", out_stream=None)\nobj_arr = np.zeros(len(driver_cases))\nfor idx_case in range(len(driver_cases)):\n    obj_arr[idx_case] = cr.get_case(driver_cases[idx_case])[\"glide.duration\"]\n\nplt.plot(obj_arr)\nplt.xlabel(\"iteration\")\nplt.ylabel(\"duration [s]\")\nplt.show()\n\n# search the output directory for the latest file with a .dat extension\n# Use glob to find all .dat files in the given directory\noutput_dir = \"opt_output_sweep\"\nfiles = glob.glob(os.path.join(output_dir, \"*.avl\"))\n\n# Find the .dat file with the latest modification time\nlatest_file = max(files, key=os.path.getmtime)\n\novl = OVLSolver(geo_file=latest_file)\n\novl.plot_geom()\n\novl.execute_run()\n\n\nstrip_data = ovl.get_strip_forces()\n\n\n# Create a figure and two subplots that share the x-axis\nfig, (ax1, ax2) = plt.subplots(2, 1, sharex=True, figsize=(8, 6))\n\n\nfor surf_key in strip_data:\n    span_distance = strip_data[surf_key][\"Y LE\"]\n    ax1.plot(span_distance, strip_data[surf_key][\"chord\"], color=\"blue\", label=\"chord\")\n    ax1.plot(span_distance, strip_data[surf_key][\"twist\"], color=\"red\", label=\"twist\")\n    ax2.plot(span_distance, strip_data[surf_key][\"lift dist\"], color=\"C0\", label=\"list dist\")\n\nax1.legend([\"chord\", \"twist\"])\nax2.legend([\"lift dist\"])\nax2.set_xlabel(\"span location\")\nplt.show()\n</code></pre></p> <p>The objective function quickly rises to about 1400 seconds and then levels off. </p> <p></p> <p>However, if we zoom in we can see that some slight improvements are still being made to the design over the final iterations</p> <p></p> <p>From the geometry we can see that the aspect ratio of the wing has increased dramatically and now has a sweep.</p> <p></p> <p>Looking at the twist and chord distribution, we can see a linear chord distribution because of the taper ratio and the wash-out in the sweep.  The lift distribution does not look elliptical, which makes sense, as maximizing glide duration is not equivalent to minimizing drag. </p> <p></p>"},{"location":"pyavl_changes/","title":"Changes from pyAVL to OptVL","text":"<p>When I first started working on this project, I called it pyAVL.  I changed the name to OptVL for two reasons 1. There were many other pyAVLs and people who were looking for it had trouble finding it 2. I added lots of optimization features and wanted the name to reflect this development. While I changed the name, I decided to also make some changes to the API to better match AVL's interface.  The table below lists the changes.</p> pyAVL Method OptVL Equivalent Method <code>get_case_total_data</code> <code>get_total_forces()</code> <code>get_case_coef_derivs</code> <code>get_control_stab_derivs</code> <code>get_case_stab_derivs</code> <code>get_stab_derivs</code> <code>get_case_surface_data</code> <code>get_surface_forces</code> <code>get_case_parameter</code> <code>get_parameter</code> <code>set_case_parameter</code> <code>set_parameter</code> <code>get_case_constraint</code> <code>get_constraint</code> <code>get_strip_data</code> <code>get_strip_forces</code> <code>add_constraint</code> <code>set_constraint</code> <code>add_trim_condition</code> <code>set_trim_condition</code> <code>executeRun</code> use <code>execute_run</code> instead <p>The output dictionaries for stability and control surface derivatives are also now flat.  For example, instead of <code>cs_derivs['CL']['Elevator']</code> the key is now <code>cs_derivs['dCL/dElevator']</code>.</p>"},{"location":"sectional_data_viz/","title":"Sectional Data","text":"<p>Like AVL, OptVL can also plot data about each chordwise section.  This data is useful for visualizing the force distribution along the wing among other things.  In contrast to AVL's integrated plotter, we return the data and allow you to plot it anyway you wish. In this demo we use <code>matplotlib</code> as it by far the most common package for plotting in Python. </p>"},{"location":"sectional_data_viz/#plotting-the-data","title":"Plotting the data","text":"<p>To get the data, just call the <code>ovl.get_strip_forces()</code> method. The data is organized by surface and each surface has sectional geometric and force/moment data. <pre><code>strip_data = ovl.get_strip_forces()\nfirst_surf = list(strip_data.keys())[0]\nprint(strip_data[first_surf].keys())\n</code></pre> Running the snippet above produces the list of data available for each surface:  <pre><code>dict_keys(['chord', 'width', 'X LE', 'Y LE', 'Z LE', 'twist', 'CL', 'CD', 'CDv', 'downwash', 'CX', 'CY', 'CZ', 'CM', 'CN', 'CR', 'CL strip', 'CD strip', 'CF strip', 'CM strip', 'CL perp', 'CM c/4', 'CM LE', 'spanloading', 'lift dist', 'drag dist'])\n</code></pre></p> <p>Some data is about the geometry of the chordwise sections such as chord and twist.  The twist of our baseline design is all zero, but we have some variation in the chord that you can see on the plot:  </p> <p>One of the most useful things to look at is how the lift is distributed over the wing at our analysis condition.  Just like AVL, you can plot the CL and the CL perpendicular to the wing of the aircraft. The lift distribution is found by multiplying the CL at each section by the chord/cref. </p> <p>You can also look at how each section contributes to the overall roll and yaw moment coefficients.  The roll distribution is the <code>CR*chord^2/cref^2</code> and the yaw distribution is <code>CN*chord^2/(cref*bref)</code>. </p>"},{"location":"sectional_data_viz/#example","title":"Example","text":"<p>The example script below can be used to generate these plots for the example aircraft. </p> <pre><code>from optvl import OVLSolver\nimport numpy as np\nimport matplotlib.pyplot as plt\n\novl = OVLSolver(geo_file=\"aircraft.avl\", debug=False)\novl.set_constraint(\"alpha\", 5.0)\novl.set_constraint(\"beta\", 10.0)\novl.execute_run()\n\n# keys-start\nstrip_data = ovl.get_strip_forces()\nfirst_surf = list(strip_data.keys())[0]\nprint(strip_data[first_surf].keys())\n# keys-end\n\nfor surf_key in strip_data:\n    span_distance = strip_data[surf_key][\"Y LE\"]\n    plt.plot(span_distance, strip_data[surf_key][\"chord\"], color=\"blue\")\n    plt.plot(span_distance, strip_data[surf_key][\"twist\"], color=\"red\")\n\nplt.legend([\"chord\", \"twist\"])\nplt.title(\"geometric spanwise data\")\nplt.xlabel(\"spanwise position\")\nplt.show()\n\nfor surf_key in strip_data:\n    span_distance = strip_data[surf_key][\"Y LE\"]\n    plt.plot(span_distance, strip_data[surf_key][\"lift dist\"], color=\"blue\")\n    plt.plot(span_distance, strip_data[surf_key][\"CL\"], color=\"red\")\n    plt.plot(span_distance, strip_data[surf_key][\"CL perp\"], color=\"firebrick\", linestyle=\"--\")\n\nplt.legend([\"lift dist\", \"CL\", \"CL perp.\"])\nplt.title(\"lift spanwise data\")\nplt.xlabel(\"spanwise position\")\nplt.show()\n\n\nstrip_data = ovl.get_strip_forces()\nfor surf_key in strip_data:\n    span_distance = strip_data[surf_key][\"Y LE\"]\n    plt.plot(span_distance, strip_data[surf_key][\"CN\"], color=\"C0\")\n    plt.plot(span_distance, strip_data[surf_key][\"CR\"], color=\"C1\")\n\nplt.legend([\"roll distribution\", \"yaw distribution\"])\nplt.title(\"roll and yaw spanwise data\")\nplt.xlabel(\"spanwise position\")\nplt.show()\n</code></pre>"},{"location":"viz_overview/","title":"Visualization","text":""},{"location":"viz_overview/#with-matplotlibpython","title":"With Matplotlib/Python","text":"<p>The visualizations described in this section rely on the <code>matplotlib</code> Python package, but no external tools. </p>"},{"location":"viz_overview/#looking-at-the-geometry","title":"Looking at the geometry","text":"<p>To quickly look at your geometry you can use the <pre><code>ovl.plot_geom()\n</code></pre> command, which will produce a figure that looks like this:  </p>"},{"location":"viz_overview/#cp-plots","title":"Cp plots","text":"<p>To get a quick view of the coefficient of pressure on the surfaces of the aircraft you can use  <pre><code>ovl.plot_cp()\n</code></pre> Which will produce a plot like this: </p> <p> You can rotate, zoom, and pan in the window to look at different parts for the aircraft. </p>"},{"location":"viz_overview/#paraview-or-tecplot","title":"ParaView or Tecplot","text":"<p>This section describes how to produce data that can be used with either Tecplot or ParaView.</p> <p>To generate a Tecplot ASCII file (which can be read by both Tecplot and ParaView).  After an analysis, use the command:  <pre><code>ovl_solver.write_tecplot('test')\n</code></pre> This command will write a file called <code>test.dat</code>.</p>"},{"location":"viz_overview/#tecplot-360","title":"Tecplot 360","text":"<p>If you load the file with Tecplot 360 it will automatically be detected as a Tecplot ASCII file and will be loaded accordingly.  By default, Tecplot tends to plot the data with a 2D Cartesian plot, but you will have to switch it to 3D Cartesian to see the full geometry. </p> <p></p> <p>You can also plot the mesh and the coefficient of pressure on the surface: </p> <p></p> <p>When writing out the Tecplot file you can also specify a solution time with the optional keyword argument.  This makes it easier to flip through different data files in Tecplot but makes the output incompatible with ParaView. <pre><code>ovl_solver.write_tecplot('test', solution_time=1)\n</code></pre></p>"},{"location":"viz_overview/#paraview","title":"ParaView","text":"<p>When loading your data into ParaView, be sure to use the Tecplot data loader. </p> <p></p> <p>With the data loaded you can view the 3D shape, Coefficient of Pressure, and mesh just like with Tecplot. </p> <p></p> <p>ParaView nicely stacks up files of the same name but with different numeric suffixes and loads them into different timesteps.  So if you want to easily view the results of an optimization or parameter sweep, name your output files with the same name but a different number for the suffix. </p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>utils<ul> <li>check_surface_dict</li> <li>airfoil_utils</li> </ul> </li> <li>optvl_class</li> <li>om_wrapper</li> </ul>"},{"location":"reference/om_wrapper/","title":"om_wrapper","text":""},{"location":"reference/om_wrapper/#optvl.om_wrapper.OVLFuncsComp","title":"<code>OVLFuncsComp</code>","text":"<p>               Bases: <code>ExplicitComponent</code></p> <p>This component uses OptVL to compute functionals given a circulation solution. This is added as part of the OVL group</p> <p>Parameters:</p> Name Type Description Default <code>om</code> <p>description</p> required"},{"location":"reference/om_wrapper/#optvl.om_wrapper.OVLGroup","title":"<code>OVLGroup</code>","text":"<p>               Bases: <code>Group</code></p> <p>This is the main the top level group for interacting with OptVL.</p> <p>Parameters:</p> Name Type Description Default <code>geom_file</code> <p>the input geometry file</p> required <code>mass_file</code> <p>the optional mass file</p> required <code>write_grid</code> <p>should the grid be written after avery analysis</p> required <code>write_grid_sol_time</code> <p>add the iteration count as the solution time for easier postprocessing in tecplot</p> required <code>output_dir</code> <p>the output directory for the files generated</p> required <code>input_param_vals</code> <p>flag to turn on the flght parameters (Mach, Velocity, etc.) as inputs</p> required <code>input_ref_val</code> <p>flag to turn on the geometric reference values (Sref, Cref, Bref) as inputs</p> required <code>output_stability_derivs</code> <p>flag to turn on the output of stability derivatives</p> required <code>output_con_surf_derivs</code> <p>flag to turn on the output of control surface deflections</p> required"},{"location":"reference/om_wrapper/#optvl.om_wrapper.OVLMeshReader","title":"<code>OVLMeshReader</code>","text":"<p>               Bases: <code>ExplicitComponent</code></p> <p>This class is moslty used to provide an initial set of coordinates for custom paramerization components. It is NOT part of the OVL group</p>"},{"location":"reference/om_wrapper/#optvl.om_wrapper.OVLPostProcessComp","title":"<code>OVLPostProcessComp</code>","text":"<p>               Bases: <code>ExplicitComponent</code></p> <p>This component writes out data files for postprocessing. It is optionally added as part of the OVLGroup</p>"},{"location":"reference/om_wrapper/#optvl.om_wrapper.OVLSolverComp","title":"<code>OVLSolverComp</code>","text":"<p>               Bases: <code>ImplicitComponent</code></p> <p>OpenMDAO component that wraps optvl solver. This is added as part of the OVLgroup</p>"},{"location":"reference/optvl_class/","title":"optvl_class","text":"<p>This module contains the OVLSolver, which is the main wrapper for the Fortran level API.</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver","title":"<code>OVLSolver</code>","text":"<p>               Bases: <code>object</code></p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.__get_des_var_param","title":"<code>__get_des_var_param(surf_name, idx_sec, param)</code>","text":"<p>Returns the parameters that define the control surface. Can also get design variables (AVL).</p> <p>Parameters:</p> Name Type Description Default <code>surf_name</code> <code>str</code> <p>the name of the surface containing the control surface</p> required <code>idx_sec</code> <code>int</code> <p>the section index of the control surface data</p> required <code>param</code> <code>str</code> <p>control surface parameter to get</p> required <p>Returns:</p> Name Type Description <code>parm</code> <code>ndarray</code> <p>parameter value</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.__init__","title":"<code>__init__(geo_file=None, mass_file=None, input_dict=None, debug=False, timing=False)</code>","text":"<p>Initalize the python and fortran libary from the given objects</p> <p>Parameters:</p> Name Type Description Default <code>geo_file</code> <code>Optional[str]</code> <p>AVL geometry file</p> <code>None</code> <code>mass_file</code> <code>Optional[str]</code> <p>AVL mass file</p> <code>None</code> <code>debug</code> <code>Optional[bool]</code> <p>flag for debug printing</p> <code>False</code> <code>timing</code> <code>Optional[bool]</code> <p>flag for timing printing</p> <code>False</code>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.add_mesh_plot","title":"<code>add_mesh_plot(axis, xaxis='x', yaxis='y', color='black', mesh_style='--', mesh_linewidth=0.3, show_mesh=True)</code>","text":"<p>Adds a plot of the aircraft mesh to the axis</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <p>axis to add the plot to</p> required <code>xaxis</code> <code>str</code> <p>what variable should be plotted on the x axis. Options are ['x', 'y', 'z']</p> <code>'x'</code> <code>yaxis</code> <code>str</code> <p>what variable should be plotted on the y-axis. Options are ['x', 'y', 'z']</p> <code>'y'</code> <code>color</code> <code>str</code> <p>what color should the mesh be</p> <code>'black'</code> <code>mesh_style</code> <p>line style of the interior mesh, e.g. '-' or '--'</p> <code>'--'</code> <code>mesh_linewidth</code> <p>width of the interior mesh, 1.0 will match the surface outline</p> <code>0.3</code> <code>show_mesh</code> <code>bool</code> <p>flag to show the interior mesh of the geometry</p> <code>True</code>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.execute_eigen_mode_calc","title":"<code>execute_eigen_mode_calc()</code>","text":"<p>Execute a modal analysis (x from the MODE menu in AVL)</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.execute_run","title":"<code>execute_run(tol=2e-05)</code>","text":"<p>Run the analysis (equivalent to the AVL command <code>x</code> in the OPER menu)</p> <p>Parameters:</p> Name Type Description Default <code>tol</code> <code>float</code> <p>the tolerace of the Newton solver used for timing the aircraft</p> <code>2e-05</code>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.execute_run_sensitivities","title":"<code>execute_run_sensitivities(funcs, stab_derivs=None, consurf_derivs=None, print_timings=False)</code>","text":"<p>Run the sensitivities of the input functionals in adjoint mode</p> <p>Parameters:</p> Name Type Description Default <code>funcs</code> <code>List[str]</code> <p>force coefficients to compute the sensitivities with respect to</p> required <code>stab_derivs</code> <code>Optional[List[str]]</code> <p>stability derivatives to compute the sensitivities with respect to</p> <code>None</code> <code>consurf_derivs</code> <code>Optional[List[str]]</code> <p>control surface derivates to compute the sensitivities with respect to</p> <code>None</code> <code>print_timings</code> <code>Optional[bool]</code> <p>flag to print timing information</p> <code>False</code> <p>Returns:</p> Name Type Description <code>sens</code> <code>Dict[str, Dict[str, float]]</code> <p>a nested dictionary of sensitivities. The first key is the function and the next keys are for the design variables.</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_avl_fort_arr","title":"<code>get_avl_fort_arr(common_block, variable, slicer=None)</code>","text":"<p>Get data from the Fortran level common block data structure. see AVL.INC for all availible variables</p> <p>Parameters:</p> Name Type Description Default <code>common_block</code> <code>str</code> <p>Name of the common block of the variable like <code>CASE_R</code></p> required <code>variable</code> <code>str</code> <p>Name of the variable to retrive</p> required <code>slicer</code> <code>Optional[slice]</code> <p>slice applied to the common block variable to return a subset of the data. i.e. (100) or slice(2, 5)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>val</code> <code>ndarray</code> <p>value of variable after applying the slice (if present)</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_body_index","title":"<code>get_body_index(body_name)</code>","text":"<p>Given a body name returns the index</p> <p>Parameters:</p> Name Type Description Default <code>body_name</code> <code>str</code> <p>name of the body</p> required <p>Returns:</p> Name Type Description <code>idx_body</code> <code>int</code> <p>index of the body</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_body_names","title":"<code>get_body_names(remove_dublicated=False)</code>","text":"<p>Get the body names from the geometry</p> <p>Parameters:</p> Name Type Description Default <code>remove_dublicated</code> <code>Optional[bool]</code> <p>remove the body that were created by duplication about symmetry planes</p> <code>False</code> <p>Returns:</p> Name Type Description <code>body_names</code> <code>List[str]</code> <p>list of body names</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_body_param","title":"<code>get_body_param(body_name, param)</code>","text":"<p>Get a parameter of a specified body</p> <p>Parameters:</p> Name Type Description Default <code>body_name</code> <code>str</code> <p>the body containing the parameter</p> required <code>param</code> <code>str</code> <p>the body parameter to return. Could be either geometric or paneling</p> required <p>Returns:</p> Name Type Description <code>val</code> <code>ndarray</code> <p>the val of parameter of the body</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_body_params","title":"<code>get_body_params(include_body_oml=False)</code>","text":"<p>Get the parameters of the bodies</p> <p>Parameters:</p> Name Type Description Default <code>include_body_oml</code> <code>bool</code> <p>include the raw oml coordinates in the output dict</p> <code>False</code> <p>Returns:</p> Name Type Description <code>body_data</code> <code>Dict[str, Dict[str, Any]]</code> <p>Nested dictionary where the 1st key is the body name and the 2nd key is the parameter.</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_con_surf_param","title":"<code>get_con_surf_param(surf_name, idx_sec, param)</code>","text":"<p>Returns the parameters that define the control surface. Can also get design variables (AVL).</p> <p>Parameters:</p> Name Type Description Default <code>surf_name</code> <code>str</code> <p>the name of the surface containing the control surface</p> required <code>idx_sec</code> <code>int</code> <p>the section index of the control surface data</p> required <code>param</code> <code>str</code> <p>control surface parameter to get</p> required <p>Returns:</p> Name Type Description <code>parm</code> <code>ndarray</code> <p>parameter value</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_constraint","title":"<code>get_constraint(con_key)</code>","text":"<p>Get the value of a constraint</p> <p>Parameters:</p> Name Type Description Default <code>con_key</code> <code>str</code> <p>name of the constraint. Options are [\"alpha\",\"beta\",\"roll rate\",\"pitch rate\",\"yaw rate\",\"CL\",\"CY\",\"CR BA\",\"CM\",\"CR\"]</p> required <p>Returns:</p> Name Type Description <code>con_val</code> <code>float</code> <p>value of the constraint</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_control_deflections","title":"<code>get_control_deflections()</code>","text":"<p>Get the deflections of all the control surfaces</p> <p>Returns:</p> Name Type Description <code>def_dict</code> <code>Dict[str, float]</code> <p>dictionary of control surfaces as the keys and deflections as the values</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_control_names","title":"<code>get_control_names()</code>","text":"<p>Get the names of the control surfaces</p> <p>Returns:</p> Name Type Description <code>control_names</code> <code>List[str]</code> <p>list of control surface names</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_control_stab_derivs","title":"<code>get_control_stab_derivs()</code>","text":"<p>Get the control surface derivative data, i.e. dCL/dElevator, for the current analysis run</p> <p>Returns:</p> Name Type Description <code>stab_deriv_dict</code> <code>Dict[str, float]</code> <p>The dictionary of control surface derivatives, d{force coefficent}/d{control surface}.</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_cp_data","title":"<code>get_cp_data()</code>","text":"<p>Gets the current surface mesh and cp distribution</p> <p>Returns:</p> Name Type Description <code>xyz_list</code> <code>List[ndarray]</code> <p>list of surface mesh points</p> <code>cp_list</code> <code>List[ndarray]</code> <p>list of cp points</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_design_var_names","title":"<code>get_design_var_names()</code>","text":"<p>Get the names of the design_var surfaces</p> <p>Returns:</p> Name Type Description <code>design_var_names</code> <code>List[str]</code> <p>list of design_var surface names</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_eigenvalues","title":"<code>get_eigenvalues()</code>","text":"<p>After running an eigenmode calculation, this function will return the eigenvalues in the order used by AVL</p> <p>Returns:</p> Name Type Description <code>eig_vals</code> <code>ndarray</code> <p>array of eigen values</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_eigenvectors","title":"<code>get_eigenvectors()</code>","text":"<p>After running an eigenmode calculation, this function will return the eigenvalues in the order used by AVL</p> <p>Returns:</p> Name Type Description <code>eig_vec</code> <code>ndarray</code> <p>2D array of eigen vectors</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_header_params","title":"<code>get_header_params()</code>","text":"<p>Gets the header input settings in AVL and returns them in a dictionary.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Dict[str]: Dictionary containing the header input settings in AVL</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_hinge_moments","title":"<code>get_hinge_moments()</code>","text":"<p>Get the hinge moments from the fortran layer and return them as a dictionary</p> <p>Returns:</p> Name Type Description <code>hinge_moments</code> <code>Dict[str, float]</code> <p>array of control surface moments. The order the control surfaces are declared are the indices,</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_input_dict","title":"<code>get_input_dict(include_surfaces=True, include_section_geom=False, include_bodies=True)</code>","text":"<p>Returns all input information from AVL in input dictionary format.</p> <p>Parameters:</p> Name Type Description Default <code>include_surfaces</code> <code>bool</code> <p>Include all surfaces in the dictionary. Defaults to True.</p> <code>True</code> <code>include_section_geom</code> <code>bool</code> <p>Include all the section geometry information for each surface. Defaults to False.</p> <code>False</code> <code>include_bodies</code> <code>bool</code> <p>Include all bodies in the dictionary. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, Any]]</code> <p>Dict[str, Dict[str, Any]]: OptVL input dictionary</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_mesh_size","title":"<code>get_mesh_size()</code>","text":"<p>Get the number of vortices in the mesh</p> <p>Returns:</p> Name Type Description <code>val</code> <code>int</code> <p>the number of vortices</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_num_control_surfs","title":"<code>get_num_control_surfs()</code>","text":"<p>Get the number of control surfaces</p> <p>Returns:</p> Name Type Description <code>val</code> <code>int</code> <p>number of control surfaces</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_num_sections","title":"<code>get_num_sections(surf_name)</code>","text":"<p>Get the number of sections in a surface.</p> <p>Parameters:</p> Name Type Description Default <code>surf_name</code> <code>str</code> <p>name of the surface</p> required <p>Returns:</p> Name Type Description <code>nsec</code> <code>int</code> <p>numer of sections</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_num_strips","title":"<code>get_num_strips()</code>","text":"<p>Get the number of strips in the mesh</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_num_surfaces","title":"<code>get_num_surfaces()</code>","text":"<p>Returns the number of surface including duplicated</p> <p>Returns:</p> Name Type Description <code>val</code> <code>int</code> <p>number of surfaces</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_parameter","title":"<code>get_parameter(param_key)</code>","text":"<p>Analogous to ruinont Modify parameters for the OPER menu to view parameters.</p> <p>Parameters:</p> Name Type Description Default <code>param_key</code> <code>str</code> <p>the name of the parameter to return</p> required <p>Returns:</p> Name Type Description <code>param_val</code> <code>float</code> <p>the value of the parameter</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_stab_derivs","title":"<code>get_stab_derivs()</code>","text":"<p>Gets the stability derivates after an analysis run</p> <p>Returns:</p> Name Type Description <code>stab_deriv_dict</code> <code>Dict[str, Dict[str, float]]</code> <p>Dictionary of stability derivatives.</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_strip_forces","title":"<code>get_strip_forces()</code>","text":"<p>Get force data for each strip (chordwise segment) of the mesh.</p> <p>Returns:</p> Name Type Description <code>strip_data</code> <code>Dict[str, Dict[str, ndarray]]</code> <p>dictionary of strip data. The keys are [\"chord\", \"width\", \"X LE\", \"Y LE\", \"Z LE\", \"twist\",\"CL\", \"CD\", \"CDv\", \"downwash\", \"CX\", \"CY\", \"CZ\",\"CM\", \"CN\", \"CR\",\"CL strip\", \"CD strip\", \"CF strip\", \"CM strip\",\"CL perp\",\"CM c/4,\"CM LE\"]</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_surface_forces","title":"<code>get_surface_forces()</code>","text":"<p>Returns the force data from each surface (including mirriored surfaces)</p> <p>Returns:</p> Name Type Description <code>surf_data_dict</code> <code>Dict[str, Dict[str, float]]</code> <p>a dictionary of surface data where the first key is the surface and the second is the force coefficient</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_surface_index","title":"<code>get_surface_index(surf_name)</code>","text":"<p>Given a surface name returns the index</p> <p>Parameters:</p> Name Type Description Default <code>surf_name</code> <code>str</code> <p>name of the surface</p> required <p>Returns:</p> Name Type Description <code>idx_surf</code> <code>int</code> <p>index of the surface</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_surface_names","title":"<code>get_surface_names(remove_dublicated=False)</code>","text":"<p>Get the surface names from the geometry</p> <p>Parameters:</p> Name Type Description Default <code>remove_dublicated</code> <code>Optional[bool]</code> <p>remove the surface that were created by duplication about symmetry planes</p> <code>False</code> <p>Returns:</p> Name Type Description <code>surf_names</code> <code>List[str]</code> <p>list of surface names</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_surface_param","title":"<code>get_surface_param(surf_name, param)</code>","text":"<p>Get a parameter of a specified surface. Does not get control surface or design variables.</p> <p>Parameters:</p> Name Type Description Default <code>surf_name</code> <code>str</code> <p>the surface containing the parameter</p> required <code>param</code> <code>str</code> <p>the surface parameter to return. Could be either geometric or paneling</p> required <p>Returns:</p> Name Type Description <code>param</code> <code>ndarray</code> <p>the parameter of the surface</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_surface_params","title":"<code>get_surface_params(include_geom=True, include_section_geom=False, include_paneling=False, include_con_surf=False, include_des_vars=False, include_airfoils=False)</code>","text":"<p>Get all the surface level parameters for each suface</p> <p>Parameters:</p> Name Type Description Default <code>include_geom</code> <code>bool</code> <p>flag to include geometry data in the output. The data is [\"scale\", \"translate\", \"angle\", \"xles\", \"yles\", \"zles\", \"chords\", \"aincs\", \"clcdsec\", \"claf\"]</p> <code>True</code> <code>include_section_geom</code> <code>bool</code> <p>flag to include section geometry data in the output. The data is [\"xasec\", \"sasec\", \"tasec\", xuasec, xlasec, zlasec, zuasec, casec, nasec]</p> <code>False</code> <code>include_paneling</code> <code>bool</code> <p>flag to include paneling information in the output. The data [\"nchordwise\", \"cspace\",\"nspan\", \"sspace\",\"sspaces\",\"nspans\",\"yduplicate\", \"wake\", \"able\", \"load\", \"use surface spacing\", \"component\"]</p> <code>False</code> <code>include_con_surf</code> <code>bool</code> <p>flag to include control surface and design variable data in the output. This is data like the hinge vector and gain.</p> <code>False</code> <code>include_airfoils</code> <code>bool</code> <p>flag to include airfoil file data in the output</p> <code>False</code> Return <p>surf_data: Nested dictionary where the 1st key is the surface name and the 2nd key is the parameter.</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_system_matrix","title":"<code>get_system_matrix()</code>","text":"<p>Returns the system matrix used for the eigenmode calculation</p> <p>Returns:</p> Name Type Description <code>asys</code> <code>ndarray</code> <p>2D array representing the system matrix for the eigen value analysis</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.get_total_forces","title":"<code>get_total_forces()</code>","text":"<p>Get the aerodynamic data for the last run case and return it as a dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, float]</code> <p>Dict[str, float]: Dictionary of aerodynamic data. The keys the aerodyanmic coefficients.</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.load_input_dict","title":"<code>load_input_dict(input_dict, preCheck=True, postCheck=False)</code>","text":"<p>Reads and loads the input dictionary data into optvl. Equivalent to INPUT routine in AVL.</p> <p>Parameters:</p> Name Type Description Default <code>input_dict</code> <code>dict</code> <p>input dictionary in optvl format</p> required <code>preCheck</code> <code>bool</code> <p>perform additional verification of the user's input dictionary before loading into AVL</p> <code>True</code> <code>postCheck</code> <code>bool</code> <p>verify certain inputs values are correctly reflected in the Fortran layer</p> <code>False</code>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.plot_cp","title":"<code>plot_cp()</code>","text":"<p>Create a matplotlib plot of the surface and cp distribution</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.plot_geom","title":"<code>plot_geom(axes=None)</code>","text":"<p>Generate a matplotlib plot of geometry</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <p>Matplotlib axis object to add the plots too. If none are given, the axes will be generated.</p> <code>None</code>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.post_check_input","title":"<code>post_check_input(inputDict)</code>","text":"<p>This routine verifies that a few critical values in the Fortran layer have been set correctly with regard to the input dict.</p> <p>To be expanded later...</p>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.set_avl_fort_arr","title":"<code>set_avl_fort_arr(common_block, variable, val, slicer=None)</code>","text":"<p>Set data from the Fortran level common block data structure. see AVL.INC for all availible variables</p> <p>Parameters:</p> Name Type Description Default <code>common_block</code> <code>str</code> <p>Name of the common block of the variable like <code>CASE_R</code></p> required <code>variable</code> <code>str</code> <p>Name of the variable to retrive</p> required <code>val</code> <code>float</code> <p>value to set, which can be a numpy array</p> required <code>slicer</code> <code>Optional[slice]</code> <p>slice applied to the common block variable to return a subset of the data. i.e. (100) or slice(2, 5)</p> <code>None</code>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.set_body_coordinates","title":"<code>set_body_coordinates(ibod, nasec, x, y, storecoords=False)</code>","text":"<p>Sets the body of revolution oml points for the specified body. Computes the camber line and interpolates it with AVL's 1D Akima Spline implementation.</p> <p>Parameters:</p> Name Type Description Default <code>ibod</code> <code>int</code> <p>body number to set the outer mold line too</p> required <code>nasec</code> <code>int</code> <p>number of points to evaluate the interpolated camber line and thickness curves at</p> required <code>x</code> <code>ndarray</code> <p>oml x-coordinate array</p> required <code>y</code> <code>ndarray</code> <p>oml y-coodinate array</p> required <code>xfminmax</code> <p>length 2 array with the min and max x/c to slice the oml</p> required <code>storecoords</code> <code>bool</code> <p>store the raw input coordinates in common block</p> <code>False</code>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.set_body_param","title":"<code>set_body_param(body_name, param, val, update_geom=True)</code>","text":"<p>Set a parameter of a specified body</p> <p>Parameters:</p> Name Type Description Default <code>body_name</code> <code>str</code> <p>the body containing the parameter</p> required <code>param</code> <code>str</code> <p>the surface parameter to return. Could be either geometric or paneling</p> required <code>val</code> <p>value to set</p> required <code>update_geom</code> <code>bool</code> <p>flag to update the geometry after setting</p> <code>True</code>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.set_body_params","title":"<code>set_body_params(body_data)</code>","text":"<p>Set the give body data of the current geometry.</p> <p>Parameters:</p> Name Type Description Default <code>body_data</code> <code>Dict[str, Dict[str, Any]]</code> <p>Nested dictionary where the 1st key is the body name and the 2nd key is the parameter.</p> required"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.set_con_surf_param","title":"<code>set_con_surf_param(surf_name, idx_slice, param, val, update_geom=True)</code>","text":"<p>Sets the parameters that define the control surface. Can also set design variables (AVL).</p> <p>Parameters:</p> Name Type Description Default <code>surf_name</code> <code>str</code> <p>the name of the surface containing the control surface</p> required <code>idx_slice</code> <code>int</code> <p>the section index of the control surface data</p> required <code>param</code> <code>str</code> <p>control surface parameter to set</p> required <code>val</code> <code>float</code> <p>value to set</p> required <code>update_geom</code> <code>Optional[bool]</code> <p>flag to update the geometry after setting</p> <code>True</code>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.set_constraint","title":"<code>set_constraint(var, val, con_var=None)</code>","text":"<p>Set the constraints on the analysis case (equivalent to setting a variable in AVL's OPER menu)</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>variable to be constrained [\"alpha\"\", \"beta\"\", \"roll rate\", \"pitch rate\", \"yaw rate\"] or any control surface.</p> required <code>val</code> <code>float</code> <p>target value of <code>con_var</code></p> required <code>con_var</code> <code>str</code> <p>variable output that needs to be constrained. It could be any value for <code>var</code> plus [\"CL\", \"CY\", \"Cl roll moment\", \"Cm pitch moment\", \"Cn yaw moment\"]. If None, than <code>var</code> is also the <code>con_var</code></p> <code>None</code>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.set_parameter","title":"<code>set_parameter(param_key, param_val)</code>","text":"<p>Modify a parameter of the run (analogous to M from the OPER menu in AVL).</p> <p>Parameters:</p> Name Type Description Default <code>param_key</code> <code>str</code> <p>parameter to modify. Options are [\"alpha\", \"beta\", \"pb/2V\", \"qc/2V\", \"rb/2V\", \"CL\"]</p> required <code>param_val</code> <code>float</code> <p>value to set</p> required"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.set_section_coordinates","title":"<code>set_section_coordinates(isec, isurf, nasec, x, y, xfminmax, storecoords=False)</code>","text":"<p>Sets the airfoil oml points for the specified surface and section. Computes the camber line and interpolates it with AVL's 1D Akima Spline implementation.</p> <p>Parameters:</p> Name Type Description Default <code>isec</code> <code>int</code> <p>section number to set the airfoil mesh</p> required <code>isurf</code> <code>int</code> <p>surface number to set the airfoil mesh</p> required <code>nasec</code> <code>int</code> <p>number of points to evaluate the interpolated camber line and thickness curves at</p> required <code>x</code> <code>ndarray</code> <p>airfoil x-coordinate array</p> required <code>y</code> <code>ndarray</code> <p>airfoil y-coodinate array</p> required <code>xfminmax</code> <code>ndarray</code> <p>length 2 array with the min and max x/c to slice the airfoil</p> required <code>storecoords</code> <code>bool</code> <p>store the raw input coordinates in common block</p> <code>False</code>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.set_section_naca","title":"<code>set_section_naca(isec, isurf, nasec, naca, xfminmax)</code>","text":"<p>Sets the airfoil oml points for the specified surface and section. Computes camber lines, thickness, and oml shape from NACA 4-digit specification.</p> <p>Parameters:</p> Name Type Description Default <code>isec</code> <code>int</code> <p>section number to set the airfoil mesh</p> required <code>isurf</code> <code>int</code> <p>surface number to set the airfoil mesh</p> required <code>nasec</code> <code>int</code> <p>number of points to evaluate the interpolated camber line and thickness curves at</p> required <code>naca</code> <code>str</code> <p>4-digit naca specificaion as a string</p> required <code>xfminmax</code> <code>ndarray</code> <p>length 2 array with the min and max x/c to slice the airfoil</p> required"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.set_surface_param","title":"<code>set_surface_param(surf_name, param, val, update_geom=True)</code>","text":"<p>Set a parameter of a specified surface. Supports setting params related to geometry and panelling. Section geometry can be directly set here but this is not recommended. Use set_section_coordinates instead.</p> <p>Parameters:</p> Name Type Description Default <code>surf_name</code> <code>str</code> <p>the surface containing the parameter</p> required <code>param</code> <code>str</code> <p>the surface parameter to return. Could be either geometric or paneling</p> required <code>val</code> <code>float</code> <p>value to set</p> required <code>update_geom</code> <code>bool</code> <p>flag to update the geometry after setting</p> <code>True</code>"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.set_surface_params","title":"<code>set_surface_params(surf_data)</code>","text":"<p>Set the given data of the current geometry. ASSUMES THE CONTROL SURFACE DATA STAYS AT THE SAME LOCATION (i.e  you didn't move the control surfaces to new sections or surfaces. If so re-initialize OptVL)</p> <p>Parameters:</p> Name Type Description Default <code>surf_data</code> <code>Dict[str, Dict[str, any]]</code> <p>Nested dictionary where the 1st key is the surface name and the 2nd key is the parameter.</p> required"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.set_trim_condition","title":"<code>set_trim_condition(variable, val)</code>","text":"<p>Set a variable of the trim condition (analogus to the AVL's C1 command from the OPER menu)</p> <p>Parameters:</p> Name Type Description Default <code>variable</code> <code>str</code> <p>variable to be set. Options are [\"bankAng\", \"CL\", \"velocity\", \"mass\", \"dens\", \"G\", \"X cg\",\"Y cg\",\"Z cg\"]</p> required <code>val</code> <code>float</code> <p>value to set the variable to</p> required"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.write_geom_file","title":"<code>write_geom_file(filename)</code>","text":"<p>Write the current geometry to a file</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>name of the output AVL-style geometry file</p> required"},{"location":"reference/optvl_class/#optvl.optvl_class.OVLSolver.write_tecplot","title":"<code>write_tecplot(file_name, solution_time=None)</code>","text":"<p>Write a tecplot file of the current surface and Cp distribution</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Name of the output file</p> required <code>solution_time</code> <code>float</code> <p>Add a solution time to the output. This is useful for flipping through data in tecplot, but breaks Paraview.</p> <code>None</code>"},{"location":"reference/utils/airfoil_utils/","title":"airfoil_utils","text":""},{"location":"reference/utils/airfoil_utils/#optvl.utils.airfoil_utils.read_coordinates_files","title":"<code>read_coordinates_files(filename, headerlines=0)</code>","text":"<p>Reads a '.dat' style airfoil coordinate file, with each coordinate on a new line and each line containing an xy pair separate by whitespace.</p> <p>Parameters:</p> Name Type Description Default <code>filename </code> <p>str dat file from which to read data</p> required <code>headerlines </code> <p>int the number of lines to skip at the beginning of the file to reach the coordinates</p> required <p>Returns:</p> Name Type Description <code>X</code> <p>Ndarray [N,2] The coordinates read from the file</p>"},{"location":"reference/utils/check_surface_dict/","title":"check_surface_dict","text":"<p>This module contains the routines, for pre-checking OptVL input dictionaries for errors.</p>"},{"location":"reference/utils/check_surface_dict/#optvl.utils.check_surface_dict.pre_check_input_dict","title":"<code>pre_check_input_dict(input_dict)</code>","text":"<p>This routine performs some verifications on a user's input diciontary to OptVL. It veries that geometry and control surfaces are specified in the correct format. Also checks to see if any unsupported keys are in the inputs dictionary and the surface and body subdictionaries and issues a warning if any are detected.</p> <p>This routine does NOT type check inputs as that is handled in the load routine itself.</p> <p>NOTE: There are other redundant specifications in AVL where specifying one option will override what is specified in another. This overriding behavior is standard in AVL but in the future OptVL may check for these redundancies and raise warnings or errors.</p> <p>List non-checked redundancies: 1. nspan and sspace override nspans and sspaces only if 'use surface spacing' is True 2. 'cdcl' overrides 'cdclsec'</p> <p>Parameters:</p> Name Type Description Default <code>input_dict </code> <p>dict</p> required <p>Returns:</p> Name Type Description <code>input_dict</code> <p>dict</p>"}]}