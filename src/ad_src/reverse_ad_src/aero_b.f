C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 15 Jan 2021 14:26
C
C  Differentiation of aero in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: cdtot cltot
C   with respect to varying inputs: alfa vinf xyzref cdtot cltot
C                rle chord wstrip ensy ensz rv1 rv2 gam
C   RW status of diff variables: alfa:out vinf:out xyzref:out cdtot:in-zero
C                cltot:in-zero rle:out chord:out wstrip:out ensy:out
C                ensz:out rv1:out rv2:out gam:out
C***********************************************************************
C    Module:  aero.f
C 
C    Copyright (C) 2002 Mark Drela, Harold Youngren
C 
C    This program is free software; you can redistribute it and/or modify
C    it under the terms of the GNU General Public License as published by
C    the Free Software Foundation; either version 2 of the License, or
C    (at your option) any later version.
C
C    This program is distributed in the hope that it will be useful,
C    but WITHOUT ANY WARRANTY; without even the implied warranty of
C    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C    GNU General Public License for more details.
C
C    You should have received a copy of the GNU General Public License
C    along with this program; if not, write to the Free Software
C    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
C***********************************************************************
C
      SUBROUTINE AERO_B()
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
      INTEGER l
      INTEGER n
      EXTERNAL TPFORC
      REAL vsq
      REAL vsq_diff
      REAL vmag
      INTRINSIC SQRT
      INTEGER iu
      INTEGER ii1
C
      cdtot = 0.
      cltot = 0.
      cxtot = 0.
      cytot = 0.
      cztot = 0.
      crtot = 0.
      cmtot = 0.
      cntot = 0.
      cdvtot = 0.
C
      cdtot_a = 0.
      cltot_a = 0.
C
      DO l=1,ncontrol
        chinge(l) = 0.
      ENDDO
C
      DO n=1,numax
        cdtot_u(n) = 0.
        cltot_u(n) = 0.
        cxtot_u(n) = 0.
        cytot_u(n) = 0.
        cztot_u(n) = 0.
        crtot_u(n) = 0.
        cmtot_u(n) = 0.
        cntot_u(n) = 0.
        DO l=1,ncontrol
          chinge_u(l, n) = 0.
        ENDDO
      ENDDO
C
      DO n=1,ncontrol
        cdtot_d(n) = 0.
        cltot_d(n) = 0.
        cxtot_d(n) = 0.
        cytot_d(n) = 0.
        cztot_d(n) = 0.
        crtot_d(n) = 0.
        cmtot_d(n) = 0.
        cntot_d(n) = 0.
        DO l=1,ncontrol
          chinge_d(l, n) = 0.
        ENDDO
      ENDDO
C
      DO n=1,ndesign
        cdtot_g(n) = 0.
        cltot_g(n) = 0.
        cxtot_g(n) = 0.
        cytot_g(n) = 0.
        cztot_g(n) = 0.
        crtot_g(n) = 0.
        cmtot_g(n) = 0.
        cntot_g(n) = 0.
        DO l=1,ncontrol
          chinge_g(l, n) = 0.
        ENDDO
      ENDDO
C
C
      CALL PUSHREAL8ARRAY(clstrp, nsmax)
      CALL PUSHREAL8ARRAY(cdstrp, nsmax)
      CALL SFFORC()
C
C---------------------------------------------------------
C---- add baseline reference CD
C      SINA = SIN(ALFA)
C      COSA = COS(ALFA)
C
C
C
C
      vsq_diff = cdref*cdtot_diff
      DO ii1=1,3
        vinf_diff(ii1) = 0.D0
      ENDDO
      vinf_diff(1) = vinf_diff(1) + 2*vinf(1)*vsq_diff
      vinf_diff(2) = vinf_diff(2) + 2*vinf(2)*vsq_diff
      vinf_diff(3) = vinf_diff(3) + 2*vinf(3)*vsq_diff
      CALL BDFORC_B()
      CALL POPREAL8ARRAY(cdstrp, nsmax)
      CALL POPREAL8ARRAY(clstrp, nsmax)
      CALL SFFORC_B()
      cdtot_diff = 0.D0
      cltot_diff = 0.D0
      END

C  Differentiation of sfforc in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: alfa vinf xyzref cdtot cltot
C   with respect to varying inputs: alfa vinf xyzref rle chord
C                wstrip ensy ensz rv1 rv2 gam
C AERO
C
C
C
      SUBROUTINE SFFORC_B()
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
C
      REAL rrot(3)
      REAL rrot_diff(3)
      REAL veff(3), vrot(3), veff_u(3, 6), vrot_u(3), wrot_u(3)
      REAL veff_diff(3), vrot_diff(3)
      REAL vperp(3)
      REAL g(3), r(3), rh(3), mh(3)
      REAL g_diff(3)
      REAL f(3), f_u(3, 6)
      REAL f_diff(3)
      REAL fgam(3), fgam_u(3, 6), fgam_d(3, ndmax), fgam_g(3, ngmax)
      REAL fgam_diff(3)
      REAL enave(3), spn(3), udrag(3), ulift(3)
      REAL spn_diff(3), udrag_diff(3), ulift_diff(3)
C
      REAL cfx_u(numax), cfy_u(numax), cfz_u(numax), cmx_u(numax), cmy_u
     +     (numax), cmz_u(numax), cfx_d(ndmax), cfy_d(ndmax), cfz_d(
     +     ndmax), cmx_d(ndmax), cmy_d(ndmax), cmz_d(ndmax), cfx_g(ngmax
     +     ), cfy_g(ngmax), cfz_g(ngmax), cmx_g(ngmax), cmy_g(ngmax), 
     +     cmz_g(ngmax), clv_u(numax), clv_d(ndmax), clv_g(ngmax)
      REAL sina
      REAL sina_diff
      INTRINSIC SIN
      REAL cosa
      REAL cosa_diff
      INTRINSIC COS
      INTEGER j
      INTEGER i1
      INTEGER nvc_strp
      REAL cr
      REAL cr_diff
      REAL sr
      REAL sr_diff
      REAL xte1
      REAL xte2
      REAL ulmag
      REAL ulmag_diff
      REAL DOT
      INTRINSIC SQRT
      REAL xr
      REAL xr_diff
      REAL yr
      REAL yr_diff
      REAL zr
      REAL zr_diff
      REAL cfx
      REAL cfx_diff
      REAL cfy
      REAL cfy_diff
      REAL cfz
      REAL cfz_diff
      REAL cmx
      REAL cmy
      REAL cmz
      INTEGER n
      INTEGER ii
      INTEGER i
      INTEGER k
      REAL fnv
      REAL fnv_u
      REAL fnv_d
      REAL fnv_g
      REAL dcfx
      REAL dcfx_diff
      REAL dcfy
      REAL dcfy_diff
      REAL dcfz
      REAL dcfz_diff
      REAL dcfx_u
      REAL dcfy_u
      REAL dcfz_u
      REAL dcfx_d
      REAL dcfy_d
      REAL dcfz_d
      REAL dcfx_g
      REAL dcfy_g
      REAL dcfz_g
      INTEGER l
      REAL dfac
      INTEGER ileg
      REAL veffmag
      REAL veffmag_diff
      REAL clv
      REAL clv_diff
      REAL cdv
      REAL cdv_diff
      REAL cdv_clv
      REAL dcvfx
      REAL dcvfx_diff
      REAL dcvfy
      REAL dcvfz
      REAL dcvfz_diff
      REAL dcvfx_u
      REAL dcvfy_u
      REAL dcvfz_u
      REAL dcvfx_d
      REAL dcvfy_d
      REAL dcvfz_d
      REAL dcvfx_g
      REAL dcvfy_g
      REAL dcvfz_g
      REAL vsq
      REAL vsqi
      REAL vspan
      REAL vpsq
      REAL vpsqi
      REAL delx
      REAL dely
      REAL delz
      REAL dmag
      INTEGER is
      INTEGER nstrps
      INTEGER jj
      INTEGER l1
      INTRINSIC MOD
      INTEGER l2
      REAL dcm
      REAL enmag
      REAL result1
      REAL result1_diff
      REAL result2
      INTEGER ii1
      REAL temp_diff
      INTEGER ad_to
      INTEGER branch
      INTEGER ad_to0
      INTEGER ad_to1
      INTEGER ii2
C
C
      sina = SIN(alfa)
      cosa = COS(alfa)
C
C***********************************************************************
C...Integrate the forces strip-wise, surface-wise and total-wise
C***********************************************************************
C
C...Calculate strip forces...
C    normalized to strip reference quantities (strip area, chord)
      DO j=1,nstrip
C
        i1 = ijfrst(j)
        nvc_strp = nvstrp(j)
C
        cr = chord(j)
        CALL PUSHREAL8(sr)
        sr = chord(j)*wstrip(j)
C
        xte1 = rle1(1, j) + chord1(j)
        xte2 = rle2(1, j) + chord2(j)
C
C--- Define local strip lift and drag directions
C--- The "spanwise" vector is cross product of strip normal with X chordline 
        CALL PUSHREAL8(spn(1))
        spn(1) = 0.0
        CALL PUSHREAL8(spn(2))
        spn(2) = ensz(j)
        CALL PUSHREAL8(spn(3))
        spn(3) = -ensy(j)
C--- Stability axes stream vector defines drag direction
        CALL PUSHREAL8(udrag(1))
        udrag(1) = cosa
        CALL PUSHREAL8(udrag(2))
        udrag(2) = 0.0
        CALL PUSHREAL8(udrag(3))
        udrag(3) = sina
C--- Lift direction is vector product of "stream" and spanwise vector
        CALL PUSHREAL8ARRAY(ulift, 3)
        CALL CROSS(udrag, spn, ulift)
        CALL PUSHREAL8(result1)
        result1 = DOT(ulift, ulift)
        CALL PUSHREAL8(ulmag)
        ulmag = SQRT(result1)
        IF (ulmag .EQ. 0.) THEN
          CALL PUSHREAL8(ulift(3))
          ulift(3) = 1.0
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL8(ulift(1))
          ulift(1) = ulift(1)/ulmag
          CALL PUSHREAL8(ulift(2))
          ulift(2) = ulift(2)/ulmag
          CALL PUSHREAL8(ulift(3))
          ulift(3) = ulift(3)/ulmag
          CALL PUSHCONTROL1B(1)
        END IF
C
C...Use the strip 1/4 chord location for strip moments
        xr = rle(1, j) + 0.25*cr
        yr = rle(2, j)
        zr = rle(3, j)
C
        CALL PUSHREAL8(cfx)
        cfx = 0.
        CALL PUSHREAL8(cfy)
        cfy = 0.
        CALL PUSHREAL8(cfz)
        cfz = 0.
C
C...Sum the forces in the strip as generated by velocity
C    (freestream + rotation + induced) acting on bound vortex 
        DO ii=1,nvc_strp
          CALL PUSHINTEGER4(i)
          i = i1 + (ii-1)
C
C------- local moment reference vector from vortex midpoint to strip c/4 pt.
C          R(1) = 0.5*(RV1(1,I) + RV2(1,I)) - XR
C          R(2) = 0.5*(RV1(2,I) + RV2(2,I)) - YR
C          R(3) = 0.5*(RV1(3,I) + RV2(3,I)) - ZR
C
C------- vector from rotation axes
C          RROT(1) = 0.5*(RV1(1,I) + RV2(1,I)) - XYZREF(1)
C          RROT(2) = 0.5*(RV1(2,I) + RV2(2,I)) - XYZREF(2)
C          RROT(3) = 0.5*(RV1(3,I) + RV2(3,I)) - XYZREF(3)
          CALL PUSHREAL8(rrot(1))
          rrot(1) = rv(1, i) - xyzref(1)
          CALL PUSHREAL8(rrot(2))
          rrot(2) = rv(2, i) - xyzref(2)
          CALL PUSHREAL8(rrot(3))
          rrot(3) = rv(3, i) - xyzref(3)
C
C-------- set total effective velocity = freestream + rotation + induced
          CALL CROSS(rrot, wrot, vrot)
          CALL PUSHREAL8(veff(1))
          veff(1) = vinf(1) + vrot(1) + wv(1, i)
          CALL PUSHREAL8(veff(2))
          veff(2) = vinf(2) + vrot(2) + wv(2, i)
          CALL PUSHREAL8(veff(3))
          veff(3) = vinf(3) + vrot(3) + wv(3, i)
C
C-------- Force coefficient on vortex segment is 2(Veff x Gamma)
          CALL PUSHREAL8(g(1))
          g(1) = rv2(1, i) - rv1(1, i)
          CALL PUSHREAL8(g(2))
          g(2) = rv2(2, i) - rv1(2, i)
          CALL PUSHREAL8(g(3))
          g(3) = rv2(3, i) - rv1(3, i)
          CALL PUSHREAL8ARRAY(f, 3)
          CALL CROSS(veff, g, f)
C
          CALL PUSHREAL8(fgam(1))
          fgam(1) = 2.0*gam(i)*f(1)
          CALL PUSHREAL8(fgam(2))
          fgam(2) = 2.0*gam(i)*f(2)
          CALL PUSHREAL8(fgam(3))
          fgam(3) = 2.0*gam(i)*f(3)
C
C-------- vortex contribution to strip forces
          dcfx = fgam(1)/sr
          dcfy = fgam(2)/sr
          dcfz = fgam(3)/sr
C
C-------- forces normalized by strip area
          cfx = cfx + dcfx
          cfy = cfy + dcfy
          cfz = cfz + dcfz
C
C-------- moments referred to strip c/4 pt., normalized by strip chord and area
C
C-------- accumulate strip spanloading = c*CN
        ENDDO
        CALL PUSHINTEGER4(ii - 1)
C
C
C
        IF (.NOT.ltrforce) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
C
C...Sum forces in the strip as generated by velocity (freestream + rotation)
C     the parts of trailing legs which lie on the surface
          DO ii=1,nvc_strp
            CALL PUSHINTEGER4(i)
            i = i1 + (ii-1)
C
            DO ileg=1,2
              IF (ileg .EQ. 1) THEN
C----------- local moment reference vector from vortex midpoint to strip c/4 pt
C 
C----------- vector from rotation axes
                CALL PUSHREAL8(rrot(1))
                rrot(1) = 0.5*(rv1(1, i)+xte1) - xyzref(1)
                CALL PUSHREAL8(rrot(2))
                rrot(2) = rv1(2, i) - xyzref(2)
                CALL PUSHREAL8(rrot(3))
                rrot(3) = rv1(3, i) - xyzref(3)
C
C----------- part of trailing leg lying on surface
                CALL PUSHREAL8(g(1))
                g(1) = rv1(1, i) - xte1
                CALL PUSHREAL8(g(2))
                g(2) = 0.
                CALL PUSHREAL8(g(3))
                g(3) = 0.
C
                CALL PUSHCONTROL1B(0)
              ELSE
C----------- local moment reference vector from vortex midpoint to strip c/4 pt
C
C----------- vector from rotation axes
                CALL PUSHREAL8(rrot(1))
                rrot(1) = 0.5*(rv2(1, i)+xte2) - xyzref(1)
                CALL PUSHREAL8(rrot(2))
                rrot(2) = rv2(2, i) - xyzref(2)
                CALL PUSHREAL8(rrot(3))
                rrot(3) = rv2(3, i) - xyzref(3)
C
C----------- part of trailing leg lying on surface
                CALL PUSHREAL8(g(1))
                g(1) = xte2 - rv2(1, i)
                CALL PUSHREAL8(g(2))
                g(2) = 0.
                CALL PUSHREAL8(g(3))
                g(3) = 0.
                CALL PUSHCONTROL1B(1)
              END IF
C
C---------- set total effective velocity = freestream + rotation
              CALL CROSS(rrot, wrot, vrot)
              CALL PUSHREAL8(veff(1))
              veff(1) = vinf(1) + vrot(1)
              CALL PUSHREAL8(veff(2))
              veff(2) = vinf(2) + vrot(2)
              CALL PUSHREAL8(veff(3))
              veff(3) = vinf(3) + vrot(3)
C
C---------- Force coefficient on vortex segment is 2(Veff x Gamma)
              CALL PUSHREAL8ARRAY(f, 3)
              CALL CROSS(veff, g, f)
C
              CALL PUSHREAL8(fgam(1))
              fgam(1) = 2.0*gam(i)*f(1)
              CALL PUSHREAL8(fgam(2))
              fgam(2) = 2.0*gam(i)*f(2)
              CALL PUSHREAL8(fgam(3))
              fgam(3) = 2.0*gam(i)*f(3)
C
CC---------- Delta Cp (loading across lifting surface) due to vortex 
C            FNV = DOT(ENV(1,I),FGAM)
C            DCP(I) = FNV / (DXV(I)*WSTRIP(J))
CC
C            DO N = 1, NUMAX
C              FNV_U = DOT(ENV(1,I),FGAM_U(1,N))
C              DCP_U(I,N) = FNV_U / (DXV(I)*WSTRIP(J))
C            ENDDO
CC
C            DO N = 1, NCONTROL
C              FNV_D = DOT(ENV(1,I),FGAM_D(1,N)) + DOT(ENV_D(1,I,N),FGAM)
C              DCP_D(I,N) = FNV_D / (DXV(I)*WSTRIP(J))
C            ENDDO
CC
C            DO N = 1, NDESIGN
C              FNV_G = DOT(ENV(1,I),FGAM_G(1,N)) + DOT(ENV_G(1,I,N),FGAM)
C              DCP_G(I,N) = FNV_G / (DXV(I)*WSTRIP(J))
C            ENDDO
C
C
C---------- vortex contribution to strip forces
              dcfx = fgam(1)/sr
              dcfy = fgam(2)/sr
              dcfz = fgam(3)/sr
C
C---------- forces normalized by strip area
              cfx = cfx + dcfx
              cfy = cfy + dcfy
              cfz = cfz + dcfz
C
C---------- moments referred to strip c/4 pt., normalized by strip chord and area
C
C---------- accumulate strip spanloading = c*CN
            ENDDO
          ENDDO
          CALL PUSHINTEGER4(ii - 1)
          CALL PUSHCONTROL1B(1)
        END IF
C
CC---------- hinge moments
C            DO L=1, NCONTROL
C              RH(1) = RV(1,I) - PHINGE(1,J,L)
C              RH(2) = RV(2,I) - PHINGE(2,J,L)
C              RH(3) = RV(3,I) - PHINGE(3,J,L)
CC
C              DFAC = DCONTROL(I,L) / (SREF * CREF)
CC
C              CALL CROSS(RH,FGAM,MH)
C              CHINGE(L) = CHINGE(L) + DOT(MH,VHINGE(1,J,L))*DFAC
CC
C              DO N = 1, NUMAX
C                CALL CROSS(RH,FGAM_U(1,N),MH)
C                CHINGE_U(L,N) = CHINGE_U(L,N) + DOT(MH,VHINGE(1,J,L))*DFAC
C              ENDDO
C              DO N = 1, NCONTROL
C                CALL CROSS(RH,FGAM_D(1,N),MH)
C                CHINGE_D(L,N) = CHINGE_D(L,N) + DOT(MH,VHINGE(1,J,L))*DFAC
C              ENDDO
C              DO N = 1, NDESIGN
C                CALL CROSS(RH,FGAM_G(1,N),MH)
C                CHINGE_G(L,N) = CHINGE_G(L,N) + DOT(MH,VHINGE(1,J,L))*DFAC
C              ENDDO
C            ENDDO
C
C
C
C*******************************************************************
C--- Drag terms due to viscous effects
C    Drag forces are assumed to be characterized by velocity at the c/4 
C    point and are assumed to act thru the same point. CD is defined by 
C    user-specified CD(CL) polar.  Drag comes from function lookup on 
C    section polar drag using local lift coefficient.  
C
C
        IF (lvisc .AND. lviscstrp(j)) THEN
C--- local moment reference vector from ref point to c/4 point
C         R(1) = XR - XR
C         R(2) = YR - YR
C         R(3) = ZR - ZR
C--- Get rotational velocity at strip 1/4 chord reference point 
          CALL PUSHREAL8(rrot(1))
          rrot(1) = xr - xyzref(1)
          CALL PUSHREAL8(rrot(2))
          rrot(2) = yr - xyzref(2)
          CALL PUSHREAL8(rrot(3))
          rrot(3) = zr - xyzref(3)
C--- Onset velocity at strip c/4 = freestream + rotation
          CALL CROSS(rrot, wrot, vrot)
          CALL PUSHREAL8(veff(1))
          veff(1) = vinf(1) + vrot(1)
          CALL PUSHREAL8(veff(2))
          veff(2) = vinf(2) + vrot(2)
          CALL PUSHREAL8(veff(3))
          veff(3) = vinf(3) + vrot(3)
          CALL PUSHREAL8(veffmag)
          veffmag = SQRT(veff(1)**2 + veff(2)**2 + veff(3)**2)
C
C--- Generate CD from stored function using strip CL as parameter
          clv = ulift(1)*cfx + ulift(2)*cfy + ulift(3)*cfz
C
          CALL PUSHREAL8(cdv)
          CALL CDCL(j, clv, cdv, cdv_clv)
C
C--- Strip viscous force contribution (per unit strip area)
          dcvfx = veff(1)*veffmag*cdv
          dcvfz = veff(3)*veffmag*cdv
C
C--- Add viscous terms to strip forces and moments
          CALL PUSHREAL8(cfx)
          cfx = cfx + dcvfx
          CALL PUSHREAL8(cfz)
          cfz = cfz + dcvfz
C--- Viscous forces acting at c/4 have no effect on moments at c/4 pt.
C         CMX = CMX + (DCVFZ*R(2) - DCVFY*R(3))/CR
C         CMY = CMY + (DCVFX*R(3) - DCVFZ*R(1))/CR
C         CMZ = CMZ + (DCVFY*R(1) - DCVFX*R(2))/CR
C
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
C
C
C*******************************************************************
C
C...Store strip X,Y,Z body axes forces 
C   (these are normalized by strip area and moments are referred to
C    c/4 point and are normalized by strip chord and area)
C
C...Transform strip body axes forces into stability axes
        cdstrp(j) = cfx*cosa + cfz*sina
        clstrp(j) = -(cfx*sina) + cfz*cosa
C
C
C...Take components of X,Y,Z forces in local strip axes 
C   (axial/normal and lift/drag)
C    in plane normal to (possibly dihedralled) strip
C
C------ vector at chord reference point from rotation axes
        CALL PUSHREAL8(rrot(1))
        rrot(1) = xsref(j) - xyzref(1)
        CALL PUSHREAL8(rrot(2))
        rrot(2) = ysref(j) - xyzref(2)
        CALL PUSHREAL8(rrot(3))
        rrot(3) = zsref(j) - xyzref(3)
C
C------ set total effective velocity = freestream + rotation
        CALL CROSS(rrot, wrot, vrot)
        CALL PUSHREAL8(veff(1))
        veff(1) = vinf(1) + vrot(1)
        CALL PUSHREAL8(veff(2))
        veff(2) = vinf(2) + vrot(2)
        CALL PUSHREAL8(veff(3))
        veff(3) = vinf(3) + vrot(3)
C
      ENDDO
C
C
C
C
C...Surface forces and moments summed from strip forces...
C   XXSURF values normalized to configuration reference quantities
C   XX_SRF values normalized to each surface reference quantities
      DO is=1,nsurf
C
        nstrps = nj(is)
        DO jj=1,nstrps
          CALL PUSHREAL8(sr)
C
C
C
C
C
C--- Bug fix, HHY/S.Allmaras 
C
        ENDDO
        CALL PUSHINTEGER4(jj - 1)
C--- Surface hinge moments defined by surface LE moment about hinge vector 
Ccc        CMLE_SRF(IS) = DOT(CM_SRF(1,IS),VHINGE(1,IS))
C
C
C-------------------------------------------------
        IF (lfload(is)) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
      ENDDO
C-------------------------------------------------
C
C
C--- If case is XZ symmetric (IYSYM=1), add contributions from images,
C    zero out the asymmetric forces and double the symmetric ones
      IF (iysym .EQ. 1) THEN
        cltot_diff = 2.0*cltot_diff
        cdtot_diff = 2.0*cdtot_diff
      END IF
      DO ii1=1,nfmax
        cdsurf_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nfmax
        clsurf_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        chord_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        wstrip_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        cdstrp_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        clstrp_diff(ii1) = 0.D0
      ENDDO
      DO is=nsurf,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          clsurf_diff(is) = clsurf_diff(is) + cltot_diff
          cdsurf_diff(is) = cdsurf_diff(is) + cdtot_diff
        END IF
        CALL POPINTEGER4(ad_to1)
        DO jj=ad_to1,1,-1
          j = jfrst(is) + jj - 1
          sr = chord(j)*wstrip(j)
          clstrp_diff(j) = clstrp_diff(j) + sr*clsurf_diff(is)/sref
          sr_diff = clstrp(j)*clsurf_diff(is)/sref + cdstrp(j)*
     +      cdsurf_diff(is)/sref
          cdstrp_diff(j) = cdstrp_diff(j) + sr*cdsurf_diff(is)/sref
          CALL POPREAL8(sr)
          chord_diff(j) = chord_diff(j) + wstrip(j)*sr_diff
          wstrip_diff(j) = wstrip_diff(j) + chord(j)*sr_diff
        ENDDO
        clsurf_diff(is) = 0.D0
        cdsurf_diff(is) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        DO ii2=1,3
          rle_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nsmax
        ensy_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        ensz_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nvmax
        DO ii2=1,3
          rv1_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvmax
        DO ii2=1,3
          rv2_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvmax
        gam_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        f_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        g_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        udrag_diff(ii1) = 0.D0
      ENDDO
      cosa_diff = 0.D0
      DO ii1=1,3
        vrot_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        veff_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        ulift_diff(ii1) = 0.D0
      ENDDO
      sina_diff = 0.D0
      DO ii1=1,3
        fgam_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        rrot_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        spn_diff(ii1) = 0.D0
      ENDDO
      DO j=nstrip,1,-1
        CALL POPREAL8(veff(3))
        vinf_diff(3) = vinf_diff(3) + veff_diff(3)
        vrot_diff(3) = vrot_diff(3) + veff_diff(3)
        veff_diff(3) = 0.D0
        CALL POPREAL8(veff(2))
        vinf_diff(2) = vinf_diff(2) + veff_diff(2)
        vrot_diff(2) = vrot_diff(2) + veff_diff(2)
        veff_diff(2) = 0.D0
        CALL POPREAL8(veff(1))
        vinf_diff(1) = vinf_diff(1) + veff_diff(1)
        vrot_diff(1) = vrot_diff(1) + veff_diff(1)
        veff_diff(1) = 0.D0
        DO ii1=1,3
          wrot_diff(ii1) = 0.D0
        ENDDO
        CALL CROSS_B(rrot, rrot_diff, wrot, wrot_diff, vrot, vrot_diff)
        CALL POPREAL8(rrot(3))
        xyzref_diff(3) = xyzref_diff(3) - rrot_diff(3)
        rrot_diff(3) = 0.D0
        CALL POPREAL8(rrot(2))
        xyzref_diff(2) = xyzref_diff(2) - rrot_diff(2)
        rrot_diff(2) = 0.D0
        CALL POPREAL8(rrot(1))
        xyzref_diff(1) = xyzref_diff(1) - rrot_diff(1)
        rrot_diff(1) = 0.D0
        cfz_diff = cosa*clstrp_diff(j) + sina*cdstrp_diff(j)
        cosa_diff = cosa_diff + cfz*clstrp_diff(j) + cfx*cdstrp_diff(j)
        cfx_diff = cosa*cdstrp_diff(j) - sina*clstrp_diff(j)
        sina_diff = sina_diff + cfz*cdstrp_diff(j) - cfx*clstrp_diff(j)
        clstrp_diff(j) = 0.D0
        cdstrp_diff(j) = 0.D0
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(cfz)
          dcvfz_diff = cfz_diff
          CALL POPREAL8(cfx)
          dcvfx_diff = cfx_diff
          veff_diff(3) = veff_diff(3) + veffmag*cdv*dcvfz_diff
          veffmag_diff = cdv*veff(3)*dcvfz_diff + cdv*veff(1)*dcvfx_diff
          cdv_diff = veffmag*veff(3)*dcvfz_diff + veffmag*veff(1)*
     +      dcvfx_diff
          veff_diff(1) = veff_diff(1) + veffmag*cdv*dcvfx_diff
          clv = ulift(1)*cfx + ulift(2)*cfy + ulift(3)*cfz
          CALL POPREAL8(cdv)
          CALL CDCL_B(j, clv, clv_diff, cdv, cdv_diff, cdv_clv)
          ulift_diff(1) = ulift_diff(1) + cfx*clv_diff
          cfx_diff = cfx_diff + ulift(1)*clv_diff
          ulift_diff(2) = ulift_diff(2) + cfy*clv_diff
          cfy_diff = ulift(2)*clv_diff
          ulift_diff(3) = ulift_diff(3) + cfz*clv_diff
          cfz_diff = cfz_diff + ulift(3)*clv_diff
          CALL POPREAL8(veffmag)
          IF (veff(1)**2 + veff(2)**2 + veff(3)**2 .EQ. 0.D0) THEN
            temp_diff = 0.D0
          ELSE
            temp_diff = veffmag_diff/(2.0*SQRT(veff(1)**2+veff(2)**2+
     +        veff(3)**2))
          END IF
          veff_diff(1) = veff_diff(1) + 2*veff(1)*temp_diff
          veff_diff(2) = veff_diff(2) + 2*veff(2)*temp_diff
          veff_diff(3) = veff_diff(3) + 2*veff(3)*temp_diff
          CALL POPREAL8(veff(3))
          vinf_diff(3) = vinf_diff(3) + veff_diff(3)
          vrot_diff(3) = vrot_diff(3) + veff_diff(3)
          veff_diff(3) = 0.D0
          CALL POPREAL8(veff(2))
          vinf_diff(2) = vinf_diff(2) + veff_diff(2)
          vrot_diff(2) = vrot_diff(2) + veff_diff(2)
          veff_diff(2) = 0.D0
          CALL POPREAL8(veff(1))
          vinf_diff(1) = vinf_diff(1) + veff_diff(1)
          vrot_diff(1) = vrot_diff(1) + veff_diff(1)
          veff_diff(1) = 0.D0
          DO ii1=1,3
            wrot_diff(ii1) = 0.D0
          ENDDO
          CALL CROSS_B(rrot, rrot_diff, wrot, wrot_diff, vrot, vrot_diff
     +                )
          CALL POPREAL8(rrot(3))
          zr_diff = rrot_diff(3)
          xyzref_diff(3) = xyzref_diff(3) - rrot_diff(3)
          rrot_diff(3) = 0.D0
          CALL POPREAL8(rrot(2))
          yr_diff = rrot_diff(2)
          xyzref_diff(2) = xyzref_diff(2) - rrot_diff(2)
          rrot_diff(2) = 0.D0
          CALL POPREAL8(rrot(1))
          xr_diff = rrot_diff(1)
          xyzref_diff(1) = xyzref_diff(1) - rrot_diff(1)
          rrot_diff(1) = 0.D0
        ELSE
          cfy_diff = 0.D0
          xr_diff = 0.D0
          yr_diff = 0.D0
          zr_diff = 0.D0
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          sr_diff = 0.D0
        ELSE
          sr_diff = 0.D0
          CALL POPINTEGER4(ad_to0)
          DO ii=ad_to0,1,-1
            DO ileg=2,1,-1
              dcfz_diff = cfz_diff
              dcfy_diff = cfy_diff
              dcfx_diff = cfx_diff
              fgam_diff(3) = fgam_diff(3) + dcfz_diff/sr
              sr_diff = sr_diff - fgam(3)*dcfz_diff/sr**2 - fgam(2)*
     +          dcfy_diff/sr**2 - fgam(1)*dcfx_diff/sr**2
              fgam_diff(2) = fgam_diff(2) + dcfy_diff/sr
              fgam_diff(1) = fgam_diff(1) + dcfx_diff/sr
              CALL POPREAL8(fgam(3))
              gam_diff(i) = gam_diff(i) + f(3)*2.0*fgam_diff(3) + f(2)*
     +          2.0*fgam_diff(2) + f(1)*2.0*fgam_diff(1)
              f_diff(3) = f_diff(3) + gam(i)*2.0*fgam_diff(3)
              fgam_diff(3) = 0.D0
              CALL POPREAL8(fgam(2))
              f_diff(2) = f_diff(2) + gam(i)*2.0*fgam_diff(2)
              fgam_diff(2) = 0.D0
              CALL POPREAL8(fgam(1))
              f_diff(1) = f_diff(1) + gam(i)*2.0*fgam_diff(1)
              fgam_diff(1) = 0.D0
              CALL POPREAL8ARRAY(f, 3)
              CALL CROSS_B(veff, veff_diff, g, g_diff, f, f_diff)
              CALL POPREAL8(veff(3))
              vinf_diff(3) = vinf_diff(3) + veff_diff(3)
              vrot_diff(3) = vrot_diff(3) + veff_diff(3)
              veff_diff(3) = 0.D0
              CALL POPREAL8(veff(2))
              vinf_diff(2) = vinf_diff(2) + veff_diff(2)
              vrot_diff(2) = vrot_diff(2) + veff_diff(2)
              veff_diff(2) = 0.D0
              CALL POPREAL8(veff(1))
              vinf_diff(1) = vinf_diff(1) + veff_diff(1)
              vrot_diff(1) = vrot_diff(1) + veff_diff(1)
              veff_diff(1) = 0.D0
              DO ii1=1,3
                wrot_diff(ii1) = 0.D0
              ENDDO
              CALL CROSS_B(rrot, rrot_diff, wrot, wrot_diff, vrot, 
     +                     vrot_diff)
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                CALL POPREAL8(g(3))
                g_diff(3) = 0.D0
                CALL POPREAL8(g(2))
                g_diff(2) = 0.D0
                CALL POPREAL8(g(1))
                rv1_diff(1, i) = rv1_diff(1, i) + g_diff(1) + 0.5*
     +            rrot_diff(1)
                g_diff(1) = 0.D0
                CALL POPREAL8(rrot(3))
                rv1_diff(3, i) = rv1_diff(3, i) + rrot_diff(3)
                xyzref_diff(3) = xyzref_diff(3) - rrot_diff(3)
                rrot_diff(3) = 0.D0
                CALL POPREAL8(rrot(2))
                rv1_diff(2, i) = rv1_diff(2, i) + rrot_diff(2)
                xyzref_diff(2) = xyzref_diff(2) - rrot_diff(2)
                rrot_diff(2) = 0.D0
                CALL POPREAL8(rrot(1))
                xyzref_diff(1) = xyzref_diff(1) - rrot_diff(1)
                rrot_diff(1) = 0.D0
              ELSE
                CALL POPREAL8(g(3))
                g_diff(3) = 0.D0
                CALL POPREAL8(g(2))
                g_diff(2) = 0.D0
                CALL POPREAL8(g(1))
                rv2_diff(1, i) = rv2_diff(1, i) + 0.5*rrot_diff(1) - 
     +            g_diff(1)
                g_diff(1) = 0.D0
                CALL POPREAL8(rrot(3))
                rv2_diff(3, i) = rv2_diff(3, i) + rrot_diff(3)
                xyzref_diff(3) = xyzref_diff(3) - rrot_diff(3)
                rrot_diff(3) = 0.D0
                CALL POPREAL8(rrot(2))
                rv2_diff(2, i) = rv2_diff(2, i) + rrot_diff(2)
                xyzref_diff(2) = xyzref_diff(2) - rrot_diff(2)
                rrot_diff(2) = 0.D0
                CALL POPREAL8(rrot(1))
                xyzref_diff(1) = xyzref_diff(1) - rrot_diff(1)
                rrot_diff(1) = 0.D0
              END IF
            ENDDO
            CALL POPINTEGER4(i)
          ENDDO
        END IF
        CALL POPINTEGER4(ad_to)
        DO ii=ad_to,1,-1
          dcfz_diff = cfz_diff
          dcfy_diff = cfy_diff
          dcfx_diff = cfx_diff
          fgam_diff(3) = fgam_diff(3) + dcfz_diff/sr
          sr_diff = sr_diff - fgam(3)*dcfz_diff/sr**2 - fgam(2)*
     +      dcfy_diff/sr**2 - fgam(1)*dcfx_diff/sr**2
          fgam_diff(2) = fgam_diff(2) + dcfy_diff/sr
          fgam_diff(1) = fgam_diff(1) + dcfx_diff/sr
          CALL POPREAL8(fgam(3))
          gam_diff(i) = gam_diff(i) + f(3)*2.0*fgam_diff(3) + f(2)*2.0*
     +      fgam_diff(2) + f(1)*2.0*fgam_diff(1)
          f_diff(3) = f_diff(3) + gam(i)*2.0*fgam_diff(3)
          fgam_diff(3) = 0.D0
          CALL POPREAL8(fgam(2))
          f_diff(2) = f_diff(2) + gam(i)*2.0*fgam_diff(2)
          fgam_diff(2) = 0.D0
          CALL POPREAL8(fgam(1))
          f_diff(1) = f_diff(1) + gam(i)*2.0*fgam_diff(1)
          fgam_diff(1) = 0.D0
          CALL POPREAL8ARRAY(f, 3)
          CALL CROSS_B(veff, veff_diff, g, g_diff, f, f_diff)
          CALL POPREAL8(g(3))
          rv2_diff(3, i) = rv2_diff(3, i) + g_diff(3)
          rv1_diff(3, i) = rv1_diff(3, i) - g_diff(3)
          g_diff(3) = 0.D0
          CALL POPREAL8(g(2))
          rv2_diff(2, i) = rv2_diff(2, i) + g_diff(2)
          rv1_diff(2, i) = rv1_diff(2, i) - g_diff(2)
          g_diff(2) = 0.D0
          CALL POPREAL8(g(1))
          rv2_diff(1, i) = rv2_diff(1, i) + g_diff(1)
          rv1_diff(1, i) = rv1_diff(1, i) - g_diff(1)
          g_diff(1) = 0.D0
          CALL POPREAL8(veff(3))
          vinf_diff(3) = vinf_diff(3) + veff_diff(3)
          vrot_diff(3) = vrot_diff(3) + veff_diff(3)
          veff_diff(3) = 0.D0
          CALL POPREAL8(veff(2))
          vinf_diff(2) = vinf_diff(2) + veff_diff(2)
          vrot_diff(2) = vrot_diff(2) + veff_diff(2)
          veff_diff(2) = 0.D0
          CALL POPREAL8(veff(1))
          vinf_diff(1) = vinf_diff(1) + veff_diff(1)
          vrot_diff(1) = vrot_diff(1) + veff_diff(1)
          veff_diff(1) = 0.D0
          DO ii1=1,3
            wrot_diff(ii1) = 0.D0
          ENDDO
          CALL CROSS_B(rrot, rrot_diff, wrot, wrot_diff, vrot, vrot_diff
     +                )
          CALL POPREAL8(rrot(3))
          xyzref_diff(3) = xyzref_diff(3) - rrot_diff(3)
          rrot_diff(3) = 0.D0
          CALL POPREAL8(rrot(2))
          xyzref_diff(2) = xyzref_diff(2) - rrot_diff(2)
          rrot_diff(2) = 0.D0
          CALL POPREAL8(rrot(1))
          xyzref_diff(1) = xyzref_diff(1) - rrot_diff(1)
          rrot_diff(1) = 0.D0
          CALL POPINTEGER4(i)
        ENDDO
        CALL POPREAL8(cfz)
        CALL POPREAL8(cfy)
        CALL POPREAL8(cfx)
        rle_diff(3, j) = rle_diff(3, j) + zr_diff
        rle_diff(2, j) = rle_diff(2, j) + yr_diff
        rle_diff(1, j) = rle_diff(1, j) + xr_diff
        cr_diff = 0.25*xr_diff
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(ulift(3))
          ulift_diff(3) = 0.D0
          ulmag_diff = 0.D0
        ELSE
          CALL POPREAL8(ulift(3))
          CALL POPREAL8(ulift(2))
          CALL POPREAL8(ulift(1))
          ulmag_diff = -(ulift(3)*ulift_diff(3)/ulmag**2) - ulift(2)*
     +      ulift_diff(2)/ulmag**2 - ulift(1)*ulift_diff(1)/ulmag**2
          ulift_diff(3) = ulift_diff(3)/ulmag
          ulift_diff(2) = ulift_diff(2)/ulmag
          ulift_diff(1) = ulift_diff(1)/ulmag
        END IF
        CALL POPREAL8(ulmag)
        IF (result1 .EQ. 0.D0) THEN
          result1_diff = 0.D0
        ELSE
          result1_diff = ulmag_diff/(2.0*SQRT(result1))
        END IF
        CALL POPREAL8(result1)
        CALL DOT_B(ulift, ulift_diff, ulift, ulift_diff, result1_diff)
        CALL POPREAL8ARRAY(ulift, 3)
        CALL CROSS_B(udrag, udrag_diff, spn, spn_diff, ulift, ulift_diff
     +              )
        CALL POPREAL8(udrag(3))
        sina_diff = sina_diff + udrag_diff(3)
        udrag_diff(3) = 0.D0
        CALL POPREAL8(udrag(2))
        udrag_diff(2) = 0.D0
        CALL POPREAL8(udrag(1))
        cosa_diff = cosa_diff + udrag_diff(1)
        udrag_diff(1) = 0.D0
        CALL POPREAL8(spn(3))
        ensy_diff(j) = ensy_diff(j) - spn_diff(3)
        spn_diff(3) = 0.D0
        CALL POPREAL8(spn(2))
        ensz_diff(j) = ensz_diff(j) + spn_diff(2)
        spn_diff(2) = 0.D0
        CALL POPREAL8(spn(1))
        spn_diff(1) = 0.D0
        CALL POPREAL8(sr)
        chord_diff(j) = chord_diff(j) + wstrip(j)*sr_diff + cr_diff
        wstrip_diff(j) = wstrip_diff(j) + chord(j)*sr_diff
      ENDDO
      alfa_diff = alfa_diff + COS(alfa)*sina_diff - SIN(alfa)*cosa_diff
      END

C  Differentiation of bdforc in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: vinf cdtot cltot
C   with respect to varying inputs: alfa vinf xyzref cdtot cltot
C SFFORC
C
C
C
      SUBROUTINE BDFORC_B()
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
C
      REAL rrot(3)
      REAL rrot_diff(3)
      REAL veff(3), vrot(3), veff_u(3, 6), vrot_u(3), wrot_u(3)
      REAL veff_diff(3), vrot_diff(3)
      REAL drl(3), esl(3), fb(3), fb_u(3, numax), mb(3), mb_u(3, numax)
      REAL fb_diff(3)
      REAL cdbdy_u(numax), clbdy_u(numax), cxbdy_u(numax), cybdy_u(numax
     +     ), czbdy_u(numax), crbdy_u(numax), cmbdy_u(numax), cnbdy_u(
     +     numax)
      REAL betm
      INTRINSIC SQRT
      REAL sina
      REAL sina_diff
      INTRINSIC SIN
      REAL cosa
      REAL cosa_diff
      INTRINSIC COS
      INTEGER ib
      INTEGER iu
      INTEGER ilseg
      INTEGER l1
      INTEGER l2
      INTEGER l
      REAL drlmag
      REAL drlmi
      REAL dia
      REAL dinv
      INTEGER k
      REAL us
      REAL us_diff
      REAL un
      REAL un_diff
      REAL un_u
      INTEGER ii1
      REAL(kind=8) temp_diff
      INTEGER ad_to
C
C
      betm = SQRT(1.0 - mach**2)
C
      sina = SIN(alfa)
      cosa = COS(alfa)
C
C
C---- add on body force contributions
      DO ib=1,nbody
C
        DO ilseg=1,nl(ib)-1
          l1 = lfrst(ib) + ilseg - 1
          l2 = lfrst(ib) + ilseg
C
          l = l1
C
          drl(1) = (rl(1, l2)-rl(1, l1))/betm
          drl(2) = rl(2, l2) - rl(2, l1)
          drl(3) = rl(3, l2) - rl(3, l1)
          drlmag = SQRT(drl(1)**2 + drl(2)**2 + drl(3)**2)
          IF (drlmag .EQ. 0.0) THEN
            drlmi = 0.0
          ELSE
            drlmi = 1.0/drlmag
          END IF
C
C-------- unit vector along line segment
          CALL PUSHREAL8(esl(1))
          esl(1) = drl(1)*drlmi
          CALL PUSHREAL8(esl(2))
          esl(2) = drl(2)*drlmi
          CALL PUSHREAL8(esl(3))
          esl(3) = drl(3)*drlmi
C
          CALL PUSHREAL8(rrot(1))
          rrot(1) = 0.5*(rl(1, l2)+rl(1, l1)) - xyzref(1)
          CALL PUSHREAL8(rrot(2))
          rrot(2) = 0.5*(rl(2, l2)+rl(2, l1)) - xyzref(2)
          CALL PUSHREAL8(rrot(3))
          rrot(3) = 0.5*(rl(3, l2)+rl(3, l1)) - xyzref(3)
C
C-------- go over freestream velocity and rotation components
          CALL CROSS(rrot, wrot, vrot)
C
          veff(1) = (vinf(1)+vrot(1))/betm
          veff(2) = vinf(2) + vrot(2)
          veff(3) = vinf(3) + vrot(3)
C
C-------- U.es
          us = veff(1)*esl(1) + veff(2)*esl(2) + veff(3)*esl(3)
C
C
C-------- velocity projected on normal plane = U - (U.es) es
          DO k=1,3
            un = veff(k) - us*esl(k)
            CALL PUSHREAL8(fb(k))
            fb(k) = un*src(l)
          ENDDO
        ENDDO
        CALL PUSHINTEGER4(ilseg - 1)
      ENDDO
      DO ii1=1,3
        xyzref_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nbmax
        cdbdy_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nbmax
        clbdy_diff(ii1) = 0.D0
      ENDDO
      cosa_diff = 0.D0
      DO ii1=1,3
        vrot_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        fb_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        veff_diff(ii1) = 0.D0
      ENDDO
      sina_diff = 0.D0
      DO ii1=1,3
        rrot_diff(ii1) = 0.D0
      ENDDO
      DO ib=nbody,1,-1
        clbdy_diff(ib) = clbdy_diff(ib) + cltot_diff
        cdbdy_diff(ib) = cdbdy_diff(ib) + cdtot_diff
        CALL POPINTEGER4(ad_to)
        DO ilseg=ad_to,1,-1
          temp_diff = 2.0*clbdy_diff(ib)/sref
          fb_diff(3) = fb_diff(3) + cosa*temp_diff
          cosa_diff = cosa_diff + fb(3)*temp_diff
          fb_diff(1) = fb_diff(1) - sina*temp_diff
          sina_diff = sina_diff - fb(1)*temp_diff
          temp_diff = 2.0*cdbdy_diff(ib)/sref
          fb_diff(1) = fb_diff(1) + cosa*temp_diff
          cosa_diff = cosa_diff + fb(1)*temp_diff
          fb_diff(3) = fb_diff(3) + sina*temp_diff
          sina_diff = sina_diff + fb(3)*temp_diff
          l1 = lfrst(ib) + ilseg - 1
          l = l1
          us_diff = 0.D0
          DO k=3,1,-1
            CALL POPREAL8(fb(k))
            un_diff = src(l)*fb_diff(k)
            fb_diff(k) = 0.D0
            veff_diff(k) = veff_diff(k) + un_diff
            us_diff = us_diff - esl(k)*un_diff
          ENDDO
          veff_diff(1) = veff_diff(1) + esl(1)*us_diff
          veff_diff(2) = veff_diff(2) + esl(2)*us_diff
          veff_diff(3) = veff_diff(3) + esl(3)*us_diff
          vinf_diff(3) = vinf_diff(3) + veff_diff(3)
          vrot_diff(3) = vrot_diff(3) + veff_diff(3)
          veff_diff(3) = 0.D0
          vinf_diff(2) = vinf_diff(2) + veff_diff(2)
          vrot_diff(2) = vrot_diff(2) + veff_diff(2)
          veff_diff(2) = 0.D0
          vinf_diff(1) = vinf_diff(1) + veff_diff(1)/betm
          vrot_diff(1) = vrot_diff(1) + veff_diff(1)/betm
          veff_diff(1) = 0.D0
          DO ii1=1,3
            wrot_diff(ii1) = 0.D0
          ENDDO
          CALL CROSS_B(rrot, rrot_diff, wrot, wrot_diff, vrot, vrot_diff
     +                )
          CALL POPREAL8(rrot(3))
          xyzref_diff(3) = xyzref_diff(3) - rrot_diff(3)
          rrot_diff(3) = 0.D0
          CALL POPREAL8(rrot(2))
          xyzref_diff(2) = xyzref_diff(2) - rrot_diff(2)
          rrot_diff(2) = 0.D0
          CALL POPREAL8(rrot(1))
          xyzref_diff(1) = xyzref_diff(1) - rrot_diff(1)
          rrot_diff(1) = 0.D0
          CALL POPREAL8(esl(3))
          CALL POPREAL8(esl(2))
          CALL POPREAL8(esl(1))
        ENDDO
        clbdy_diff(ib) = 0.D0
        cdbdy_diff(ib) = 0.D0
      ENDDO
      alfa_diff = COS(alfa)*sina_diff - SIN(alfa)*cosa_diff
      END

C  Differentiation of vinfab in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: vinf
C   with respect to varying inputs: alfa
C BDFORC
C
C
C
      SUBROUTINE VINFAB_B()
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
      REAL sina
      REAL sina_diff
      INTRINSIC SIN
      REAL cosa
      REAL cosa_diff
      INTRINSIC COS
      REAL sinb
      REAL cosb
C
      cosb = COS(beta)
C
C
C
C
      sina_diff = cosb*vinf_diff(3)
      vinf_diff(3) = 0.D0
      vinf_diff(2) = 0.D0
      cosa_diff = cosb*vinf_diff(1)
      alfa_diff = COS(alfa)*sina_diff - SIN(alfa)*cosa_diff
      END
C VINFAB

