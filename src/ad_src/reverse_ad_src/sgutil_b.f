C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 15 Jan 2021 14:26
C
C  Differentiation of akima in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: x y xx yy
C   with respect to varying inputs: x y xx
C***********************************************************************
C    Module:  sgutil.f
C 
C    Copyright (C) 2002 Mark Drela, Harold Youngren
C 
C    This program is free software; you can redistribute it and/or modify
C    it under the terms of the GNU General Public License as published by
C    the Free Software Foundation; either version 2 of the License, or
C    (at your option) any later version.
C
C    This program is distributed in the hope that it will be useful,
C    but WITHOUT ANY WARRANTY; without even the implied warranty of
C    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C    GNU General Public License for more details.
C
C    You should have received a copy of the GNU General Public License
C    along with this program; if not, write to the Free Software
C    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
C***********************************************************************
C
C
C
      SUBROUTINE AKIMA_B(x, x_diff, y, y_diff, n, xx, xx_diff, yy, 
     +                   yy_diff, slp)
      INTEGER n
      REAL d
      REAL d_diff
      REAL t
      REAL t_diff
      REAL x
      REAL y
C
C...PURPOSE    General-purpose monovariate interpolation routine
C              using a locally-fitted cubic spline. One point is
C              interpolated from the input data arrays.
C
C...INPUT:     X  An input array of abscissas in ascending or 
C                 descending value order.
C              Y  An input array of corresponding ordinates. The 
C                 function Y(X) must be single-valued.
C              N  Size for the 'X' and 'Y' arrays. 'N' is an integer.
C                 (the input arrays may be any size)
C
C             XX  Input 'X' point at which an interpolated 'Y' value is
C                 desired.
C
C...OUTPUT:   YY  Interpolated 'Y' ordinate.
C            SLP  Interpolated slope (DY/DX).
C
C...DISCUSSION This spline method produces an interpolated curve that
C              is relatively free of the oscillatory behavior normally
C              associated with cubic splines. The curve produced will
C              be continuous in 'Y' and 'DY/DX' but further derivatives
C              may be discontinuous. The interpolated slope should be
C              treated with some caution, however, due to the tendency
C              of this spline curve to concentrate changes of curvature
C              at the input points (interval ends). If only 2 points are
C              input the curve will be linear, if 3 points are given
C              the curve will be parabolic, more than 3 points will
C              produce a cubic. Extrapolation beyond the bounds of the
C              input data is done with a quadratic through the last 3
C              points at that data boundary.
C
C              This routine is intended as a replacement for B.Wainfan's
C              AKIMAD. It is shorter, twice as fast and it works on
C              input data in ascending or descending order. The calling
C              sequence is more natural and is easier to use for the
C              bulk of applications.
C
C              The coding is compatible with IBM or VAX Fortran 77 
C              and IBM Fortran IV G or H with optimization.
C
C...ORIGIN     Harold Youngren  CALAC Dept. 72-71   3/81
C
C...REFERENCE  Akima, Hiroshi, "A New Method of Interpolation and
C              Smooth Curve Fitting Based on Local Procedures",
C              Journal of the Association for Computing Machines,
C              Vol. 17, No. 4, Oct 1970, pages 589-602
C
C              Wainfan, B. S., "The Akima Subroutines:  Nonlinear
C              Interpolation by Local Polynomial Fit", LR 29244,
C              Oct 30, 1979.
C
C
      DIMENSION x(n), y(n), d(5), t(2)
      REAL x_diff
      REAL y_diff
      DIMENSION x_diff(n), y_diff(n), d_diff(5), t_diff(2)
      REAL xordr
      INTEGER ibot
      INTEGER itop
      REAL xxo
      INTEGER nstep
      INTEGER i
      REAL xo
      INTEGER j
      INTEGER k
      REAL a
      REAL a_diff
      INTRINSIC ABS
      REAL b
      REAL b_diff
      REAL xint
      REAL xint_diff
      REAL xdif
      REAL xdif_diff
      REAL p0
      REAL p0_diff
      REAL p1
      REAL p1_diff
      REAL p2
      REAL p2_diff
      REAL p3
      REAL p3_diff
      REAL temp_diff
      REAL temp_diff0
      INTEGER ii1
      INTEGER ad_count
      INTEGER i0
      INTEGER branch
      REAL xx
      REAL xx_diff
      REAL yy
      REAL yy_diff
      REAL slp
C 
C
C...Check for a degenerate case ( X(1)=X(N) ).    
C 
      IF (x(1) .NE. x(n)) THEN
C
C
C...Find which interval contains the point by binary search.
C...The binary search loop is terminated when the search residual
C...(NSTEP) is zero. The index 'I' will point to the input point
C...lower than or equal to the desired point for the 'X' values
C...in ascending order or to the input point greater than or equal
C...to the desired point for descending order 'X' values.       
C
        xordr = 1.0
        IF (x(1) .GT. x(n)) xordr = -1.0
C
        ibot = 1
        itop = n
        xxo = xx*xordr
        ad_count = 1
C
 20     nstep = (itop-ibot)/2
        i = ibot + nstep
        xo = x(i)*xordr
        IF (xxo .GE. xo) ibot = i
        IF (xxo .LT. xo) itop = i
        IF (nstep .NE. 0) THEN
          ad_count = ad_count + 1
          GOTO 20
        END IF
        CALL PUSHINTEGER4(ad_count)
C
C
C...Calculate the straight line slopes between adjacent input points.
C...D(3) is the slope on the interval of interpolation. If the other
C...slopes D(1), D(2), D(4) OR D(5) are not defined they will be
C...created by quadratic extrapolation (only at start and end of data).
C
        DO j=1,5
          k = i + (j-2)
          IF (k - 1 .GE. 1 .AND. k .LE. n) THEN
            d(j) = (y(k)-y(k-1))/(x(k)-x(k-1))
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
        ENDDO
C
C...Synthesize upper and lower slopes if required. Check for
C...single line segment input (N=2).
C
        IF (n .EQ. 2) THEN
          d(2) = d(3)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
C
        IF (i + 2 .GT. n) THEN
          d(4) = 2.*d(3) - d(2)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (i + 3 .GT. n) THEN
          d(5) = 2.*d(4) - d(3)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (i - 1 .LT. 1) THEN
          d(2) = 2.*d(3) - d(4)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (i - 2 .LT. 1) THEN
          d(1) = 2.*d(2) - d(3)
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
C
C
C...Calculate the slopes (T(1),T(2)) at the lower and upper
C...points bounding the interval of interpolation. If the point is
C...at an intersection of straight line segments the slope is
C...defined by the average of the adjacent segment slopes.
C
        DO j=1,2
          IF (d(j+3) - d(j+2) .GE. 0.) THEN
            CALL PUSHREAL8(a)
            a = d(j+3) - d(j+2)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHREAL8(a)
            a = -(d(j+3)-d(j+2))
            CALL PUSHCONTROL1B(1)
          END IF
          IF (d(j+1) - d(j) .GE. 0.) THEN
            CALL PUSHREAL8(b)
            b = d(j+1) - d(j)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHREAL8(b)
            b = -(d(j+1)-d(j))
            CALL PUSHCONTROL1B(1)
          END IF
          IF (a + b .NE. 0.) THEN
            CALL PUSHCONTROL1B(0)
          ELSE
            a = 1.
            b = 1.
            CALL PUSHCONTROL1B(1)
          END IF
          t(j) = (a*d(j+1)+b*d(j+2))/(a+b)
        ENDDO
C
C
C...Check if desired point is on upper point of interval. This
C...reduces error at the transition points between intervals.
C
        IF (xx .NE. x(i+1)) THEN
C
C...Calculate the cubic coefficients.
C
          xint = x(i+1) - x(i)
          xdif = xx - x(i)
          p1 = t(1)
          p2 = (3.*d(3)-2.*t(1)-t(2))/xint
          p3 = (t(1)+t(2)-2.*d(3))/(xint*xint)
C
C...Calculate the Y-value and the slope.
C
          temp_diff0 = xdif*yy_diff
          temp_diff = xdif*temp_diff0
          p0_diff = yy_diff
          xdif_diff = (p1+xdif*(p2+xdif*p3))*yy_diff + (p2+xdif*p3)*
     +      temp_diff0 + p3*temp_diff
          p1_diff = temp_diff0
          p2_diff = temp_diff
          p3_diff = xdif*temp_diff
          DO ii1=1,5
            d_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,2
            t_diff(ii1) = 0.D0
          ENDDO
          temp_diff0 = p3_diff/xint**2
          t_diff(1) = t_diff(1) + temp_diff0
          t_diff(2) = t_diff(2) + temp_diff0
          d_diff(3) = d_diff(3) - 2.*temp_diff0
          xint_diff = -(2*(t(1)+t(2)-2.*d(3))*temp_diff0/xint)
          temp_diff0 = p2_diff/xint
          d_diff(3) = d_diff(3) + 3.*temp_diff0
          t_diff(1) = t_diff(1) + p1_diff - 2.*temp_diff0
          t_diff(2) = t_diff(2) - temp_diff0
          xint_diff = xint_diff - (3.*d(3)-2.*t(1)-t(2))*temp_diff0/xint
          y_diff(i) = y_diff(i) + p0_diff
          xx_diff = xx_diff + xdif_diff
          x_diff(i) = x_diff(i) - xdif_diff - xint_diff
          x_diff(i+1) = x_diff(i+1) + xint_diff
        ELSE
          y_diff(i+1) = y_diff(i+1) + yy_diff
          DO ii1=1,5
            d_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,2
            t_diff(ii1) = 0.D0
          ENDDO
        END IF
        DO j=2,1,-1
          temp_diff0 = t_diff(j)/(a+b)
          t_diff(j) = 0.D0
          d_diff(j+1) = d_diff(j+1) + a*temp_diff0
          d_diff(j+2) = d_diff(j+2) + b*temp_diff0
          temp_diff = -((a*d(j+1)+b*d(j+2))*temp_diff0/(a+b))
          a_diff = d(j+1)*temp_diff0 + temp_diff
          b_diff = d(j+2)*temp_diff0 + temp_diff
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            a_diff = 0.D0
            b_diff = 0.D0
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(b)
            d_diff(j+1) = d_diff(j+1) + b_diff
            d_diff(j) = d_diff(j) - b_diff
          ELSE
            CALL POPREAL8(b)
            d_diff(j) = d_diff(j) + b_diff
            d_diff(j+1) = d_diff(j+1) - b_diff
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(a)
            d_diff(j+3) = d_diff(j+3) + a_diff
            d_diff(j+2) = d_diff(j+2) - a_diff
          ELSE
            CALL POPREAL8(a)
            d_diff(j+2) = d_diff(j+2) + a_diff
            d_diff(j+3) = d_diff(j+3) - a_diff
          END IF
        ENDDO
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          d_diff(2) = d_diff(2) + 2.*d_diff(1)
          d_diff(3) = d_diff(3) - d_diff(1)
          d_diff(1) = 0.D0
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          d_diff(3) = d_diff(3) + 2.*d_diff(2)
          d_diff(4) = d_diff(4) - d_diff(2)
          d_diff(2) = 0.D0
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          d_diff(4) = d_diff(4) + 2.*d_diff(5)
          d_diff(3) = d_diff(3) - d_diff(5)
          d_diff(5) = 0.D0
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          d_diff(3) = d_diff(3) + 2.*d_diff(4)
          d_diff(2) = d_diff(2) - d_diff(4)
          d_diff(4) = 0.D0
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          d_diff(3) = d_diff(3) + d_diff(2)
          d_diff(2) = 0.D0
        END IF
        DO j=5,1,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            k = i + (j-2)
            temp_diff = d_diff(j)/(x(k)-x(k-1))
            d_diff(j) = 0.D0
            y_diff(k) = y_diff(k) + temp_diff
            y_diff(k-1) = y_diff(k-1) - temp_diff
            temp_diff0 = -((y(k)-y(k-1))*temp_diff/(x(k)-x(k-1)))
            x_diff(k) = x_diff(k) + temp_diff0
            x_diff(k-1) = x_diff(k-1) - temp_diff0
          END IF
        ENDDO
        CALL POPINTEGER4(ad_count)
        i0 = ad_count + 1
      ELSE
        y_diff(1) = y_diff(1) + yy_diff
      END IF
      END

C  Differentiation of cspacer in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: xcp
C   with respect to varying inputs: xcp claf
C SPACER
C
C
C
      SUBROUTINE CSPACER_B(nvc, cspace, claf, claf_diff, xpt, xvr, xsr, 
     +                     xcp, xcp_diff)
      REAL xpt(*), xvr(*), xsr(*), xcp(*)
      REAL xcp_diff(*)
      REAL pi
      INTRINSIC ATAN
      REAL acsp
      INTRINSIC ABS
      INTEGER ncsp
      INTRINSIC INT
      REAL f0
      REAL f1
      REAL f2
      REAL dth1
      INTRINSIC FLOAT
      REAL dth2
      REAL dxc0
      INTEGER ivc
      REAL xc0
      REAL xpt0
      REAL xvr0
      REAL xsr0
      REAL xcp0
      REAL xcp0_diff
      REAL th1
      REAL xpt1
      INTRINSIC COS
      REAL xvr1
      REAL xsr1
      REAL xcp1
      REAL xcp1_diff
      REAL th2
      REAL xpt2
      REAL xvr2
      REAL xsr2
      REAL xcp2
      REAL xcp2_diff
      INTRINSIC SIN
      INTEGER branch
      REAL claf
      REAL claf_diff
      REAL cspace
      INTEGER nvc
C
      pi = 4.0*ATAN(1.0)
      IF (cspace .GE. 0.) THEN
        acsp = cspace
      ELSE
        acsp = -cspace
      END IF
      ncsp = INT(acsp)
      IF (ncsp .EQ. 0) THEN
        CALL PUSHCONTROL1B(0)
        f0 = 1.0 - acsp
        f1 = acsp
        f2 = 0.
      ELSE IF (ncsp .EQ. 1) THEN
        CALL PUSHCONTROL1B(1)
        f0 = 0.
        f1 = 2.0 - acsp
        f2 = acsp - 1.0
      ELSE
        CALL PUSHCONTROL1B(1)
        f0 = acsp - 2.0
        f1 = 0.
        f2 = 3.0 - acsp
      END IF
C
C---- cosine chordwise spacing
      dth1 = pi/FLOAT(4*nvc+2)
      dth2 = 0.5*pi/FLOAT(4*nvc+1)
      dxc0 = 1.0/FLOAT(4*nvc)
C
      DO ivc=1,nvc
C------ uniform
C
C------ cosine
        CALL PUSHREAL8(th1)
        th1 = INT(4*ivc-3)*dth1
C
        IF (cspace .GT. 0.0) THEN
C------- sine
          CALL PUSHREAL8(th2)
          th2 = INT(4*ivc-3)*dth2
          CALL PUSHCONTROL1B(0)
        ELSE
C------- -sine
          CALL PUSHREAL8(th2)
          th2 = INT(4*ivc-4)*dth2
          CALL PUSHCONTROL1B(1)
        END IF
      ENDDO
      claf_diff = 0.D0
      DO ivc=nvc,1,-1
        xcp0_diff = f0*xcp_diff(ivc)
        xcp1_diff = f1*xcp_diff(ivc)
        xcp2_diff = f2*xcp_diff(ivc)
        xcp_diff(ivc) = 0.D0
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          claf_diff = claf_diff + dth2*2.0*SIN(th2+dth2+dth2*2.0*claf)*
     +      xcp2_diff
          CALL POPREAL8(th2)
        ELSE
          claf_diff = claf_diff + dth2*2.0*COS(th2+dth2+dth2*2.0*claf)*
     +      xcp2_diff
          CALL POPREAL8(th2)
        END IF
        claf_diff = claf_diff + dth1*2.0*SIN(th1+dth1+dth1*2.0*claf)*0.5
     +    *xcp1_diff + dxc0*2.0*xcp0_diff
        CALL POPREAL8(th1)
      ENDDO
      CALL POPCONTROL1B(branch)
      END
C CSPACER
C

