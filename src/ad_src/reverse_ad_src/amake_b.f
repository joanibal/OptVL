C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 15 Jan 2021 14:26
C
C  Differentiation of update_surfaces in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: enc env
C   with respect to varying inputs: addinc enc env
C   RW status of diff variables: addinc:out enc:in-out env:in-out
C MAKESURF
      SUBROUTINE UPDATE_SURFACES_B()
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
      INTEGER isurf
      INTEGER ii1
      INTEGER branch
      nstrip = 0
      nvor = 0
      DO 100 isurf=1,nsurf
        IF (lverbose) WRITE(*, *) 'Updating surface ', isurf
        IF (isurf .NE. 1) THEN
          IF (ldupl(isurf-1)) THEN
            CALL PUSHCONTROL2B(0)
            GOTO 100
          ELSE
C this surface has already been created
            CALL PUSHREAL8ARRAY(sspaces, nsmax*nfmax)
            CALL PUSHREAL8ARRAY(sspace, nfmax)
            CALL PUSHINTEGER4ARRAY(nvs, nfmax)
            CALL PUSHINTEGER4(nstrip)
            CALL MAKESURF(isurf)
            CALL PUSHCONTROL1B(0)
          END IF
        ELSE
          CALL PUSHREAL8ARRAY(sspaces, nsmax*nfmax)
          CALL PUSHREAL8ARRAY(sspace, nfmax)
          CALL PUSHINTEGER4ARRAY(nvs, nfmax)
          CALL PUSHINTEGER4(nstrip)
          CALL MAKESURF(isurf)
          CALL PUSHCONTROL1B(1)
        END IF
        IF (ldupl(isurf)) THEN
          CALL PUSHINTEGER4ARRAY(nvs, nfmax)
          CALL PUSHINTEGER4ARRAY(nvc, nfmax)
          CALL PUSHINTEGER4ARRAY(jfrst, nfmax)
          CALL PUSHINTEGER4ARRAY(nk, nfmax)
          CALL PUSHINTEGER4ARRAY(nj, nfmax)
          CALL PUSHINTEGER4(nstrip)
          CALL PUSHINTEGER4(nvor)
          DO ii1=1,nfmax
            CALL PUSHCHARACTERARRAY(stitle(ii1), 40)
          ENDDO
          CALL SDUPL(isurf, ydupl(isurf), 'ydup')
          CALL PUSHCONTROL2B(2)
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
 100  CONTINUE
      CALL ENCALC_B()
      DO ii1=1,nfmax
        addinc_diff(ii1) = 0.D0
      ENDDO
      DO isurf=nsurf,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .NE. 1) THEN
            DO ii1=nfmax,1,-1
              CALL POPCHARACTERARRAY(stitle(ii1), 40)
            ENDDO
            CALL POPINTEGER4(nvor)
            CALL POPINTEGER4(nstrip)
            CALL POPINTEGER4ARRAY(nj, nfmax)
            CALL POPINTEGER4ARRAY(nk, nfmax)
            CALL POPINTEGER4ARRAY(jfrst, nfmax)
            CALL POPINTEGER4ARRAY(nvc, nfmax)
            CALL POPINTEGER4ARRAY(nvs, nfmax)
            CALL SDUPL_B(isurf, ydupl(isurf), 'ydup')
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPINTEGER4(nstrip)
            CALL POPINTEGER4ARRAY(nvs, nfmax)
            CALL POPREAL8ARRAY(sspace, nfmax)
            CALL POPREAL8ARRAY(sspaces, nsmax*nfmax)
            CALL MAKESURF_B(isurf)
          ELSE
            CALL POPINTEGER4(nstrip)
            CALL POPINTEGER4ARRAY(nvs, nfmax)
            CALL POPREAL8ARRAY(sspace, nfmax)
            CALL POPREAL8ARRAY(sspaces, nsmax*nfmax)
            CALL MAKESURF_B(isurf)
          END IF
        END IF
      ENDDO
      END

C  Differentiation of makesurf in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: addinc ainc ainc_g
C   with respect to varying inputs: addinc ainc ainc_g
C***********************************************************************
C    Module:  amake.f
C 
C    Copyright (C) 2002 Mark Drela, Harold Youngren
C 
C    This program is free software; you can redistribute it and/or modify
C    it under the terms of the GNU General Public License as published by
C    the Free Software Foundation; either version 2 of the License, or
C    (at your option) any later version.
C
C    This program is distributed in the hope that it will be useful,
C    but WITHOUT ANY WARRANTY; without even the implied warranty of
C    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C    GNU General Public License for more details.
C
C    You should have received a copy of the GNU General Public License
C    along with this program; if not, write to the Free Software
C    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
C***********************************************************************
C
      SUBROUTINE MAKESURF_B(isurf)
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
C
C
      REAL xyzlel(3), xyzler(3)
      INTEGER kcmax
      INTEGER ksmax
      PARAMETER (kcmax=50, ksmax=500)
      REAL xpt0(kcmax), xcp0(kcmax), xvr0(kcmax), xsr0(kcmax), xpt1(
     +     kcmax), xcp1(kcmax), xvr1(kcmax), xsr1(kcmax), xpt2(kcmax), 
     +     xcp2(kcmax), xvr2(kcmax), xsr2(kcmax)
      REAL xpt(kcmax), xcp(kcmax), xvr(kcmax), xsr(kcmax), ypt(ksmax), 
     +     ycp(ksmax)
      REAL yzlen(ksmax)
      INTEGER iptloc(ksmax)
      INTEGER kpmax
      PARAMETER (kpmax=2*kcmax+2*ksmax)
      REAL fspace(kpmax)
C
      REAL chsinl_g(ngmax), chcosl_g(ngmax), chsinr_g(ngmax), chcosr_g(
     +     ngmax)
      REAL chsinl_g_diff(ngmax), chcosl_g_diff(ngmax), chsinr_g_diff(
     +     ngmax), chcosr_g_diff(ngmax)
      INTEGER isconl(ndmax), isconr(ndmax)
      REAL xled(ndmax), xted(ndmax), gainda(ndmax)
      INTEGER isec
      REAL dy
      REAL dz
      INTRINSIC SQRT
      REAL dyzlen
      INTEGER nvint
      INTEGER nspace
      EXTERNAL SPACER
      INTEGER n
      INTEGER ivs
      INTEGER npt
      REAL yptloc
      INTEGER ipt
      REAL yptdel
      INTRINSIC ABS
      INTEGER ipt1
      INTEGER ipt2
      REAL ypt1
      REAL yscale
      REAL width
      REAL chordl
      REAL chordr
      REAL clafl
      REAL clafr
      REAL aincl
      REAL aincl_diff
      REAL aincr
      REAL aincr_diff
      REAL chsinl
      REAL chsinl_diff
      INTRINSIC SIN
      REAL chsinr
      REAL chsinr_diff
      REAL chcosl
      REAL chcosl_diff
      INTRINSIC COS
      REAL chcosr
      REAL chcosr_diff
      INTEGER iscon
      INTEGER isdes
      INTEGER iptl
      INTEGER iptr
      INTEGER nspan
      INTEGER ispan
      REAL f1
      REAL f2
      REAL fc
      REAL chsin
      REAL chsin_diff
      REAL chcos
      REAL chcos_diff
      INTRINSIC ATAN2
      REAL chsin_g
      REAL chsin_g_diff
      REAL chcos_g
      REAL chcos_g_diff
      INTEGER icl
      INTEGER icr
      REAL xhd
      REAL vhx
      REAL vhy
      REAL vhz
      REAL vsq
      REAL vmod
      INTEGER l
      INTEGER nsl
      INTEGER nsr
      REAL chordc
      REAL clafc
      EXTERNAL CSPACER
      INTEGER ivc
      REAL slopel
      REAL dsdx
      EXTERNAL AKIMA
      REAL sloper
      REAL dxoc
      REAL fracle
      REAL fracte
      INTRINSIC MAX
      INTRINSIC MIN
      REAL sum
      REAL wtot
      INTEGER jj
      INTEGER j
      REAL astrp
      INTEGER nst
      EXTERNAL STRIP
      REAL y1
      REAL y2
      REAL abs0
      REAL*(kind=avl_real) abs1
      REAL*(kind=avl_real) abs2
      REAL tmp
      REAL temp
      REAL temp_diff
      REAL temp_diff0
      INTEGER ad_count
      INTEGER i
      INTEGER branch
      INTEGER ii2
      INTEGER ii1
      INTEGER ad_to
      INTEGER ad_to0
      INTEGER ad_count0
      INTEGER i0
      INTEGER ad_to1
      INTEGER ad_to2
      INTEGER ad_to3
      INTEGER isurf
C
C
      IF (nsec(isurf) .LT. 2) THEN
        STOP
      ELSE
C
        IF (nvs(isurf) .GT. ksmax) nvs(isurf) = ksmax
C
C--- Image flag set to indicate section definition direction
C    IMAGS= 1  defines edge 1 located at surface root edge 
C    IMAGS=-1  defines edge 2 located at surface root edge (reflected surfaces)
C
C-----------------------------------------------------------------
C---- section arc lengths of wing trace in y-z plane
        yzlen(1) = 0.
        DO isec=2,nsec(isurf)
          dy = xyzles(2, isec, isurf) - xyzles(2, isec-1, isurf)
          dz = xyzles(3, isec, isurf) - xyzles(3, isec-1, isurf)
          yzlen(isec) = yzlen(isec-1) + SQRT(dy*dy + dz*dz)
        ENDDO
C
C
        IF (nvs(isurf) .EQ. 0) THEN
C----- set spanwise spacing using spacing parameters for each section interval
          DO isec=1,nsec(isurf)-1
            nvs(isurf) = nvs(isurf) + nspans(isec, isurf)
          ENDDO
          IF (nvs(isurf) .GT. ksmax) THEN
            STOP
          ELSE
C
            nvs(isurf) = 0
            ypt(1) = yzlen(1)
            iptloc(1) = 1
            CALL PUSHINTEGER4(isec)
            ad_count = 1
C
            DO isec=1,nsec(isurf)-1
              dyzlen = yzlen(isec+1) - yzlen(isec)
C
              nvint = nspans(isec, isurf)
C
C------- set spanwise spacing array
              nspace = 2*nvint + 1
              IF (nspace .GT. kpmax) THEN
                GOTO 100
              ELSE
                CALL SPACER(nspace, sspaces(isec, isurf), fspace)
C
                DO n=1,nvint
                  ivs = nvs(isurf) + n
                  ycp(ivs) = ypt(nvs(isurf)+1) + dyzlen*fspace(2*n)
                  tmp = ypt(nvs(isurf)+1) + dyzlen*fspace(2*n+1)
                  ypt(ivs+1) = tmp
                ENDDO
                iptloc(isec+1) = nvs(isurf) + nvint + 1
C
                nvs(isurf) = nvs(isurf) + nvint
                CALL PUSHINTEGER4(isec)
                ad_count = ad_count + 1
              END IF
            ENDDO
            CALL PUSHCONTROL1B(0)
            CALL PUSHINTEGER4(ad_count)
            CALL PUSHCONTROL1B(0)
            GOTO 130
 100        CALL PUSHCONTROL1B(1)
            CALL PUSHINTEGER4(ad_count)
            STOP
          END IF
        ELSE
C
C----- set spanwise spacing using overall parameters NVS(ISURF), SSPACE
C
          nspace = 2*nvs(isurf) + 1
          IF (nspace .GT. kpmax) THEN
            STOP
          ELSE
            CALL SPACER(nspace, sspace(isurf), fspace)
C
            ypt(1) = yzlen(1)
            DO ivs=1,nvs(isurf)
              ycp(ivs) = yzlen(1) + (yzlen(nsec(isurf))-yzlen(1))*fspace
     +          (2*ivs)
              ypt(ivs+1) = yzlen(1) + (yzlen(nsec(isurf))-yzlen(1))*
     +          fspace(2*ivs+1)
            ENDDO
C
            npt = nvs(isurf) + 1
C
C----- find node nearest each section
            DO isec=2,nsec(isurf)-1
              yptloc = 1.0e9
              iptloc(isec) = 1
              DO ipt=1,npt
                IF (yzlen(isec) - ypt(ipt) .GE. 0.) THEN
                  yptdel = yzlen(isec) - ypt(ipt)
                ELSE
                  yptdel = -(yzlen(isec)-ypt(ipt))
                END IF
                IF (yptdel .LT. yptloc) THEN
                  CALL PUSHCONTROL1B(1)
                  yptloc = yptdel
                  iptloc(isec) = ipt
                ELSE
                  CALL PUSHCONTROL1B(0)
                END IF
              ENDDO
              CALL PUSHINTEGER4(ipt - 1)
            ENDDO
            CALL PUSHINTEGER4(isec - 1)
            iptloc(1) = 1
            iptloc(nsec(isurf)) = npt
            ad_count0 = 1
C
C----- fudge Glauert angles to make nodes match up exactly with interior sections
            DO isec=2,nsec(isurf)-1
              ipt1 = iptloc(isec-1)
              ipt2 = iptloc(isec)
              IF (ipt1 .EQ. ipt2) THEN
                GOTO 110
              ELSE
C
                ypt1 = ypt(ipt1)
                yscale = (yzlen(isec)-yzlen(isec-1))/(ypt(ipt2)-ypt(ipt1
     +            ))
                DO ipt=ipt1,ipt2-1
                  ypt(ipt) = yzlen(isec-1) + yscale*(ypt(ipt)-ypt1)
                ENDDO
                DO ivs=ipt1,ipt2-1
                  ycp(ivs) = yzlen(isec-1) + yscale*(ycp(ivs)-ypt1)
                ENDDO
C
                ipt1 = iptloc(isec)
                ipt2 = iptloc(isec+1)
                IF (ipt1 .EQ. ipt2) THEN
                  GOTO 120
                ELSE
C
                  ypt1 = ypt(ipt1)
                  yscale = (ypt(ipt2)-yzlen(isec))/(ypt(ipt2)-ypt(ipt1))
                  DO ipt=ipt1,ipt2-1
                    ypt(ipt) = yzlen(isec) + yscale*(ypt(ipt)-ypt1)
                  ENDDO
                  DO ivs=ipt1,ipt2-1
                    ycp(ivs) = yzlen(isec) + yscale*(ycp(ivs)-ypt1)
                  ENDDO
                  ad_count0 = ad_count0 + 1
                END IF
              END IF
            ENDDO
            CALL PUSHCONTROL2B(0)
            CALL PUSHINTEGER4(ad_count0)
            CALL PUSHCONTROL1B(1)
            GOTO 130
 110        CALL PUSHCONTROL2B(1)
            CALL PUSHINTEGER4(ad_count0)
            STOP
 120        CALL PUSHCONTROL2B(2)
            CALL PUSHINTEGER4(ad_count0)
            STOP
          END IF
        END IF
C
C
C
C====================================================
C---- define strips between input sections
C
C
 130    IF (ncontrol .GT. ndmax) THEN
          STOP
        ELSE IF (ndesign .GT. ngmax) THEN
C
          STOP
        ELSE
C
C---- go over section intervals
          DO isec=1,nsec(isurf)-1
C
C
            chordl = xyzscal(1, isurf)*chords(isec, isurf)
            chordr = xyzscal(1, isurf)*chords(isec+1, isurf)
C
C
C------ removed CLAF influence on zero-lift angle  (MD  21 Mar 08)
            aincl = aincs(isec, isurf) + addinc(isurf)
            aincr = aincs(isec+1, isurf) + addinc(isurf)
Cc      AINCL = AINCS(ISEC)   + ADDINC(ISURF) - 4.0*DTR*(CLAFL-1.0)
Cc      AINCR = AINCS(ISEC+1) + ADDINC(ISURF) - 4.0*DTR*(CLAFR-1.0)
C
            chsinl = chordl*SIN(aincl)
            chsinr = chordr*SIN(aincr)
            chcosl = chordl*COS(aincl)
            chcosr = chordr*COS(aincr)
C
C------ set design-variable sensitivities of CHSIN and CHCOS
            DO n=1,ndesign
              chsinl_g(n) = 0.
              chsinr_g(n) = 0.
              chcosl_g(n) = 0.
              chcosr_g(n) = 0.
C
              DO isdes=1,nsdes(isec, isurf)
                IF (idestd(isdes, isec, isurf) .EQ. n) THEN
                  chsinl_g(n) = chcosl*gaing(isdes, isec, isurf)*dtr
                  chcosl_g(n) = -(chsinl*gaing(isdes, isec, isurf)*dtr)
                  CALL PUSHCONTROL1B(1)
                ELSE
                  CALL PUSHCONTROL1B(0)
                END IF
              ENDDO
              CALL PUSHINTEGER4(isdes - 1)
C
              DO isdes=1,nsdes(isec+1, isurf)
                IF (idestd(isdes, isec+1, isurf) .EQ. n) THEN
                  chsinr_g(n) = chcosr*gaing(isdes, isec+1, isurf)*dtr
                  chcosr_g(n) = -(chsinr*gaing(isdes, isec+1, isurf)*dtr
     +              )
                  CALL PUSHCONTROL1B(1)
                ELSE
                  CALL PUSHCONTROL1B(0)
                END IF
              ENDDO
              CALL PUSHINTEGER4(isdes - 1)
            ENDDO
C
C
C------ go over chord strips
            CALL PUSHINTEGER4(iptl)
            iptl = iptloc(isec)
            CALL PUSHINTEGER4(iptr)
            iptr = iptloc(isec+1)
            nspan = iptr - iptl
            DO ispan=1,nspan
C-------- define left and right edges of vortex strip
C-          note that incidence angle is set by ATAN of chord projections,
C-          not by linear interpolation of AINC
              ivs = iptl + ispan - 1
              CALL PUSHREAL8(fc)
              fc = (ycp(ivs)-ypt(iptl))/(ypt(iptr)-ypt(iptl))
C
C-------- store strip in global data arrays
              CALL PUSHINTEGER4(nstrip)
              nstrip = nstrip + 1
C
C
C
C
C
              CALL PUSHREAL8(chsin)
              chsin = chsinl + fc*(chsinr-chsinl)
              CALL PUSHREAL8(chcos)
              chcos = chcosl + fc*(chcosr-chcosl)
C
              DO n=1,ndesign
                CALL PUSHREAL8(chsin_g)
                chsin_g = (1.0-fc)*chsinl_g(n) + fc*chsinr_g(n)
                CALL PUSHREAL8(chcos_g)
                chcos_g = (1.0-fc)*chcosl_g(n) + fc*chcosr_g(n)
              ENDDO
            ENDDO
            CALL PUSHINTEGER4(ispan - 1)
          ENDDO
          DO ii1=1,ngmax
            chcosl_g_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ngmax
            chsinr_g_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ngmax
            chsinl_g_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ngmax
            chcosr_g_diff(ii1) = 0.D0
          ENDDO
          DO isec=nsec(isurf)-1,1,-1
            chsinl_diff = 0.D0
            chsinr_diff = 0.D0
            chcosl_diff = 0.D0
            chcosr_diff = 0.D0
            CALL POPINTEGER4(ad_to3)
            DO ispan=ad_to3,1,-1
              chsin_diff = 0.D0
              chcos_diff = 0.D0
              DO n=ndesign,1,-1
                temp = chsin*chsin + chcos*chcos
                temp_diff = ainc_g_diff(nstrip, n)/temp
                ainc_g_diff(nstrip, n) = 0.D0
                chsin_g_diff = chcos*temp_diff
                chcos_g_diff = -(chsin*temp_diff)
                temp_diff0 = -((chcos*chsin_g-chsin*chcos_g)*temp_diff/
     +            temp)
                chcos_diff = chcos_diff + chsin_g*temp_diff + 2*chcos*
     +            temp_diff0
                chsin_diff = chsin_diff + 2*chsin*temp_diff0 - chcos_g*
     +            temp_diff
                CALL POPREAL8(chcos_g)
                chcosl_g_diff(n) = chcosl_g_diff(n) + (1.0-fc)*
     +            chcos_g_diff
                chcosr_g_diff(n) = chcosr_g_diff(n) + fc*chcos_g_diff
                CALL POPREAL8(chsin_g)
                chsinl_g_diff(n) = chsinl_g_diff(n) + (1.0-fc)*
     +            chsin_g_diff
                chsinr_g_diff(n) = chsinr_g_diff(n) + fc*chsin_g_diff
              ENDDO
              chsin_diff = chsin_diff + chcos*ainc_diff(nstrip)/(chsin**
     +          2+chcos**2)
              chcos_diff = chcos_diff - chsin*ainc_diff(nstrip)/(chsin**
     +          2+chcos**2)
              ainc_diff(nstrip) = 0.D0
              CALL POPREAL8(chcos)
              chcosl_diff = chcosl_diff + (1.0-fc)*chcos_diff
              chcosr_diff = chcosr_diff + fc*chcos_diff
              CALL POPREAL8(chsin)
              chsinl_diff = chsinl_diff + (1.0-fc)*chsin_diff
              chsinr_diff = chsinr_diff + fc*chsin_diff
              CALL POPINTEGER4(nstrip)
              CALL POPREAL8(fc)
            ENDDO
            CALL POPINTEGER4(iptr)
            CALL POPINTEGER4(iptl)
            DO n=ndesign,1,-1
              CALL POPINTEGER4(ad_to2)
              DO isdes=ad_to2,1,-1
                CALL POPCONTROL1B(branch)
                IF (branch .NE. 0) THEN
                  chsinr_diff = chsinr_diff - dtr*gaing(isdes, isec+1, 
     +              isurf)*chcosr_g_diff(n)
                  chcosr_g_diff(n) = 0.D0
                  chcosr_diff = chcosr_diff + dtr*gaing(isdes, isec+1, 
     +              isurf)*chsinr_g_diff(n)
                  chsinr_g_diff(n) = 0.D0
                END IF
              ENDDO
              CALL POPINTEGER4(ad_to1)
              DO isdes=ad_to1,1,-1
                CALL POPCONTROL1B(branch)
                IF (branch .NE. 0) THEN
                  chsinl_diff = chsinl_diff - dtr*gaing(isdes, isec, 
     +              isurf)*chcosl_g_diff(n)
                  chcosl_g_diff(n) = 0.D0
                  chcosl_diff = chcosl_diff + dtr*gaing(isdes, isec, 
     +              isurf)*chsinl_g_diff(n)
                  chsinl_g_diff(n) = 0.D0
                END IF
              ENDDO
              chcosr_g_diff(n) = 0.D0
              chcosl_g_diff(n) = 0.D0
              chsinr_g_diff(n) = 0.D0
              chsinl_g_diff(n) = 0.D0
            ENDDO
            chordr = xyzscal(1, isurf)*chords(isec+1, isurf)
            aincr = aincs(isec+1, isurf) + addinc(isurf)
            aincr_diff = COS(aincr)*chordr*chsinr_diff - SIN(aincr)*
     +        chordr*chcosr_diff
            chordl = xyzscal(1, isurf)*chords(isec, isurf)
            aincl = aincs(isec, isurf) + addinc(isurf)
            aincl_diff = COS(aincl)*chordl*chsinl_diff - SIN(aincl)*
     +        chordl*chcosl_diff
            addinc_diff(isurf) = addinc_diff(isurf) + aincr_diff + 
     +        aincl_diff
          ENDDO
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPINTEGER4(ad_count)
            DO i=1,ad_count
              IF (i .EQ. 1) THEN
                CALL POPCONTROL1B(branch)
                IF (branch .NE. 0) THEN
                  DO ii1=1,nfmax
                    addinc_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nsmax
                    ainc_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,ngmax
                    DO ii2=1,nsmax
                      ainc_g_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                END IF
              END IF
              CALL POPINTEGER4(isec)
            ENDDO
          ELSE
            CALL POPINTEGER4(ad_count0)
            DO i0=1,ad_count0
              IF (i0 .EQ. 1) THEN
                CALL POPCONTROL2B(branch)
                IF (branch .NE. 0) THEN
                  IF (branch .EQ. 1) THEN
                    DO ii1=1,nfmax
                      addinc_diff(ii1) = 0.D0
                    ENDDO
                    DO ii1=1,nsmax
                      ainc_diff(ii1) = 0.D0
                    ENDDO
                    DO ii1=1,ngmax
                      DO ii2=1,nsmax
                        ainc_g_diff(ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ELSE
                    DO ii1=1,nfmax
                      addinc_diff(ii1) = 0.D0
                    ENDDO
                    DO ii1=1,nsmax
                      ainc_diff(ii1) = 0.D0
                    ENDDO
                    DO ii1=1,ngmax
                      DO ii2=1,nsmax
                        ainc_g_diff(ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  END IF
                END IF
              END IF
            ENDDO
            CALL POPINTEGER4(ad_to0)
            DO isec=ad_to0,2,-1
              CALL POPINTEGER4(ad_to)
              DO ipt=ad_to,1,-1
                CALL POPCONTROL1B(branch)
              ENDDO
            ENDDO
          END IF
        END IF
      END IF
C
 7000 FORMAT(/' *** Cannot adjust spanwise spacing at section',i3,
     +       ', on surface ',a/
     +      ' *** Insufficient number of spanwise vortices to work with'
     +      )
      END

C  Differentiation of sdupl in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: ainc ainc_g
C   with respect to varying inputs: ainc ainc_g
C MAKEBODY
C
C
C
C
      SUBROUTINE SDUPL_B(nn, ypt, msg)
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
      CHARACTER*(*) msg
      INTEGER nni
      INTEGER klen
      INTRINSIC LEN
      INTEGER k
      REAL yoff
      INTEGER ivs
      INTEGER jji
      INTEGER jj
      INTEGER n
      INTEGER l
      INTEGER ivc
      INTEGER iii
      INTEGER ii
      REAL rsgn
      REAL*(kind=avl_real) tmp
      REAL*(kind=avl_real) tmp0
      REAL*(kind=avl_real) tmp1
      REAL*(kind=avl_real) tmp2
      REAL*(kind=avl_real) tmp3
      REAL*(kind=avl_real) tmp4
      REAL*(kind=avl_real) tmp5
      REAL*(kind=avl_real) tmp6
      REAL*(kind=avl_real) tmp7
      REAL*(kind=avl_real) tmp_diff
      REAL*(kind=avl_real) tmp8
      REAL*(kind=avl_real) tmp_diff0
      REAL*(kind=avl_real) tmp9
      REAL*(kind=avl_real) tmp10
      REAL*(kind=avl_real) tmp11
      REAL*(kind=avl_real) tmp12
      REAL*(kind=avl_real) tmp13
      REAL*(kind=avl_real) tmp14
      REAL*(kind=avl_real) tmp15
      REAL*(kind=avl_real) tmp16
      REAL*(kind=avl_real) tmp17
      REAL*(kind=avl_real) tmp18
      REAL*(kind=avl_real) tmp19
      REAL*(kind=avl_real) tmp20
      REAL*(kind=avl_real) tmp21
      REAL*(kind=avl_real) tmp22
      REAL*(kind=avl_real) tmp23
      REAL*(kind=avl_real) tmp24
      REAL*(kind=avl_real) tmp25
      REAL*(kind=avl_real) tmp26
      REAL*(kind=avl_real) tmp27
      INTEGER ad_count
      INTEGER i
      INTEGER branch
      INTEGER ad_to
      INTEGER ad_count0
      INTEGER i0
      INTEGER ii2
      INTEGER ii1
      INTEGER nn
      REAL ypt
C
      nni = nsurf + 1
      IF (nni .GT. nfmax) THEN
        STOP
      ELSE
C
        klen = LEN(stitle(nn))
        ad_count = 1
        DO k=klen,1,-1
          IF (stitle(nn)(k:k) .NE. ' ') THEN
            GOTO 100
          ELSE
            ad_count = ad_count + 1
          END IF
        ENDDO
        CALL PUSHCONTROL1B(0)
        CALL PUSHINTEGER4(ad_count)
        CALL PUSHINTEGER4(ivs)
        CALL PUSHCONTROL1B(0)
        GOTO 110
 100    CALL PUSHCONTROL1B(1)
        CALL PUSHINTEGER4(ad_count)
        CALL PUSHINTEGER4(ivs)
        CALL PUSHCONTROL1B(0)
C
C---- duplicate surface is assumed to be the same logical component surface
C
C---- same various logical flags
C
C---- accumulate stuff for new image surface 
 110    jfrst(nni) = nstrip + 1
        nj(nni) = nj(nn)
        nk(nni) = nk(nn)
C
        nvc(nni) = nk(nni)
        nvs(nni) = nj(nni)
C
C--- Note hinge axis is flipped to reverse the Y component of the hinge
C    vector.   This means that deflections need to be reversed for image
C    surfaces.
C
C--- Image flag reversed (set to -IMAGS) for imaged surfaces
C
C
C--- Create image strips, to maintain the same sense of positive GAMMA
C    these have the 1 and 2 strip edges reversed (i.e. root is edge 2, 
C    not edge 1 as for a strip with IMAGS=1
        DO ivs=1,nvs(nni)
          nstrip = nstrip + 1
          IF (nstrip .GT. nsmax) THEN
            GOTO 130
          ELSE
C
            CALL PUSHINTEGER4(jji)
            jji = jfrst(nni) + ivs - 1
            CALL PUSHINTEGER4(jj)
            jj = jfrst(nn) + ivs - 1
C
C
            n = ndesign + 1
            CALL PUSHINTEGER4(n - 1)
            ad_count0 = 1
C
            DO ivc=1,nvc(nni)
              nvor = nvor + 1
              IF (nvor .GT. nvmax) THEN
                GOTO 140
              ELSE
                ad_count0 = ad_count0 + 1
              END IF
            ENDDO
            CALL PUSHCONTROL1B(0)
            CALL PUSHINTEGER4(ad_count0)
            CALL PUSHINTEGER4(ivs)
            CALL PUSHCONTROL1B(1)
          END IF
        ENDDO
 120    CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          CALL POPINTEGER4(ivs)
          CALL POPINTEGER4(ad_count0)
          DO i0=1,ad_count0
            IF (i0 .EQ. 1) THEN
              CALL POPCONTROL1B(branch)
              IF (branch .NE. 0) THEN
                DO ii1=1,nsmax
                  ainc_diff(ii1) = 0.D0
                ENDDO
                DO ii1=1,ngmax
                  DO ii2=1,nsmax
                    ainc_g_diff(ii2, ii1) = 0.D0
                  ENDDO
                ENDDO
              END IF
            END IF
          ENDDO
          CALL POPINTEGER4(ad_to)
          DO n=ad_to,1,-1
            tmp_diff0 = ainc_g_diff(jji, n)
            ainc_g_diff(jji, n) = 0.D0
            ainc_g_diff(jj, n) = ainc_g_diff(jj, n) + tmp_diff0
          ENDDO
          tmp_diff = ainc_diff(jji)
          ainc_diff(jji) = 0.D0
          ainc_diff(jj) = ainc_diff(jj) + tmp_diff
          CALL POPINTEGER4(jj)
          CALL POPINTEGER4(jji)
          GOTO 120
        END IF
        CALL POPINTEGER4(ivs)
        CALL POPINTEGER4(ad_count)
        DO i=1,ad_count
          IF (i .EQ. 1) CALL POPCONTROL1B(branch)
        ENDDO
        GOTO 150
 130    STOP
 140    CALL PUSHCONTROL1B(1)
        CALL PUSHINTEGER4(ad_count0)
        STOP
      END IF
 150  CONTINUE
      END

C  Differentiation of encalc in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: enc env
C   with respect to varying inputs: ainc ainc_g enc env
C BDUPL
C
C
C
C
      SUBROUTINE ENCALC_B()
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
C
      REAL ep(3), eq(3), es(3), eb(3), ec(3), ecxb(3)
      REAL eb_diff(3), ec_diff(3), ecxb_diff(3)
      REAL ec_g(3, ndmax), ecxb_g(3)
      INTEGER j
      INTEGER i
      REAL dxle
      REAL dyle
      REAL dzle
      REAL axle
      REAL ayle
      REAL azle
      REAL dxte
      REAL dyte
      REAL dzte
      REAL axte
      REAL ayte
      REAL azte
      REAL dxt
      REAL dyt
      REAL dzt
      INTRINSIC SQRT
      INTEGER nv
      INTEGER ii
      INTEGER n
      REAL dxb
      REAL dyb
      REAL dzb
      REAL emag
      REAL emag_diff
      REAL ang
      REAL ang_diff
      INTRINSIC ATAN
      REAL sinc
      REAL sinc_diff
      INTRINSIC SIN
      REAL cosc
      REAL cosc_diff
      INTRINSIC COS
      REAL emag_g
      REAL ang_ddc
      REAL cosd
      REAL sind
      REAL endot
      REAL DOT
      INTEGER ii1
      REAL temp_diff
      INTEGER branch
      INTEGER ad_to
      INTEGER ii2
C
C...Calculate the normal vector at control points and bound vortex midpoints
C
      DO j=1,nstrip
C
C...Calculate normal vector for the strip (normal to X axis)
        CALL PUSHINTEGER4(i)
        i = ijfrst(j)
        dyle = rv2(2, i) - rv1(2, i)
        dzle = rv2(3, i) - rv1(3, i)
C       AXLE = (RV2(1,I)+RV1(1,I))*0.5
C       AYLE = (RV2(2,I)+RV1(2,I))*0.5
C       AZLE = (RV2(3,I)+RV1(3,I))*0.5
C
        i = ijfrst(j) + (nvstrp(j)-1)
        dyte = rv2(2, i) - rv1(2, i)
        dzte = rv2(3, i) - rv1(3, i)
C       AXTE = (RV2(1,I)+RV1(1,I))*0.5
C       AYTE = (RV2(2,I)+RV1(2,I))*0.5
C       AZTE = (RV2(3,I)+RV1(3,I))*0.5
C
        dyt = (1.0-saxfr)*dyle + saxfr*dyte
        dzt = (1.0-saxfr)*dzle + saxfr*dzte
C
C
        ensy(j) = -(dzt/SQRT(dyt*dyt+dzt*dzt))
        ensz(j) = dyt/SQRT(dyt*dyt+dzt*dzt)
C
C
C
        CALL PUSHREAL8(es(1))
        es(1) = 0.
        CALL PUSHREAL8(es(2))
        es(2) = ensy(j)
        CALL PUSHREAL8(es(3))
        es(3) = ensz(j)
C
C
        nv = nvstrp(j)
        DO ii=1,nv
C
          CALL PUSHINTEGER4(i)
          i = ijfrst(j) + (ii-1)
C
C...Define unit vector along bound leg
          dxb = rv2(1, i) - rv1(1, i)
          dyb = rv2(2, i) - rv1(2, i)
          dzb = rv2(3, i) - rv1(3, i)
          CALL PUSHREAL8(emag)
          emag = SQRT(dxb**2 + dyb**2 + dzb**2)
          CALL PUSHREAL8(eb(1))
          eb(1) = dxb/emag
          CALL PUSHREAL8(eb(2))
          eb(2) = dyb/emag
          CALL PUSHREAL8(eb(3))
          eb(3) = dzb/emag
C
C...Define direction of normal vector at control point 
C   The YZ projection of the normal vector matches the camber slope
C   + section local incidence in the YZ defining plane for the section
          CALL PUSHREAL8(ang)
          ang = ainc(j) - ATAN(slopec(i))
Cc          IF(LDES) THEN
C--------- add design-variable contribution to angle
          DO n=1,ndesign
            ang = ang + ainc_g(j, n)*deldes(n)
          ENDDO
Cc          ENDIF
C
          sinc = SIN(ang)
          cosc = COS(ang)
          CALL PUSHREAL8(ec(1))
          ec(1) = cosc
          CALL PUSHREAL8(ec(2))
          ec(2) = -(sinc*es(2))
          CALL PUSHREAL8(ec(3))
          ec(3) = -(sinc*es(3))
C
C...Normal vector is perpendicular to camberline vector and to the bound leg
          CALL PUSHREAL8ARRAY(ecxb, 3)
          CALL CROSS(ec, eb, ecxb)
          emag = SQRT(ecxb(1)**2 + ecxb(2)**2 + ecxb(3)**2)
          IF (emag .NE. 0.0) THEN
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
C
C
C...Define direction of normal vector at vortex mid-point. 
C   The YZ projection of the normal vector matches the camber slope
C   + section local incidence in the YZ defining plane for the section
          CALL PUSHREAL8(ang)
          ang = ainc(j) - ATAN(slopev(i))
Cc          IF(LDES) THEN
C--------- add design-variable contribution to angle
          DO n=1,ndesign
            ang = ang + ainc_g(j, n)*deldes(n)
          ENDDO
Cc          ENDIF
C
          sinc = SIN(ang)
          cosc = COS(ang)
          CALL PUSHREAL8(ec(1))
          ec(1) = cosc
          CALL PUSHREAL8(ec(2))
          ec(2) = -(sinc*es(2))
          CALL PUSHREAL8(ec(3))
          ec(3) = -(sinc*es(3))
C
C...Normal vector is perpendicular to camberline vector and to the bound leg
          CALL PUSHREAL8ARRAY(ecxb, 3)
          CALL CROSS(ec, eb, ecxb)
          CALL PUSHREAL8(emag)
          emag = SQRT(ecxb(1)**2 + ecxb(2)**2 + ecxb(3)**2)
          IF (emag .NE. 0.0) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        ENDDO
        CALL PUSHINTEGER4(ii - 1)
      ENDDO
      DO ii1=1,nsmax
        ainc_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,ngmax
        DO ii2=1,nsmax
          ainc_g_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,3
        ec_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        ecxb_diff(ii1) = 0.D0
      ENDDO
      DO j=nstrip,1,-1
        CALL POPINTEGER4(ad_to)
        DO ii=ad_to,1,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            env_diff(3, i) = 0.D0
            env_diff(2, i) = 0.D0
            env_diff(1, i) = 0.D0
            emag_diff = 0.D0
          ELSE
            ecxb_diff(3) = ecxb_diff(3) + env_diff(3, i)/emag
            emag_diff = -(ecxb(3)*env_diff(3, i)/emag**2) - ecxb(2)*
     +        env_diff(2, i)/emag**2 - ecxb(1)*env_diff(1, i)/emag**2
            env_diff(3, i) = 0.D0
            ecxb_diff(2) = ecxb_diff(2) + env_diff(2, i)/emag
            env_diff(2, i) = 0.D0
            ecxb_diff(1) = ecxb_diff(1) + env_diff(1, i)/emag
            env_diff(1, i) = 0.D0
          END IF
          CALL POPREAL8(emag)
          IF (ecxb(1)**2 + ecxb(2)**2 + ecxb(3)**2 .EQ. 0.D0) THEN
            temp_diff = 0.D0
          ELSE
            temp_diff = emag_diff/(2.0*SQRT(ecxb(1)**2+ecxb(2)**2+ecxb(3
     +        )**2))
          END IF
          ecxb_diff(1) = ecxb_diff(1) + 2*ecxb(1)*temp_diff
          ecxb_diff(2) = ecxb_diff(2) + 2*ecxb(2)*temp_diff
          ecxb_diff(3) = ecxb_diff(3) + 2*ecxb(3)*temp_diff
          CALL POPREAL8ARRAY(ecxb, 3)
          DO ii1=1,3
            eb_diff(ii1) = 0.D0
          ENDDO
          CALL CROSS_B(ec, ec_diff, eb, eb_diff, ecxb, ecxb_diff)
          CALL POPREAL8(ec(3))
          sinc_diff = -(es(3)*ec_diff(3)) - es(2)*ec_diff(2)
          ec_diff(3) = 0.D0
          CALL POPREAL8(ec(2))
          ec_diff(2) = 0.D0
          CALL POPREAL8(ec(1))
          cosc_diff = ec_diff(1)
          ec_diff(1) = 0.D0
          ang_diff = COS(ang)*sinc_diff - SIN(ang)*cosc_diff
          DO n=ndesign,1,-1
            ainc_g_diff(j, n) = ainc_g_diff(j, n) + deldes(n)*ang_diff
          ENDDO
          CALL POPREAL8(ang)
          ainc_diff(j) = ainc_diff(j) + ang_diff
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            ecxb_diff(3) = ecxb_diff(3) + enc_diff(3, i)/emag
            emag_diff = -(ecxb(3)*enc_diff(3, i)/emag**2) - ecxb(2)*
     +        enc_diff(2, i)/emag**2 - ecxb(1)*enc_diff(1, i)/emag**2
            enc_diff(3, i) = 0.D0
            ecxb_diff(2) = ecxb_diff(2) + enc_diff(2, i)/emag
            enc_diff(2, i) = 0.D0
            ecxb_diff(1) = ecxb_diff(1) + enc_diff(1, i)/emag
            enc_diff(1, i) = 0.D0
          ELSE
            enc_diff(3, i) = 0.D0
            enc_diff(2, i) = 0.D0
            enc_diff(1, i) = 0.D0
            emag_diff = 0.D0
          END IF
          IF (ecxb(1)**2 + ecxb(2)**2 + ecxb(3)**2 .EQ. 0.D0) THEN
            temp_diff = 0.D0
          ELSE
            temp_diff = emag_diff/(2.0*SQRT(ecxb(1)**2+ecxb(2)**2+ecxb(3
     +        )**2))
          END IF
          ecxb_diff(1) = ecxb_diff(1) + 2*ecxb(1)*temp_diff
          ecxb_diff(2) = ecxb_diff(2) + 2*ecxb(2)*temp_diff
          ecxb_diff(3) = ecxb_diff(3) + 2*ecxb(3)*temp_diff
          CALL POPREAL8ARRAY(ecxb, 3)
          DO ii1=1,3
            eb_diff(ii1) = 0.D0
          ENDDO
          CALL CROSS_B(ec, ec_diff, eb, eb_diff, ecxb, ecxb_diff)
          CALL POPREAL8(ec(3))
          sinc_diff = -(es(3)*ec_diff(3)) - es(2)*ec_diff(2)
          ec_diff(3) = 0.D0
          CALL POPREAL8(ec(2))
          ec_diff(2) = 0.D0
          CALL POPREAL8(ec(1))
          cosc_diff = ec_diff(1)
          ec_diff(1) = 0.D0
          ang_diff = COS(ang)*sinc_diff - SIN(ang)*cosc_diff
          DO n=ndesign,1,-1
            ainc_g_diff(j, n) = ainc_g_diff(j, n) + deldes(n)*ang_diff
          ENDDO
          CALL POPREAL8(ang)
          ainc_diff(j) = ainc_diff(j) + ang_diff
          CALL POPREAL8(eb(3))
          CALL POPREAL8(eb(2))
          CALL POPREAL8(eb(1))
          CALL POPREAL8(emag)
          CALL POPINTEGER4(i)
        ENDDO
        CALL POPREAL8(es(3))
        CALL POPREAL8(es(2))
        CALL POPREAL8(es(1))
        CALL POPINTEGER4(i)
      ENDDO
      END
C ENCALC
C

