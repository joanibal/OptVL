C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 15 Jan 2021 14:26
C
C  Differentiation of vvor in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: chordv rc rv1 rv2 zsym ysym
C                wc_gam
C   with respect to varying inputs: chordv rc rv1 rv2 zsym betm
C                ysym wc_gam
C***********************************************************************
C    Module:  aic.f
C 
C    Copyright (C) 2002 Mark Drela, Harold Youngren
C 
C    This program is free software; you can redistribute it and/or modify
C    it under the terms of the GNU General Public License as published by
C    the Free Software Foundation; either version 2 of the License, or
C    (at your option) any later version.
C
C    This program is distributed in the hope that it will be useful,
C    but WITHOUT ANY WARRANTY; without even the implied warranty of
C    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C    GNU General Public License for more details.
C
C    You should have received a copy of the GNU General Public License
C    along with this program; if not, write to the Free Software
C    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
C***********************************************************************
C
C
      SUBROUTINE VVOR_B(betm, betm_diff, iysym, ysym, ysym_diff, izsym, 
     +                  zsym, zsym_diff, vrcorec, vrcorew, nv, rv1, 
     +                  rv1_diff, rv2, rv2_diff, ncompv, chordv, 
     +                  chordv_diff, nc, rc, rc_diff, ncompc, lvtest, 
     +                  wc_gam, wc_gam_diff, ncdim)
      INCLUDE 'AVL_kinds.INC'
      INTEGER nv
C
      REAL(kind=avl_real) rv1(3, nv), rv2(3, nv), chordv(nv)
      REAL(kind=avl_real) rv1_diff(3, nv), rv2_diff(3, nv), chordv_diff
     +                     (nv)
      INTEGER nc
      INTEGER ncdim
      REAL(kind=avl_real) rc(3, nc), wc_gam(3, ncdim, ncdim)
      REAL(kind=avl_real) rc_diff(3, nc), wc_gam_diff(3, ncdim, ncdim)
      INTEGER ncompv(nv), ncompc(nc)
      LOGICAL lvtest
C     
      LOGICAL lbound
      REAL fysym
      INTRINSIC FLOAT
      REAL fzsym
      INTEGER i
      REAL x
      REAL x_diff
      REAL y
      REAL y_diff
      REAL z
      REAL z_diff
      REAL u
      REAL u_diff
      REAL v
      REAL v_diff
      REAL w
      REAL w_diff
      INTEGER j
      REAL dsyz
      REAL dsyz_diff
      INTRINSIC SQRT
      REAL rcore
      REAL rcore_diff
      INTRINSIC MAX
      REAL ui
      REAL ui_diff
      REAL vi
      REAL vi_diff
      REAL wi
      REAL wi_diff
      REAL yoff
      REAL yoff_diff
      REAL zoff
      REAL zoff_diff
      REAL xave
      REAL yave
      REAL zave
      REAL uii
      REAL uii_diff
      REAL vii
      REAL vii_diff
      REAL wii
      REAL wii_diff
      REAL us
      REAL us_diff
      REAL vs
      REAL vs_diff
      REAL ws
      REAL ws_diff
      REAL(kind=8) arg1
      REAL(kind=8) arg1_diff
      REAL(kind=8) arg2
      REAL(kind=8) arg2_diff
      REAL(kind=8) arg3
      REAL(kind=8) arg3_diff
      REAL(kind=8) arg4
      REAL(kind=8) arg4_diff
      REAL(kind=avl_real) temp
      REAL(kind=avl_real) temp0
      REAL(kind=avl_real) temp_diff
      REAL(kind=avl_real) temp_diff0
      REAL(kind=avl_real) temp_diff1
      INTEGER branch
      REAL vrcorec
      REAL vrcorew
      REAL zsym
      REAL zsym_diff
      INTEGER izsym
      REAL betm
      REAL betm_diff
      REAL ysym
      REAL ysym_diff
      INTEGER iysym
C     
C     
      fysym = FLOAT(iysym)
      fzsym = FLOAT(izsym)
      betm_diff = 0.D0
C$BWD-OF II-LOOP 
      DO i=1,nc
C...  Control point location
        x = rc(1, i)
        y = rc(2, i)
        z = rc(3, i)
C     
        x_diff = 0.D0
        y_diff = 0.D0
        z_diff = 0.D0
C$BWD-OF II-LOOP 
        DO j=1,nv
C--------- set vortex core
          dsyz = SQRT((rv2(2, j)-rv1(2, j))**2 + (rv2(3, j)-rv1(3, j))**
     +      2)
C---- default (non-zero) core size based on spanwise lattice spacing
          rcore = 0.0001*dsyz
C---- if field point is not on same component use larger core size
          IF (nc .EQ. nv) THEN
            IF (ncompc(i) .NE. ncompv(j)) THEN
              IF (vrcorec*chordv(j) .LT. vrcorew*dsyz) THEN
                rcore = vrcorew*dsyz
                CALL PUSHCONTROL2B(3)
              ELSE
                rcore = vrcorec*chordv(j)
                CALL PUSHCONTROL2B(2)
              END IF
            ELSE
              CALL PUSHCONTROL2B(0)
            END IF
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
C     
C     
          yoff = 2.0*ysym
          zoff = 2.0*zsym
CCC   ZOFF = 2.0*(ZSYM + ALFA*0.5*(RV1(1,J)+RV2(1,J)) )
C     
C...  Calculate the influence of the REAL vortex
C
C     
          IF (iysym .NE. 0) THEN
C...  Calculate the influence of the y-IMAGE vortex
            lbound = .true.
C...  For sym/asym matrices check for vortex midpoints of image vortices
            IF (iysym .EQ. 1) THEN
              xave = 0.5*(rv1(1, j)+rv2(1, j))
              yave = yoff - 0.5*(rv1(2, j)+rv2(2, j))
              zave = 0.5*(rv1(3, j)+rv2(3, j))
              IF (x .EQ. xave .AND. y .EQ. yave .AND. z .EQ. zave) THEN
                CALL PUSHCONTROL1B(0)
                lbound = .false.
              ELSE
                CALL PUSHCONTROL1B(0)
              END IF
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
C     
          IF (izsym .NE. 0) THEN
C...  Calculate the influence of the z-IMAGE vortex
            CALL PUSHBOOLEAN(lbound)
C     
C...  Calculate the influence of the y,z-IMAGE vortex
            IF (iysym .NE. 0) THEN
              lbound = .true.
              arg1 = yoff - rv1(2, j)
              arg2 = zoff - rv1(3, j)
              arg3 = yoff - rv2(2, j)
              arg4 = zoff - rv2(3, j)
C     
              CALL PUSHCONTROL2B(0)
            ELSE
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B(2)
          END IF
          ws_diff = wc_gam_diff(3, i, j)
          wc_gam_diff(3, i, j) = 0.D0
          vs_diff = wc_gam_diff(2, i, j)
          wc_gam_diff(2, i, j) = 0.D0
          us_diff = wc_gam_diff(1, i, j)
          wc_gam_diff(1, i, j) = 0.D0
          w_diff = ws_diff
          wi_diff = ws_diff
          v_diff = vs_diff
          vi_diff = vs_diff
          u_diff = us_diff
          ui_diff = us_diff
          CALL POPCONTROL2B(branch)
          IF (branch .EQ. 0) THEN
            wii_diff = fysym*fzsym*wi_diff
            vii_diff = fysym*fzsym*vi_diff
            uii_diff = fysym*fzsym*ui_diff
            arg1_diff = 0.D0
            arg2_diff = 0.D0
            arg3_diff = 0.D0
            arg4_diff = 0.D0
            rcore_diff = 0.D0
            CALL VORVELC_B(x, x_diff, y, y_diff, z, z_diff, lbound, rv1(
     +                     1, j), rv1_diff(1, j), arg1, arg1_diff, arg2
     +                     , arg2_diff, rv2(1, j), rv2_diff(1, j), arg3
     +                     , arg3_diff, arg4, arg4_diff, betm, betm_diff
     +                     , uii, uii_diff, vii, vii_diff, wii, wii_diff
     +                     , rcore, rcore_diff)
            zoff_diff = arg4_diff + arg2_diff
            rv2_diff(3, j) = rv2_diff(3, j) - arg4_diff
            yoff_diff = arg3_diff + arg1_diff
            rv2_diff(2, j) = rv2_diff(2, j) - arg3_diff
            rv1_diff(3, j) = rv1_diff(3, j) - arg2_diff
            rv1_diff(2, j) = rv1_diff(2, j) - arg1_diff
          ELSE IF (branch .EQ. 1) THEN
            rcore_diff = 0.D0
            zoff_diff = 0.D0
            yoff_diff = 0.D0
          ELSE
            rcore_diff = 0.D0
            zoff_diff = 0.D0
            yoff_diff = 0.D0
            GOTO 100
          END IF
          wii_diff = fzsym*w_diff
          vii_diff = fzsym*v_diff
          uii_diff = fzsym*u_diff
          lbound = .true.
          arg1 = zoff - rv2(3, j)
          arg2 = zoff - rv1(3, j)
          arg1_diff = 0.D0
          arg2_diff = 0.D0
          CALL VORVELC_B(x, x_diff, y, y_diff, z, z_diff, lbound, rv2(1
     +                   , j), rv2_diff(1, j), rv2(2, j), rv2_diff(2, j)
     +                   , arg1, arg1_diff, rv1(1, j), rv1_diff(1, j), 
     +                   rv1(2, j), rv1_diff(2, j), arg2, arg2_diff, 
     +                   betm, betm_diff, uii, uii_diff, vii, vii_diff, 
     +                   wii, wii_diff, rcore, rcore_diff)
          zoff_diff = zoff_diff + arg2_diff + arg1_diff
          rv1_diff(3, j) = rv1_diff(3, j) - arg2_diff
          rv2_diff(3, j) = rv2_diff(3, j) - arg1_diff
          CALL POPBOOLEAN(lbound)
 100      CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            wi_diff = fysym*wi_diff
            vi_diff = fysym*vi_diff
            ui_diff = fysym*ui_diff
            arg1 = yoff - rv2(2, j)
            arg2 = yoff - rv1(2, j)
            arg1_diff = 0.D0
            arg2_diff = 0.D0
            CALL VORVELC_B(x, x_diff, y, y_diff, z, z_diff, lbound, rv2(
     +                     1, j), rv2_diff(1, j), arg1, arg1_diff, rv2(3
     +                     , j), rv2_diff(3, j), rv1(1, j), rv1_diff(1, 
     +                     j), arg2, arg2_diff, rv1(3, j), rv1_diff(3, j
     +                     ), betm, betm_diff, ui, ui_diff, vi, vi_diff
     +                     , wi, wi_diff, rcore, rcore_diff)
            yoff_diff = yoff_diff + arg2_diff + arg1_diff
            rv1_diff(2, j) = rv1_diff(2, j) - arg2_diff
            rv2_diff(2, j) = rv2_diff(2, j) - arg1_diff
            CALL POPCONTROL1B(branch)
          END IF
          lbound = .NOT.(lvtest .AND. i .EQ. j)
          CALL VORVELC_B(x, x_diff, y, y_diff, z, z_diff, lbound, rv1(1
     +                   , j), rv1_diff(1, j), rv1(2, j), rv1_diff(2, j)
     +                   , rv1(3, j), rv1_diff(3, j), rv2(1, j), 
     +                   rv2_diff(1, j), rv2(2, j), rv2_diff(2, j), rv2(
     +                   3, j), rv2_diff(3, j), betm, betm_diff, u, 
     +                   u_diff, v, v_diff, w, w_diff, rcore, rcore_diff
     +                  )
          zsym_diff = zsym_diff + 2.0*zoff_diff
          ysym_diff = ysym_diff + 2.0*yoff_diff
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              dsyz_diff = 0.D0
            ELSE
              dsyz_diff = 0.D0
            END IF
          ELSE
            IF (branch .EQ. 2) THEN
              chordv_diff(j) = chordv_diff(j) + vrcorec*rcore_diff
              dsyz_diff = 0.D0
            ELSE
              dsyz_diff = vrcorew*rcore_diff
            END IF
            rcore_diff = 0.D0
          END IF
          dsyz_diff = dsyz_diff + 0.0001*rcore_diff
          temp = rv2(3, j) - rv1(3, j)
          temp0 = rv2(2, j) - rv1(2, j)
          IF (temp0**2 + temp**2 .EQ. 0.D0) THEN
            temp_diff = 0.D0
          ELSE
            temp_diff = dsyz_diff/(2.0*SQRT(temp0**2+temp**2))
          END IF
          temp_diff0 = 2*temp0*temp_diff
          temp_diff1 = 2*temp*temp_diff
          rv2_diff(3, j) = rv2_diff(3, j) + temp_diff1
          rv1_diff(3, j) = rv1_diff(3, j) - temp_diff1
          rv2_diff(2, j) = rv2_diff(2, j) + temp_diff0
          rv1_diff(2, j) = rv1_diff(2, j) - temp_diff0
        ENDDO
        rc_diff(3, i) = rc_diff(3, i) + z_diff
        rc_diff(2, i) = rc_diff(2, i) + y_diff
        rc_diff(1, i) = rc_diff(1, i) + x_diff
      ENDDO
      END

C  Differentiation of cross in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: u v w
C   with respect to varying inputs: u v w
C SRDSET
C
      SUBROUTINE CROSS_B(u, u_diff, v, v_diff, w, w_diff)
      REAL u(3), v(3), w(3)
      REAL u_diff(3), v_diff(3), w_diff(3)
      u_diff(1) = u_diff(1) + v(2)*w_diff(3) - v(3)*w_diff(2)
      v_diff(2) = v_diff(2) + u(1)*w_diff(3) - u(3)*w_diff(1)
      u_diff(2) = u_diff(2) + v(3)*w_diff(1) - v(1)*w_diff(3)
      v_diff(1) = v_diff(1) + u(3)*w_diff(2) - u(2)*w_diff(3)
      w_diff(3) = 0.D0
      u_diff(3) = u_diff(3) + v(1)*w_diff(2) - v(2)*w_diff(1)
      v_diff(3) = v_diff(3) + u(2)*w_diff(1) - u(1)*w_diff(2)
      w_diff(2) = 0.D0
      w_diff(1) = 0.D0
      END

C  Differentiation of dot in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: u v dot
C   with respect to varying inputs: u v
C
C
      SUBROUTINE DOT_B(u, u_diff, v, v_diff, dot_diff)
      REAL u(3), v(3)
      REAL u_diff(3), v_diff(3)
      REAL dot
      REAL dot_diff
      u_diff(1) = u_diff(1) + v(1)*dot_diff
      v_diff(1) = v_diff(1) + u(1)*dot_diff
      u_diff(2) = u_diff(2) + v(2)*dot_diff
      v_diff(2) = v_diff(2) + u(2)*dot_diff
      u_diff(3) = u_diff(3) + v(3)*dot_diff
      v_diff(3) = v_diff(3) + u(3)*dot_diff
      END

C  Differentiation of vorvelc in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: y1 y2 rcore u v w x y z z1
C                z2 x1 x2 beta
C   with respect to varying inputs: y1 y2 rcore x y z z1 z2 x1
C                x2 beta
C
C
      SUBROUTINE VORVELC_B(x, x_diff, y, y_diff, z, z_diff, lbound, x1, 
     +                     x1_diff, y1, y1_diff, z1, z1_diff, x2, 
     +                     x2_diff, y2, y2_diff, z2, z2_diff, beta, 
     +                     beta_diff, u, u_diff, v, v_diff, w, w_diff, 
     +                     rcore, rcore_diff)
C----------------------------------------------------------
C     Same as VORVEL, with finite core radius
C     Original Scully (AKA Burnham-Hallock) core model 
C       Vtan = Gam/2*pi . r/(r^2 +rcore^2)
C      
C     Uses Leishman's R^4 variant of Scully (AKA Burnham-Hallock) core model 
C       Vtan = Gam/2*pi . r/sqrt(r^4 +rcore^4)
C----------------------------------------------------------
      LOGICAL lbound
C
C
      REAL a(3), b(3), axb(3)
      REAL a_diff(3), b_diff(3), axb_diff(3)
      REAL asq
      REAL asq_diff
      REAL bsq
      REAL bsq_diff
      REAL amag
      REAL amag_diff
      INTRINSIC SQRT
      REAL bmag
      REAL bmag_diff
      REAL rcore2
      REAL rcore2_diff
      REAL rcore4
      REAL rcore4_diff
      REAL axbsq
      REAL axbsq_diff
      REAL adb
      REAL adb_diff
      REAL alsq
      REAL alsq_diff
      REAL abmag
      REAL t
      REAL t_diff
      REAL axisq
      REAL axisq_diff
      REAL adx
      REAL adx_diff
      REAL rsq
      REAL rsq_diff
      REAL bxisq
      REAL bxisq_diff
      REAL bdx
      REAL bdx_diff
      REAL temp
      REAL temp_diff
      REAL temp0
      REAL temp_diff0
      REAL temp1
      REAL temp2
      REAL temp3
      REAL temp_diff1
      REAL temp_diff2
      REAL temp4
      REAL temp5
      REAL temp6
      REAL temp_diff3
      REAL temp7
      REAL temp_diff4
      INTEGER ii1
      REAL temp_diff5
      INTEGER branch
      REAL y1
      REAL y1_diff
      REAL y2
      REAL y2_diff
      REAL rcore
      REAL rcore_diff
      REAL u
      REAL u_diff
      REAL v
      REAL v_diff
      REAL w
      REAL w_diff
      REAL x
      REAL x_diff
      REAL y
      REAL y_diff
      REAL z
      REAL z_diff
      REAL z1
      REAL z1_diff
      REAL z2
      REAL z2_diff
      REAL x1
      REAL x1_diff
      REAL x2
      REAL x2_diff
      REAL beta
      REAL beta_diff
      REAL pi4inv
C
      DATA pi4inv /0.079577472/
C
C---- Prandtl-Glauert coordinates 
      a(1) = (x1-x)/beta
      a(2) = y1 - y
      a(3) = z1 - z
C
      b(1) = (x2-x)/beta
      b(2) = y2 - y
      b(3) = z2 - z
C
      asq = a(1)**2 + a(2)**2 + a(3)**2
      bsq = b(1)**2 + b(2)**2 + b(3)**2
C
      amag = SQRT(asq)
      bmag = SQRT(bsq)
C
      rcore2 = rcore**2
      rcore4 = rcore2**2
C
      u = 0.
C
C---- contribution from the transverse bound leg
      IF (lbound .AND. amag*bmag .NE. 0.0) THEN
        axb(1) = a(2)*b(3) - a(3)*b(2)
        axb(2) = a(3)*b(1) - a(1)*b(3)
        axb(3) = a(1)*b(2) - a(2)*b(1)
        axbsq = axb(1)**2 + axb(2)**2 + axb(3)**2
C
        IF (axbsq .NE. 0.0) THEN
          adb = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
          alsq = asq + bsq - 2.0*adb
Cc c     RSQ = AXBSQ / ALSQ
C     
C---- Scully core model      
Cccc        T = (AMAG+BMAG)*(1.0 - ADB/ABMAG) / (AXBSQ + ALSQ*RCORE2)
Cc        T = (  (BSQ-ADB)/SQRT(BSQ+RCORE2)
Cc     &       + (ASQ-ADB)/SQRT(ASQ+RCORE2) ) / (AXBSQ + ALSQ*RCORE2)
C---- Leishman core model
          t = ((bsq-adb)/SQRT(SQRT(bsq**2+rcore4))+(asq-adb)/SQRT(SQRT(
     +      asq**2+rcore4)))/SQRT(axbsq**2+alsq**2*rcore4)
C
          u = axb(1)*t
          CALL PUSHCONTROL2B(0)
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(2)
      END IF
C
C---- trailing leg attached to A
      IF (amag .NE. 0.0) THEN
        axisq = a(3)**2 + a(2)**2
        adx = a(1)
        rsq = axisq
C
C---- Scully core model      
Cc        T = - (1.0 - ADX/AMAG) / (RSQ + RCORE2)
C---- Leishman core model
        CALL PUSHREAL8(t)
        t = -((1.0-adx/amag)/SQRT(rsq**2+rcore4))
C
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
C
C---- trailing leg attached to B
      IF (bmag .NE. 0.0) THEN
        bxisq = b(3)**2 + b(2)**2
        bdx = b(1)
        rsq = bxisq
C
C---- Scully core model      
Cc        T =   (1.0 - BDX/BMAG) / (RSQ + RCORE2)
C---- Leishman core modeld
        CALL PUSHREAL8(t)
        t = (1.0-bdx/bmag)/SQRT(rsq**2+rcore4)
C
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      w_diff = pi4inv*w_diff
      v_diff = pi4inv*v_diff
      temp_diff4 = pi4inv*u_diff/beta
      u_diff = temp_diff4
      beta_diff = beta_diff - u*temp_diff4/beta
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        t_diff = b(3)*v_diff - b(2)*w_diff
        temp7 = SQRT(rsq*rsq + rcore4)
        temp_diff3 = t_diff/temp7
        IF (rsq**2 + rcore4 .EQ. 0.D0) THEN
          temp_diff5 = 0.D0
        ELSE
          temp_diff5 = -((1.0-bdx/bmag)*temp_diff3/(2.0*temp7**2))
        END IF
        rsq_diff = 2*rsq*temp_diff5
        bxisq_diff = rsq_diff
        DO ii1=1,3
          b_diff(ii1) = 0.D0
        ENDDO
        b_diff(2) = b_diff(2) + 2*b(2)*bxisq_diff - t*w_diff
        b_diff(3) = b_diff(3) + t*v_diff + 2*b(3)*bxisq_diff
        CALL POPREAL8(t)
        bdx_diff = -(temp_diff3/bmag)
        bmag_diff = bdx*temp_diff3/bmag**2
        rcore4_diff = temp_diff5
        b_diff(1) = b_diff(1) + bdx_diff
      ELSE
        rcore4_diff = 0.D0
        bmag_diff = 0.D0
        DO ii1=1,3
          b_diff(ii1) = 0.D0
        ENDDO
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        t_diff = a(3)*v_diff - a(2)*w_diff
        rsq = axisq
        temp7 = SQRT(rsq*rsq + rcore4)
        temp_diff3 = -(t_diff/temp7)
        IF (rsq**2 + rcore4 .EQ. 0.D0) THEN
          temp_diff5 = 0.D0
        ELSE
          temp_diff5 = -((1.0-adx/amag)*temp_diff3/(2.0*temp7**2))
        END IF
        rsq_diff = 2*rsq*temp_diff5
        axisq_diff = rsq_diff
        DO ii1=1,3
          a_diff(ii1) = 0.D0
        ENDDO
        a_diff(2) = a_diff(2) + 2*a(2)*axisq_diff - t*w_diff
        a_diff(3) = a_diff(3) + t*v_diff + 2*a(3)*axisq_diff
        CALL POPREAL8(t)
        adx_diff = -(temp_diff3/amag)
        amag_diff = adx*temp_diff3/amag**2
        rcore4_diff = rcore4_diff + temp_diff5
        a_diff(1) = a_diff(1) + adx_diff
      ELSE
        amag_diff = 0.D0
        DO ii1=1,3
          a_diff(ii1) = 0.D0
        ENDDO
      END IF
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        DO ii1=1,3
          axb_diff(ii1) = 0.D0
        ENDDO
        axb_diff(3) = axb_diff(3) + t*w_diff
        t_diff = axb(3)*w_diff + axb(2)*v_diff + axb(1)*u_diff
        axb_diff(2) = axb_diff(2) + t*v_diff
        axb_diff(1) = axb_diff(1) + t*u_diff
        temp = axbsq*axbsq + alsq*alsq*rcore4
        temp0 = SQRT(temp)
        temp1 = SQRT(bsq*bsq + rcore4)
        temp2 = SQRT(temp1)
        temp3 = (bsq-adb)/temp2
        temp4 = SQRT(asq*asq + rcore4)
        temp5 = SQRT(temp4)
        temp6 = (asq-adb)/temp5
        temp_diff0 = t_diff/temp0
        temp_diff1 = temp_diff0/temp2
        temp_diff3 = temp_diff0/temp5
        IF (temp .EQ. 0.D0) THEN
          temp_diff = 0.D0
        ELSE
          temp_diff = -((temp3+temp6)*temp_diff0/(2.0*temp0**2))
        END IF
        axbsq_diff = 2*axbsq*temp_diff
        alsq_diff = 2*alsq*rcore4*temp_diff
        adb_diff = -temp_diff3 - temp_diff1 - 2.0*alsq_diff
        IF (asq**2 + rcore4 .EQ. 0.D0 .OR. temp4 .EQ. 0.D0) THEN
          temp_diff4 = 0.D0
        ELSE
          temp_diff4 = -(temp6*temp_diff3/(2.0**2*temp4*temp5))
        END IF
        asq_diff = temp_diff3 + 2*asq*temp_diff4 + alsq_diff
        IF (bsq**2 + rcore4 .EQ. 0.D0 .OR. temp1 .EQ. 0.D0) THEN
          temp_diff2 = 0.D0
        ELSE
          temp_diff2 = -(temp3*temp_diff1/(2.0**2*temp1*temp2))
        END IF
        rcore4_diff = rcore4_diff + alsq**2*temp_diff + temp_diff4 + 
     +    temp_diff2
        bsq_diff = temp_diff1 + 2*bsq*temp_diff2 + alsq_diff
        a_diff(1) = a_diff(1) + b(1)*adb_diff
        b_diff(1) = b_diff(1) + a(1)*adb_diff
        a_diff(2) = a_diff(2) + b(2)*adb_diff
        b_diff(2) = b_diff(2) + a(2)*adb_diff
        a_diff(3) = a_diff(3) + b(3)*adb_diff
        b_diff(3) = b_diff(3) + a(3)*adb_diff
      ELSE IF (branch .EQ. 1) THEN
        axbsq_diff = 0.D0
        DO ii1=1,3
          axb_diff(ii1) = 0.D0
        ENDDO
        bsq_diff = 0.D0
        asq_diff = 0.D0
      ELSE
        bsq_diff = 0.D0
        asq_diff = 0.D0
        GOTO 100
      END IF
      axb_diff(1) = axb_diff(1) + 2*axb(1)*axbsq_diff
      axb_diff(2) = axb_diff(2) + 2*axb(2)*axbsq_diff
      axb_diff(3) = axb_diff(3) + 2*axb(3)*axbsq_diff
      a_diff(1) = a_diff(1) + b(2)*axb_diff(3) - b(3)*axb_diff(2)
      b_diff(2) = b_diff(2) + a(1)*axb_diff(3) - a(3)*axb_diff(1)
      a_diff(2) = a_diff(2) + b(3)*axb_diff(1) - b(1)*axb_diff(3)
      b_diff(1) = b_diff(1) + a(3)*axb_diff(2) - a(2)*axb_diff(3)
      axb_diff(3) = 0.D0
      a_diff(3) = a_diff(3) + b(1)*axb_diff(2) - b(2)*axb_diff(1)
      b_diff(3) = b_diff(3) + a(2)*axb_diff(1) - a(1)*axb_diff(2)
      axb_diff(2) = 0.D0
 100  rcore2_diff = 2*rcore2*rcore4_diff
      rcore_diff = rcore_diff + 2*rcore*rcore2_diff
      IF (.NOT.bsq .EQ. 0.D0) bsq_diff = bsq_diff + bmag_diff/(2.0*SQRT(
     +    bsq))
      IF (.NOT.asq .EQ. 0.D0) asq_diff = asq_diff + amag_diff/(2.0*SQRT(
     +    asq))
      b_diff(1) = b_diff(1) + 2*b(1)*bsq_diff
      b_diff(2) = b_diff(2) + 2*b(2)*bsq_diff
      b_diff(3) = b_diff(3) + 2*b(3)*bsq_diff
      a_diff(1) = a_diff(1) + 2*a(1)*asq_diff
      a_diff(2) = a_diff(2) + 2*a(2)*asq_diff
      a_diff(3) = a_diff(3) + 2*a(3)*asq_diff
      z2_diff = z2_diff + b_diff(3)
      z_diff = z_diff - b_diff(3) - a_diff(3)
      b_diff(3) = 0.D0
      y2_diff = y2_diff + b_diff(2)
      y_diff = y_diff - b_diff(2) - a_diff(2)
      b_diff(2) = 0.D0
      temp_diff = b_diff(1)/beta
      x2_diff = x2_diff + temp_diff
      x_diff = x_diff - temp_diff
      beta_diff = beta_diff - (x2-x)*temp_diff/beta
      z1_diff = z1_diff + a_diff(3)
      a_diff(3) = 0.D0
      y1_diff = y1_diff + a_diff(2)
      a_diff(2) = 0.D0
      temp_diff = a_diff(1)/beta
      x1_diff = x1_diff + temp_diff
      x_diff = x_diff - temp_diff
      beta_diff = beta_diff - (x1-x)*temp_diff/beta
      END

