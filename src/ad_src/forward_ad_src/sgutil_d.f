C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 15 Jan 2021 14:26
C
C  Differentiation of akima in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: yy
C   with respect to varying inputs: xx
C***********************************************************************
C    Module:  sgutil.f
C 
C    Copyright (C) 2002 Mark Drela, Harold Youngren
C 
C    This program is free software; you can redistribute it and/or modify
C    it under the terms of the GNU General Public License as published by
C    the Free Software Foundation; either version 2 of the License, or
C    (at your option) any later version.
C
C    This program is distributed in the hope that it will be useful,
C    but WITHOUT ANY WARRANTY; without even the implied warranty of
C    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C    GNU General Public License for more details.
C
C    You should have received a copy of the GNU General Public License
C    along with this program; if not, write to the Free Software
C    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
C***********************************************************************
C
C
C
      SUBROUTINE AKIMA_D(x, y, n, xx, xx_diff, yy, yy_diff, slp)
      INTEGER n
      REAL d
      REAL t
      REAL x
      REAL y
C
C...PURPOSE    General-purpose monovariate interpolation routine
C              using a locally-fitted cubic spline. One point is
C              interpolated from the input data arrays.
C
C...INPUT:     X  An input array of abscissas in ascending or 
C                 descending value order.
C              Y  An input array of corresponding ordinates. The 
C                 function Y(X) must be single-valued.
C              N  Size for the 'X' and 'Y' arrays. 'N' is an integer.
C                 (the input arrays may be any size)
C
C             XX  Input 'X' point at which an interpolated 'Y' value is
C                 desired.
C
C...OUTPUT:   YY  Interpolated 'Y' ordinate.
C            SLP  Interpolated slope (DY/DX).
C
C...DISCUSSION This spline method produces an interpolated curve that
C              is relatively free of the oscillatory behavior normally
C              associated with cubic splines. The curve produced will
C              be continuous in 'Y' and 'DY/DX' but further derivatives
C              may be discontinuous. The interpolated slope should be
C              treated with some caution, however, due to the tendency
C              of this spline curve to concentrate changes of curvature
C              at the input points (interval ends). If only 2 points are
C              input the curve will be linear, if 3 points are given
C              the curve will be parabolic, more than 3 points will
C              produce a cubic. Extrapolation beyond the bounds of the
C              input data is done with a quadratic through the last 3
C              points at that data boundary.
C
C              This routine is intended as a replacement for B.Wainfan's
C              AKIMAD. It is shorter, twice as fast and it works on
C              input data in ascending or descending order. The calling
C              sequence is more natural and is easier to use for the
C              bulk of applications.
C
C              The coding is compatible with IBM or VAX Fortran 77 
C              and IBM Fortran IV G or H with optimization.
C
C...ORIGIN     Harold Youngren  CALAC Dept. 72-71   3/81
C
C...REFERENCE  Akima, Hiroshi, "A New Method of Interpolation and
C              Smooth Curve Fitting Based on Local Procedures",
C              Journal of the Association for Computing Machines,
C              Vol. 17, No. 4, Oct 1970, pages 589-602
C
C              Wainfan, B. S., "The Akima Subroutines:  Nonlinear
C              Interpolation by Local Polynomial Fit", LR 29244,
C              Oct 30, 1979.
C
C
      DIMENSION x(n), y(n), d(5), t(2)
      REAL xordr
      INTEGER ibot
      INTEGER itop
      REAL xxo
      INTEGER nstep
      INTEGER i
      REAL xo
      INTEGER j
      INTEGER k
      REAL a
      INTRINSIC ABS
      REAL b
      REAL xint
      REAL xdif
      REAL xdif_diff
      REAL p0
      REAL p1
      REAL p2
      REAL p3
      REAL temp
      REAL xx
      REAL xx_diff
      REAL yy
      REAL yy_diff
      REAL slp
C 
C
C...Check for a degenerate case ( X(1)=X(N) ).    
C 
      IF (x(1) .NE. x(n)) THEN
C
C
C...Find which interval contains the point by binary search.
C...The binary search loop is terminated when the search residual
C...(NSTEP) is zero. The index 'I' will point to the input point
C...lower than or equal to the desired point for the 'X' values
C...in ascending order or to the input point greater than or equal
C...to the desired point for descending order 'X' values.       
C
        xordr = 1.0
        IF (x(1) .GT. x(n)) xordr = -1.0
C
        ibot = 1
        itop = n
        xxo = xx*xordr
C
 20     nstep = (itop-ibot)/2
        i = ibot + nstep
        xo = x(i)*xordr
        IF (xxo .GE. xo) ibot = i
        IF (xxo .LT. xo) itop = i
        IF (nstep .NE. 0) GOTO 20
C
C
C...Calculate the straight line slopes between adjacent input points.
C...D(3) is the slope on the interval of interpolation. If the other
C...slopes D(1), D(2), D(4) OR D(5) are not defined they will be
C...created by quadratic extrapolation (only at start and end of data).
C
        DO j=1,5
          k = i + (j-2)
          IF (k - 1 .GE. 1 .AND. k .LE. n) d(j) = (y(k)-y(k-1))/(x(k)-x(
     +        k-1))
        ENDDO
C
C...Synthesize upper and lower slopes if required. Check for
C...single line segment input (N=2).
C
        IF (n .EQ. 2) d(2) = d(3)
C
        IF (i + 2 .GT. n) d(4) = 2.*d(3) - d(2)
        IF (i + 3 .GT. n) d(5) = 2.*d(4) - d(3)
        IF (i - 1 .LT. 1) d(2) = 2.*d(3) - d(4)
        IF (i - 2 .LT. 1) d(1) = 2.*d(2) - d(3)
C
C
C...Calculate the slopes (T(1),T(2)) at the lower and upper
C...points bounding the interval of interpolation. If the point is
C...at an intersection of straight line segments the slope is
C...defined by the average of the adjacent segment slopes.
C
        DO j=1,2
          IF (d(j+3) - d(j+2) .GE. 0.) THEN
            a = d(j+3) - d(j+2)
          ELSE
            a = -(d(j+3)-d(j+2))
          END IF
          IF (d(j+1) - d(j) .GE. 0.) THEN
            b = d(j+1) - d(j)
          ELSE
            b = -(d(j+1)-d(j))
          END IF
          IF (a + b .EQ. 0.) THEN
            a = 1.
            b = 1.
          END IF
          t(j) = (a*d(j+1)+b*d(j+2))/(a+b)
        ENDDO
C
C
C...Check if desired point is on upper point of interval. This
C...reduces error at the transition points between intervals.
C
        IF (xx .NE. x(i+1)) THEN
C
C...Calculate the cubic coefficients.
C
          xint = x(i+1) - x(i)
          xdif_diff = xx_diff
          xdif = xx - x(i)
          p0 = y(i)
          p1 = t(1)
          p2 = (3.*d(3)-2.*t(1)-t(2))/xint
          p3 = (t(1)+t(2)-2.*d(3))/(xint*xint)
C
C...Calculate the Y-value and the slope.
C
          temp = p1 + xdif*(p2+p3*xdif)
          yy_diff = (temp+xdif*(p2+p3*xdif+xdif*p3))*xdif_diff
          yy = p0 + xdif*temp
          slp = p1 + xdif*(2.*p2+xdif*(3.*p3))
        ELSE
          yy = y(i+1)
          slp = t(2)
          yy_diff = 0.D0
        END IF
      ELSE
        yy = y(1)
        slp = 0.
        yy_diff = 0.D0
      END IF
C
      RETURN
      END

C  Differentiation of cspacer in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: xcp
C   with respect to varying inputs: xcp claf
C SPACER
C
C
C
      SUBROUTINE CSPACER_D(nvc, cspace, claf, claf_diff, xpt, xvr, xsr, 
     +                     xcp, xcp_diff)
      REAL xpt(*), xvr(*), xsr(*), xcp(*)
      REAL xcp_diff(*)
      REAL pi
      INTRINSIC ATAN
      REAL acsp
      INTRINSIC ABS
      INTEGER ncsp
      INTRINSIC INT
      REAL f0
      REAL f1
      REAL f2
      REAL dth1
      INTRINSIC FLOAT
      REAL dth2
      REAL dxc0
      INTEGER ivc
      REAL xc0
      REAL xpt0
      REAL xvr0
      REAL xsr0
      REAL xcp0
      REAL xcp0_diff
      REAL th1
      REAL xpt1
      INTRINSIC COS
      REAL xvr1
      REAL xsr1
      REAL xcp1
      REAL xcp1_diff
      REAL th2
      REAL xpt2
      REAL xvr2
      REAL xsr2
      REAL xcp2
      REAL xcp2_diff
      INTRINSIC SIN
      REAL arg1
      REAL arg1_diff
      REAL claf
      REAL claf_diff
      REAL cspace
      INTEGER nvc
C
      pi = 4.0*ATAN(1.0)
      IF (cspace .GE. 0.) THEN
        acsp = cspace
      ELSE
        acsp = -cspace
      END IF
      ncsp = INT(acsp)
      IF (ncsp .EQ. 0) THEN
        f0 = 1.0 - acsp
        f1 = acsp
        f2 = 0.
      ELSE IF (ncsp .EQ. 1) THEN
        f0 = 0.
        f1 = 2.0 - acsp
        f2 = acsp - 1.0
      ELSE
        f0 = acsp - 2.0
        f1 = 0.
        f2 = 3.0 - acsp
      END IF
C
C---- cosine chordwise spacing
      dth1 = pi/FLOAT(4*nvc+2)
      dth2 = 0.5*pi/FLOAT(4*nvc+1)
      dxc0 = 1.0/FLOAT(4*nvc)
C
      DO ivc=1,nvc
C------ uniform
        xc0 = INT(4*ivc-4)*dxc0
        xpt0 = xc0
        xvr0 = xc0 + dxc0
        xsr0 = xc0 + 2.0*dxc0
        xcp0_diff = dxc0*2.0*claf_diff
        xcp0 = xc0 + dxc0 + 2.0*dxc0*claf
C
C------ cosine
        th1 = INT(4*ivc-3)*dth1
        xpt1 = 0.5*(1.0-COS(th1))
        xvr1 = 0.5*(1.0-COS(th1+dth1))
        xsr1 = 0.5*(1.0-COS(th1+2.0*dth1))
        arg1_diff = dth1*2.0*claf_diff
        arg1 = th1 + dth1 + 2.0*dth1*claf
        xcp1_diff = 0.5*SIN(arg1)*arg1_diff
        xcp1 = 0.5*(1.0-COS(arg1))
C
        IF (cspace .GT. 0.0) THEN
C------- sine
          th2 = INT(4*ivc-3)*dth2
          xpt2 = 1.0 - COS(th2)
          xvr2 = 1.0 - COS(th2 + dth2)
          xsr2 = 1.0 - COS(th2 + 2.0*dth2)
          arg1_diff = dth2*2.0*claf_diff
          arg1 = th2 + dth2 + 2.0*dth2*claf
          xcp2_diff = SIN(arg1)*arg1_diff
          xcp2 = 1.0 - COS(arg1)
        ELSE
C------- -sine
          th2 = INT(4*ivc-4)*dth2
          xpt2 = SIN(th2)
          xvr2 = SIN(th2 + dth2)
          xsr2 = SIN(th2 + 2.0*dth2)
          arg1_diff = dth2*2.0*claf_diff
          arg1 = th2 + dth2 + 2.0*dth2*claf
          xcp2_diff = COS(arg1)*arg1_diff
          xcp2 = SIN(arg1)
        END IF
C
C------ blend 'em
        xpt(ivc) = f0*xpt0 + f1*xpt1 + f2*xpt2
        xvr(ivc) = f0*xvr0 + f1*xvr1 + f2*xvr2
        xsr(ivc) = f0*xsr0 + f1*xsr1 + f2*xsr2
        xcp_diff(ivc) = f0*xcp0_diff + f1*xcp1_diff + f2*xcp2_diff
        xcp(ivc) = f0*xcp0 + f1*xcp1 + f2*xcp2
      ENDDO
C
      xpt(1) = 0.0
      xpt(nvc+1) = 1.0
C
      RETURN
      END
C CSPACER
C

