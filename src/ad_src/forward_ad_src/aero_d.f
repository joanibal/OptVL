C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 15 Jan 2021 14:26
C
C  Differentiation of aero in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: cltot cytot crtot cmtot cntot
C                cltot_a cltot_u cytot_u crtot_u cmtot_u cntot_u
C                cltot_d cytot_d crtot_d cmtot_d cntot_d clsurf
C                cysurf crsurf cnsurf cmsurf cls_a cls_u cys_u
C                crs_u cns_u cms_u cls_d cys_d crs_d cns_d cms_d
C                clstrp cystrp crstrp cnstrp cmstrp clst_a clst_u
C                cyst_u crst_u cnst_u cmst_u clst_d cyst_d crst_d
C                cnst_d cmst_d clbdy cybdy crbdy cnbdy cmbdy
C   with respect to varying inputs: alfa vinf wrot xyzref cltot_u
C                cytot_u crtot_u cmtot_u cntot_u cltot_d cytot_d
C                crtot_d cmtot_d cntot_d clsurf cysurf crsurf cnsurf
C                cmsurf cls_a cls_u cys_u crs_u cns_u cms_u cls_d
C                cys_d crs_d cns_d cms_d rle chord wstrip ensy
C                ensz clstrp cystrp crstrp cnstrp cmstrp clst_a
C                clst_u cyst_u crst_u cnst_u cmst_u clst_d cyst_d
C                crst_d cnst_d cmst_d rv1 rv2 gam clbdy cybdy crbdy
C                cnbdy cmbdy
C***********************************************************************
C    Module:  aero.f
C 
C    Copyright (C) 2002 Mark Drela, Harold Youngren
C 
C    This program is free software; you can redistribute it and/or modify
C    it under the terms of the GNU General Public License as published by
C    the Free Software Foundation; either version 2 of the License, or
C    (at your option) any later version.
C
C    This program is distributed in the hope that it will be useful,
C    but WITHOUT ANY WARRANTY; without even the implied warranty of
C    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C    GNU General Public License for more details.
C
C    You should have received a copy of the GNU General Public License
C    along with this program; if not, write to the Free Software
C    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
C***********************************************************************
C
      SUBROUTINE AERO_D()
      IMPLICIT NONE
      INCLUDE 'AVL_d.inc'
      INTEGER l
      INTEGER n
      EXTERNAL TPFORC
      REAL vsq
      REAL vsqd
      REAL vmag
      REAL vmagd
      INTRINSIC SQRT
      INTEGER iu
      REAL temp
C
      cdtot = 0.
      cltot = 0.
      cxtot = 0.
      cytot = 0.
      cztot = 0.
      crtot = 0.
      cmtot = 0.
      cntot = 0.
      cdvtot = 0.
C
      cdtot_a = 0.
      cltot_a = 0.
C
      DO l=1,ncontrol
        chinge(l) = 0.
      ENDDO
C
      DO n=1,numax
        cdtot_u(n) = 0.
        cltot_ud(n) = 0.D0
        cltot_u(n) = 0.
        cxtot_u(n) = 0.
        cytot_ud(n) = 0.D0
        cytot_u(n) = 0.
        cztot_u(n) = 0.
        crtot_ud(n) = 0.D0
        crtot_u(n) = 0.
        cmtot_ud(n) = 0.D0
        cmtot_u(n) = 0.
        cntot_ud(n) = 0.D0
        cntot_u(n) = 0.
        DO l=1,ncontrol
          chinge_u(l, n) = 0.
        ENDDO
      ENDDO
C
      DO n=1,ncontrol
        cdtot_d(n) = 0.
        cltot_dd(n) = 0.D0
        cltot_d(n) = 0.
        cxtot_d(n) = 0.
        cytot_dd(n) = 0.D0
        cytot_d(n) = 0.
        cztot_d(n) = 0.
        crtot_dd(n) = 0.D0
        crtot_d(n) = 0.
        cmtot_dd(n) = 0.D0
        cmtot_d(n) = 0.
        cntot_dd(n) = 0.D0
        cntot_d(n) = 0.
        DO l=1,ncontrol
          chinge_d(l, n) = 0.
        ENDDO
      ENDDO
C
      DO n=1,ndesign
        cdtot_g(n) = 0.
        cltot_g(n) = 0.
        cxtot_g(n) = 0.
        cytot_g(n) = 0.
        cztot_g(n) = 0.
        crtot_g(n) = 0.
        cmtot_g(n) = 0.
        cntot_g(n) = 0.
        DO l=1,ncontrol
          chinge_g(l, n) = 0.
        ENDDO
      ENDDO
C
C
      CALL SFFORC_D()
      CALL BDFORC_D()
      CALL TPFORC()
C
C---------------------------------------------------------
C---- add baseline reference CD
C      SINA = SIN(ALFA)
C      COSA = COS(ALFA)
C
      vsqd = 2*vinf(1)*vinfd(1) + 2*vinf(2)*vinfd(2) + 2*vinf(3)*vinfd(3
     +  )
      vsq = vinf(1)**2 + vinf(2)**2 + vinf(3)**2
      temp = SQRT(vsq)
      IF (vsq .EQ. 0.D0) THEN
        vmagd = 0.D0
      ELSE
        vmagd = vsqd/(2.0*temp)
      END IF
      vmag = temp
C
      cdvtot = cdvtot + cdref*vsq
C
      cdtot = cdtot + cdref*vsq
      cxtot = cxtot + cdref*vinf(1)*vmag
      cytotd = cytotd + cdref*(vmag*vinfd(2)+vinf(2)*vmagd)
      cytot = cytot + cdref*vinf(2)*vmag
      cztot = cztot + cdref*vinf(3)*vmag
C
      cxtot_u(1) = cxtot_u(1) + cdref*vmag
      cytot_ud(2) = cytot_ud(2) + cdref*vmagd
      cytot_u(2) = cytot_u(2) + cdref*vmag
      cztot_u(3) = cztot_u(3) + cdref*vmag
      DO iu=1,3
        cdtot_u(iu) = cdtot_u(iu) + cdref*2.0*vinf(iu)
        cxtot_u(iu) = cxtot_u(iu) + cdref*vinf(1)*vinf(iu)/vmag
        temp = vinf(2)/vmag
        cytot_ud(iu) = cytot_ud(iu) + cdref*(vinf(iu)*(vinfd(2)-temp*
     +    vmagd)/vmag+temp*vinfd(iu))
        cytot_u(iu) = cytot_u(iu) + cdref*(temp*vinf(iu))
        cztot_u(iu) = cztot_u(iu) + cdref*vinf(3)*vinf(iu)/vmag
      ENDDO
C

      RETURN
      END

C  Differentiation of sfforc in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: cltot cytot crtot cmtot cntot
C                cltot_a cltot_u cytot_u crtot_u cmtot_u cntot_u
C                cltot_d cytot_d crtot_d cmtot_d cntot_d clsurf
C                cysurf crsurf cnsurf cmsurf cls_a cls_u cys_u
C                crs_u cns_u cms_u cls_d cys_d crs_d cns_d cms_d
C                clstrp cystrp crstrp cnstrp cmstrp clst_a clst_u
C                cyst_u crst_u cnst_u cmst_u clst_d cyst_d crst_d
C                cnst_d cmst_d
C   with respect to varying inputs: alfa vinf wrot xyzref cltot_u
C                cytot_u crtot_u cmtot_u cntot_u cltot_d cytot_d
C                crtot_d cmtot_d cntot_d clsurf cysurf crsurf cnsurf
C                cmsurf cls_a cls_u cys_u crs_u cns_u cms_u cls_d
C                cys_d crs_d cns_d cms_d rle chord wstrip ensy
C                ensz clstrp cystrp crstrp cnstrp cmstrp clst_a
C                clst_u cyst_u crst_u cnst_u cmst_u clst_d cyst_d
C                crst_d cnst_d cmst_d rv1 rv2 gam
C AERO
C
C
C
      SUBROUTINE SFFORC_D()
      IMPLICIT NONE
      INCLUDE 'AVL_d.inc'
C
      REAL rrot(3)
      REAL rrotd(3)
      REAL veff(3), vrot(3), veff_u(3, 6), vrot_u(3), wrot_u(3)
      REAL veffd(3), vrotd(3), veff_ud(3, 6), vrot_ud(3), wrot_ud(3)
      REAL vperp(3)
      REAL g(3), r(3), rh(3), mh(3)
      REAL gd(3), rd(3)
      REAL f(3), f_u(3, 6)
      REAL fd(3), f_ud(3, 6)
      REAL fgam(3), fgam_u(3, 6), fgam_d(3, ndmax), fgam_g(3, ngmax)
      REAL fgamd(3), fgam_ud(3, 6), fgam_dd(3, ndmax)
      REAL enave(3), spn(3), udrag(3), ulift(3)
      REAL spnd(3), udragd(3), uliftd(3)
C
      REAL cfx_u(numax), cfy_u(numax), cfz_u(numax), cmx_u(numax), cmy_u
     +     (numax), cmz_u(numax), cfx_d(ndmax), cfy_d(ndmax), cfz_d(
     +     ndmax), cmx_d(ndmax), cmy_d(ndmax), cmz_d(ndmax), cfx_g(ngmax
     +     ), cfy_g(ngmax), cfz_g(ngmax), cmx_g(ngmax), cmy_g(ngmax), 
     +     cmz_g(ngmax), clv_u(numax), clv_d(ndmax), clv_g(ngmax)
      REAL cfx_ud(numax), cfy_ud(numax), cfz_ud(numax), cmx_ud(numax), 
     +     cmy_ud(numax), cmz_ud(numax), cfx_dd(ndmax), cfy_dd(ndmax), 
     +     cfz_dd(ndmax), cmx_dd(ndmax), cmy_dd(ndmax), cmz_dd(ndmax), 
     +     clv_ud(numax), clv_dd(ndmax)
      REAL sina
      REAL sinad
      INTRINSIC SIN
      REAL cosa
      REAL cosad
      INTRINSIC COS
      INTEGER j
      INTEGER i1
      INTEGER nvc_strp
      REAL cr
      REAL crd
      REAL sr
      REAL srd
      REAL xte1
      REAL xte2
      REAL ulmag
      REAL ulmagd
      REAL DOT
      REAL DOT_D
      INTRINSIC SQRT
      REAL xr
      REAL xrd
      REAL yr
      REAL yrd
      REAL zr
      REAL zrd
      REAL cfx
      REAL cfxd
      REAL cfy
      REAL cfyd
      REAL cfz
      REAL cfzd
      REAL cmx
      REAL cmxd
      REAL cmy
      REAL cmyd
      REAL cmz
      REAL cmzd
      INTEGER n
      INTEGER ii
      INTEGER i
      INTEGER k
      REAL fnv
      REAL fnv_u
      REAL fnv_d
      REAL fnv_g
      REAL dcfx
      REAL dcfxd
      REAL dcfy
      REAL dcfyd
      REAL dcfz
      REAL dcfzd
      REAL dcfx_u
      REAL dcfx_ud
      REAL dcfy_u
      REAL dcfy_ud
      REAL dcfz_u
      REAL dcfz_ud
      REAL dcfx_d
      REAL dcfx_dd
      REAL dcfy_d
      REAL dcfy_dd
      REAL dcfz_d
      REAL dcfz_dd
      REAL dcfx_g
      REAL dcfy_g
      REAL dcfz_g
      INTEGER l
      REAL dfac
      INTEGER ileg
      REAL veffmag
      REAL veffmagd
      REAL clv
      REAL clvd
      REAL cdv
      REAL cdvd
      REAL cdv_clv
      REAL cdv_clvd
      REAL dcvfx
      REAL dcvfxd
      REAL dcvfy
      REAL dcvfyd
      REAL dcvfz
      REAL dcvfzd
      REAL dcvfx_u
      REAL dcvfx_ud
      REAL dcvfy_u
      REAL dcvfy_ud
      REAL dcvfz_u
      REAL dcvfz_ud
      REAL dcvfx_d
      REAL dcvfx_dd
      REAL dcvfy_d
      REAL dcvfy_dd
      REAL dcvfz_d
      REAL dcvfz_dd
      REAL dcvfx_g
      REAL dcvfy_g
      REAL dcvfz_g
      REAL vsq
      REAL vsqi
      REAL vspan
      REAL vpsq
      REAL vpsqi
      REAL delx
      REAL dely
      REAL delz
      REAL dmag
      INTEGER is
      INTEGER nstrps
      INTEGER jj
      INTEGER l1
      INTRINSIC MOD
      INTEGER l2
      REAL dcm
      REAL enmag
      REAL result1
      REAL result1d
      REAL result2
      REAL arg1
      REAL arg1d
      REAL temp
      INTEGER ii1
      REAL temp0
      REAL temp1
      INTEGER ii2
C
C
      sinad = COS(alfa)*alfad
      sina = SIN(alfa)
      cosad = -(SIN(alfa)*alfad)
      cosa = COS(alfa)
      DO ii1=1,numax
        cmz_ud(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        fd(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        gd(ii1) = 0.D0
      ENDDO
      DO ii1=1,numax
        cfy_ud(ii1) = 0.D0
      ENDDO
      DO ii1=1,6
        DO ii2=1,3
          fgam_ud(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,6
        DO ii2=1,3
          veff_ud(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,3
        rd(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        udragd(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        cmy_dd(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        cfx_dd(ii1) = 0.D0
      ENDDO
      DO ii1=1,numax
        cmy_ud(ii1) = 0.D0
      ENDDO
      DO ii1=1,numax
        cfx_ud(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        cfz_dd(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        vrotd(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        clv_dd(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        vrot_ud(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        cmx_dd(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        veffd(ii1) = 0.D0
      ENDDO
      DO ii1=1,numax
        cfz_ud(ii1) = 0.D0
      ENDDO
      DO ii1=1,numax
        clv_ud(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        uliftd(ii1) = 0.D0
      ENDDO
      DO ii1=1,numax
        cmx_ud(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        fgamd(ii1) = 0.D0
      ENDDO
      DO ii1=1,6
        DO ii2=1,3
          f_ud(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        cmz_dd(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        rrotd(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        cfy_dd(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,3
          fgam_dd(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,3
        spnd(ii1) = 0.D0
      ENDDO
C
C***********************************************************************
C...Integrate the forces strip-wise, surface-wise and total-wise
C***********************************************************************
C
C...Calculate strip forces...
C    normalized to strip reference quantities (strip area, chord)
      DO j=1,nstrip
C
        i1 = ijfrst(j)
        nvc_strp = nvstrp(j)
C
        crd = chordd(j)
        cr = chord(j)
        srd = wstrip(j)*chordd(j) + chord(j)*wstripd(j)
        sr = chord(j)*wstrip(j)
C
        xte1 = rle1(1, j) + chord1(j)
        xte2 = rle2(1, j) + chord2(j)
C
C--- Define local strip lift and drag directions
C--- The "spanwise" vector is cross product of strip normal with X chordline 
        spnd(1) = 0.D0
        spn(1) = 0.0
        spnd(2) = enszd(j)
        spn(2) = ensz(j)
        spnd(3) = -ensyd(j)
        spn(3) = -ensy(j)
C--- Stability axes stream vector defines drag direction
        udragd(1) = cosad
        udrag(1) = cosa
        udragd(2) = 0.D0
        udrag(2) = 0.0
        udragd(3) = sinad
        udrag(3) = sina
C--- Lift direction is vector product of "stream" and spanwise vector
        CALL CROSS_D(udrag, udragd, spn, spnd, ulift, uliftd)
        result1d = DOT_D(ulift, uliftd, ulift, uliftd, result1)
        temp = SQRT(result1)
        IF (result1 .EQ. 0.D0) THEN
          ulmagd = 0.D0
        ELSE
          ulmagd = result1d/(2.0*temp)
        END IF
        ulmag = temp
        IF (ulmag .EQ. 0.) THEN
          uliftd(3) = 0.D0
          ulift(3) = 1.0
        ELSE
          temp = ulift(1)/ulmag
          uliftd(1) = (uliftd(1)-temp*ulmagd)/ulmag
          ulift(1) = temp
          temp = ulift(2)/ulmag
          uliftd(2) = (uliftd(2)-temp*ulmagd)/ulmag
          ulift(2) = temp
          temp = ulift(3)/ulmag
          uliftd(3) = (uliftd(3)-temp*ulmagd)/ulmag
          ulift(3) = temp
        END IF
C
C...Use the strip 1/4 chord location for strip moments
        xrd = rled(1, j) + 0.25*crd
        xr = rle(1, j) + 0.25*cr
        yrd = rled(2, j)
        yr = rle(2, j)
        zrd = rled(3, j)
        zr = rle(3, j)
C
        cfx = 0.
        cfy = 0.
        cfz = 0.
        cmx = 0.
        cmy = 0.
        cmz = 0.
        cnc(j) = 0.
C
        DO n=1,numax
          cfx_ud(n) = 0.D0
          cfx_u(n) = 0.
          cfy_ud(n) = 0.D0
          cfy_u(n) = 0.
          cfz_ud(n) = 0.D0
          cfz_u(n) = 0.
          cmx_ud(n) = 0.D0
          cmx_u(n) = 0.
          cmy_ud(n) = 0.D0
          cmy_u(n) = 0.
          cmz_ud(n) = 0.D0
          cmz_u(n) = 0.
          cnc_u(j, n) = 0.
        ENDDO
C
        DO n=1,ncontrol
          cfx_dd(n) = 0.D0
          cfx_d(n) = 0.
          cfy_dd(n) = 0.D0
          cfy_d(n) = 0.
          cfz_dd(n) = 0.D0
          cfz_d(n) = 0.
          cmx_dd(n) = 0.D0
          cmx_d(n) = 0.
          cmy_dd(n) = 0.D0
          cmy_d(n) = 0.
          cmz_dd(n) = 0.D0
          cmz_d(n) = 0.
          cnc_d(j, n) = 0.
        ENDDO
C
        DO n=1,ndesign
          cfx_g(n) = 0.
          cfy_g(n) = 0.
          cfz_g(n) = 0.
          cmx_g(n) = 0.
          cmy_g(n) = 0.
          cmz_g(n) = 0.
          cnc_g(j, n) = 0.
        ENDDO
        cfxd = 0.D0
        cfyd = 0.D0
        cfzd = 0.D0
        cmxd = 0.D0
        cmyd = 0.D0
        cmzd = 0.D0
C
C...Sum the forces in the strip as generated by velocity
C    (freestream + rotation + induced) acting on bound vortex 
        DO ii=1,nvc_strp
          i = i1 + (ii-1)
C
C------- local moment reference vector from vortex midpoint to strip c/4 pt.
C          R(1) = 0.5*(RV1(1,I) + RV2(1,I)) - XR
C          R(2) = 0.5*(RV1(2,I) + RV2(2,I)) - YR
C          R(3) = 0.5*(RV1(3,I) + RV2(3,I)) - ZR
          rd(1) = -xrd
          r(1) = rv(1, i) - xr
          rd(2) = -yrd
          r(2) = rv(2, i) - yr
          rd(3) = -zrd
          r(3) = rv(3, i) - zr
C
C------- vector from rotation axes
C          RROT(1) = 0.5*(RV1(1,I) + RV2(1,I)) - XYZREF(1)
C          RROT(2) = 0.5*(RV1(2,I) + RV2(2,I)) - XYZREF(2)
C          RROT(3) = 0.5*(RV1(3,I) + RV2(3,I)) - XYZREF(3)
          rrotd(1) = -xyzrefd(1)
          rrot(1) = rv(1, i) - xyzref(1)
          rrotd(2) = -xyzrefd(2)
          rrot(2) = rv(2, i) - xyzref(2)
          rrotd(3) = -xyzrefd(3)
          rrot(3) = rv(3, i) - xyzref(3)
C
C-------- set total effective velocity = freestream + rotation + induced
          CALL CROSS_D(rrot, rrotd, wrot, wrotd, vrot, vrotd)
          veffd(1) = vinfd(1) + vrotd(1)
          veff(1) = vinf(1) + vrot(1) + wv(1, i)
          veffd(2) = vinfd(2) + vrotd(2)
          veff(2) = vinf(2) + vrot(2) + wv(2, i)
          veffd(3) = vinfd(3) + vrotd(3)
          veff(3) = vinf(3) + vrot(3) + wv(3, i)
C
C-------- set VEFF sensitivities to freestream,rotation components
          DO k=1,3
            veff_ud(1, k) = 0.D0
            veff_u(1, k) = wv_u(1, i, k)
            veff_ud(2, k) = 0.D0
            veff_u(2, k) = wv_u(2, i, k)
            veff_ud(3, k) = 0.D0
            veff_u(3, k) = wv_u(3, i, k)
            veff_u(k, k) = 1.0 + veff_u(k, k)
          ENDDO
          DO k=4,6
            wrot_u(1) = 0.
            wrot_u(2) = 0.
            wrot_u(3) = 0.
            wrot_u(k-3) = 1.0
            DO ii1=1,3
              wrot_ud(ii1) = 0.D0
            ENDDO
            CALL CROSS_D(rrot, rrotd, wrot_u, wrot_ud, vrot_u, vrot_ud)
            veff_ud(1, k) = vrot_ud(1)
            veff_u(1, k) = vrot_u(1) + wv_u(1, i, k)
            veff_ud(2, k) = vrot_ud(2)
            veff_u(2, k) = vrot_u(2) + wv_u(2, i, k)
            veff_ud(3, k) = vrot_ud(3)
            veff_u(3, k) = vrot_u(3) + wv_u(3, i, k)
          ENDDO
C
C-------- Force coefficient on vortex segment is 2(Veff x Gamma)
          gd(1) = rv2d(1, i) - rv1d(1, i)
          g(1) = rv2(1, i) - rv1(1, i)
          gd(2) = rv2d(2, i) - rv1d(2, i)
          g(2) = rv2(2, i) - rv1(2, i)
          gd(3) = rv2d(3, i) - rv1d(3, i)
          g(3) = rv2(3, i) - rv1(3, i)
          CALL CROSS_D(veff, veffd, g, gd, f, fd)
          DO n=1,numax
            CALL CROSS_D(veff_u(1, n), veff_ud(1, n), g, gd, f_u(1, n), 
     +                   f_ud(1, n))
          ENDDO
C
          fgamd(1) = 2.0*(f(1)*gamd(i)+gam(i)*fd(1))
          fgam(1) = 2.0*gam(i)*f(1)
          fgamd(2) = 2.0*(f(2)*gamd(i)+gam(i)*fd(2))
          fgam(2) = 2.0*gam(i)*f(2)
          fgamd(3) = 2.0*(f(3)*gamd(i)+gam(i)*fd(3))
          fgam(3) = 2.0*gam(i)*f(3)
          DO n=1,numax
            fgam_ud(1, n) = gam_u(i, n)*2.0*fd(1) + 2.0*(f_u(1, n)*gamd(
     +        i)+gam(i)*f_ud(1, n))
            fgam_u(1, n) = 2.0*gam_u(i, n)*f(1) + 2.0*gam(i)*f_u(1, n)
            fgam_ud(2, n) = gam_u(i, n)*2.0*fd(2) + 2.0*(f_u(2, n)*gamd(
     +        i)+gam(i)*f_ud(2, n))
            fgam_u(2, n) = 2.0*gam_u(i, n)*f(2) + 2.0*gam(i)*f_u(2, n)
            fgam_ud(3, n) = gam_u(i, n)*2.0*fd(3) + 2.0*(f_u(3, n)*gamd(
     +        i)+gam(i)*f_ud(3, n))
            fgam_u(3, n) = 2.0*gam_u(i, n)*f(3) + 2.0*gam(i)*f_u(3, n)
          ENDDO
          DO n=1,ncontrol
            fgam_dd(1, n) = gam_d(i, n)*2.0*fd(1)
            fgam_d(1, n) = 2.0*gam_d(i, n)*f(1)
            fgam_dd(2, n) = gam_d(i, n)*2.0*fd(2)
            fgam_d(2, n) = 2.0*gam_d(i, n)*f(2)
            fgam_dd(3, n) = gam_d(i, n)*2.0*fd(3)
            fgam_d(3, n) = 2.0*gam_d(i, n)*f(3)
          ENDDO
          DO n=1,ndesign
            fgam_g(1, n) = 2.0*gam_g(i, n)*f(1)
            fgam_g(2, n) = 2.0*gam_g(i, n)*f(2)
            fgam_g(3, n) = 2.0*gam_g(i, n)*f(3)
          ENDDO
C
C
C-------- Delta Cp (loading across lifting surface) from vortex 
          fnv = DOT(env(1, i), fgam)
          dcp(i) = fnv/(dxv(i)*wstrip(j))
C
          DO n=1,numax
            fnv_u = DOT(env(1, i), fgam_u(1, n))
            dcp_u(i, n) = fnv_u/(dxv(i)*wstrip(j))
          ENDDO
C
          DO n=1,ncontrol
            result1 = DOT(env(1, i), fgam_d(1, n))
            result2 = DOT(env_d(1, i, n), fgam)
            fnv_d = result1 + result2
            dcp_d(i, n) = fnv_d/(dxv(i)*wstrip(j))
          ENDDO
C
          DO n=1,ndesign
            result1 = DOT(env(1, i), fgam_g(1, n))
            result2 = DOT(env_g(1, i, n), fgam)
            fnv_g = result1 + result2
            dcp_g(i, n) = fnv_g/(dxv(i)*wstrip(j))
          ENDDO
C
C-------- vortex contribution to strip forces
          temp = fgam(1)/sr
          dcfxd = (fgamd(1)-temp*srd)/sr
          dcfx = temp
          temp = fgam(2)/sr
          dcfyd = (fgamd(2)-temp*srd)/sr
          dcfy = temp
          temp = fgam(3)/sr
          dcfzd = (fgamd(3)-temp*srd)/sr
          dcfz = temp
C
C-------- forces normalized by strip area
          cfxd = cfxd + dcfxd
          cfx = cfx + dcfx
          cfyd = cfyd + dcfyd
          cfy = cfy + dcfy
          cfzd = cfzd + dcfzd
          cfz = cfz + dcfz
C
C-------- moments referred to strip c/4 pt., normalized by strip chord and area
          temp = (dcfz*r(2)-dcfy*r(3))/cr
          cmxd = cmxd + (r(2)*dcfzd+dcfz*rd(2)-r(3)*dcfyd-dcfy*rd(3)-
     +      temp*crd)/cr
          cmx = cmx + temp
          temp = (dcfx*r(3)-dcfz*r(1))/cr
          cmyd = cmyd + (r(3)*dcfxd+dcfx*rd(3)-r(1)*dcfzd-dcfz*rd(1)-
     +      temp*crd)/cr
          cmy = cmy + temp
          temp = (dcfy*r(1)-dcfx*r(2))/cr
          cmzd = cmzd + (r(1)*dcfyd+dcfy*rd(1)-r(2)*dcfxd-dcfx*rd(2)-
     +      temp*crd)/cr
          cmz = cmz + temp
C
C-------- accumulate strip spanloading = c*CN
          cnc(j) = cnc(j) + cr*(ensy(j)*dcfy+ensz(j)*dcfz)
C
C-------- freestream and rotation derivatives
          DO n=1,numax
            temp = fgam_u(1, n)/sr
            dcfx_ud = (fgam_ud(1, n)-temp*srd)/sr
            dcfx_u = temp
            temp = fgam_u(2, n)/sr
            dcfy_ud = (fgam_ud(2, n)-temp*srd)/sr
            dcfy_u = temp
            temp = fgam_u(3, n)/sr
            dcfz_ud = (fgam_ud(3, n)-temp*srd)/sr
            dcfz_u = temp
C
            cfx_ud(n) = cfx_ud(n) + dcfx_ud
            cfx_u(n) = cfx_u(n) + dcfx_u
            cfy_ud(n) = cfy_ud(n) + dcfy_ud
            cfy_u(n) = cfy_u(n) + dcfy_u
            cfz_ud(n) = cfz_ud(n) + dcfz_ud
            cfz_u(n) = cfz_u(n) + dcfz_u
            temp = (dcfz_u*r(2)-dcfy_u*r(3))/cr
            cmx_ud(n) = cmx_ud(n) + (r(2)*dcfz_ud+dcfz_u*rd(2)-r(3)*
     +        dcfy_ud-dcfy_u*rd(3)-temp*crd)/cr
            cmx_u(n) = cmx_u(n) + temp
            temp = (dcfx_u*r(3)-dcfz_u*r(1))/cr
            cmy_ud(n) = cmy_ud(n) + (r(3)*dcfx_ud+dcfx_u*rd(3)-r(1)*
     +        dcfz_ud-dcfz_u*rd(1)-temp*crd)/cr
            cmy_u(n) = cmy_u(n) + temp
            temp = (dcfy_u*r(1)-dcfx_u*r(2))/cr
            cmz_ud(n) = cmz_ud(n) + (r(1)*dcfy_ud+dcfy_u*rd(1)-r(2)*
     +        dcfx_ud-dcfx_u*rd(2)-temp*crd)/cr
            cmz_u(n) = cmz_u(n) + temp
C
            cnc_u(j, n) = cnc_u(j, n) + cr*(ensy(j)*dcfy_u+ensz(j)*
     +        dcfz_u)
          ENDDO
C
C-------- control derivatives
          DO n=1,ncontrol
            temp = fgam_d(1, n)/sr
            dcfx_dd = (fgam_dd(1, n)-temp*srd)/sr
            dcfx_d = temp
            temp = fgam_d(2, n)/sr
            dcfy_dd = (fgam_dd(2, n)-temp*srd)/sr
            dcfy_d = temp
            temp = fgam_d(3, n)/sr
            dcfz_dd = (fgam_dd(3, n)-temp*srd)/sr
            dcfz_d = temp
C
            cfx_dd(n) = cfx_dd(n) + dcfx_dd
            cfx_d(n) = cfx_d(n) + dcfx_d
            cfy_dd(n) = cfy_dd(n) + dcfy_dd
            cfy_d(n) = cfy_d(n) + dcfy_d
            cfz_dd(n) = cfz_dd(n) + dcfz_dd
            cfz_d(n) = cfz_d(n) + dcfz_d
            temp = (dcfz_d*r(2)-dcfy_d*r(3))/cr
            cmx_dd(n) = cmx_dd(n) + (r(2)*dcfz_dd+dcfz_d*rd(2)-r(3)*
     +        dcfy_dd-dcfy_d*rd(3)-temp*crd)/cr
            cmx_d(n) = cmx_d(n) + temp
            temp = (dcfx_d*r(3)-dcfz_d*r(1))/cr
            cmy_dd(n) = cmy_dd(n) + (r(3)*dcfx_dd+dcfx_d*rd(3)-r(1)*
     +        dcfz_dd-dcfz_d*rd(1)-temp*crd)/cr
            cmy_d(n) = cmy_d(n) + temp
            temp = (dcfy_d*r(1)-dcfx_d*r(2))/cr
            cmz_dd(n) = cmz_dd(n) + (r(1)*dcfy_dd+dcfy_d*rd(1)-r(2)*
     +        dcfx_dd-dcfx_d*rd(2)-temp*crd)/cr
            cmz_d(n) = cmz_d(n) + temp
C
            cnc_d(j, n) = cnc_d(j, n) + cr*(ensy(j)*dcfy_d+ensz(j)*
     +        dcfz_d)
          ENDDO
C
C-------- design derivatives
          DO n=1,ndesign
            dcfx_g = fgam_g(1, n)/sr
            dcfy_g = fgam_g(2, n)/sr
            dcfz_g = fgam_g(3, n)/sr
C
            cfx_g(n) = cfx_g(n) + dcfx_g
            cfy_g(n) = cfy_g(n) + dcfy_g
            cfz_g(n) = cfz_g(n) + dcfz_g
            cmx_g(n) = cmx_g(n) + (dcfz_g*r(2)-dcfy_g*r(3))/cr
            cmy_g(n) = cmy_g(n) + (dcfx_g*r(3)-dcfz_g*r(1))/cr
            cmz_g(n) = cmz_g(n) + (dcfy_g*r(1)-dcfx_g*r(2))/cr
C
            cnc_g(j, n) = cnc_g(j, n) + cr*(ensy(j)*dcfy_g+ensz(j)*
     +        dcfz_g)
          ENDDO
C
C-------- hinge moments
          DO l=1,ncontrol
            rh(1) = rv(1, i) - phinge(1, j, l)
            rh(2) = rv(2, i) - phinge(2, j, l)
            rh(3) = rv(3, i) - phinge(3, j, l)
C
            dfac = dcontrol(i, l)/(sref*cref)
C
            CALL CROSS(rh, fgam, mh)
            result1 = DOT(mh, vhinge(1, j, l))
            chinge(l) = chinge(l) + result1*dfac
C
            DO n=1,numax
              CALL CROSS(rh, fgam_u(1, n), mh)
              result1 = DOT(mh, vhinge(1, j, l))
              chinge_u(l, n) = chinge_u(l, n) + result1*dfac
            ENDDO
            DO n=1,ncontrol
              CALL CROSS(rh, fgam_d(1, n), mh)
              result1 = DOT(mh, vhinge(1, j, l))
              chinge_d(l, n) = chinge_d(l, n) + result1*dfac
            ENDDO
            DO n=1,ndesign
              CALL CROSS(rh, fgam_g(1, n), mh)
              result1 = DOT(mh, vhinge(1, j, l))
              chinge_g(l, n) = chinge_g(l, n) + result1*dfac
            ENDDO
          ENDDO
        ENDDO
C
C
C
        IF (ltrforce) THEN
C
C...Sum forces in the strip as generated by velocity (freestream + rotation)
C     the parts of trailing legs which lie on the surface
          DO ii=1,nvc_strp
            i = i1 + (ii-1)
C
            DO ileg=1,2
              IF (ileg .EQ. 1) THEN
C----------- local moment reference vector from vortex midpoint to strip c/4 pt
                rd(1) = 0.5*rv1d(1, i) - xrd
                r(1) = 0.5*(rv1(1, i)+xte1) - xr
                rd(2) = rv1d(2, i) - yrd
                r(2) = rv1(2, i) - yr
                rd(3) = rv1d(3, i) - zrd
                r(3) = rv1(3, i) - zr
C 
C----------- vector from rotation axes
                rrotd(1) = 0.5*rv1d(1, i) - xyzrefd(1)
                rrot(1) = 0.5*(rv1(1, i)+xte1) - xyzref(1)
                rrotd(2) = rv1d(2, i) - xyzrefd(2)
                rrot(2) = rv1(2, i) - xyzref(2)
                rrotd(3) = rv1d(3, i) - xyzrefd(3)
                rrot(3) = rv1(3, i) - xyzref(3)
C
C----------- part of trailing leg lying on surface
                gd(1) = rv1d(1, i)
                g(1) = rv1(1, i) - xte1
                gd(2) = 0.D0
                g(2) = 0.
                gd(3) = 0.D0
                g(3) = 0.
C
              ELSE
C----------- local moment reference vector from vortex midpoint to strip c/4 pt
                rd(1) = 0.5*rv2d(1, i) - xrd
                r(1) = 0.5*(rv2(1, i)+xte2) - xr
                rd(2) = rv2d(2, i) - yrd
                r(2) = rv2(2, i) - yr
                rd(3) = rv2d(3, i) - zrd
                r(3) = rv2(3, i) - zr
C
C----------- vector from rotation axes
                rrotd(1) = 0.5*rv2d(1, i) - xyzrefd(1)
                rrot(1) = 0.5*(rv2(1, i)+xte2) - xyzref(1)
                rrotd(2) = rv2d(2, i) - xyzrefd(2)
                rrot(2) = rv2(2, i) - xyzref(2)
                rrotd(3) = rv2d(3, i) - xyzrefd(3)
                rrot(3) = rv2(3, i) - xyzref(3)
C
C----------- part of trailing leg lying on surface
                gd(1) = -rv2d(1, i)
                g(1) = xte2 - rv2(1, i)
                gd(2) = 0.D0
                g(2) = 0.
                gd(3) = 0.D0
                g(3) = 0.
              END IF
C
C---------- set total effective velocity = freestream + rotation
              CALL CROSS_D(rrot, rrotd, wrot, wrotd, vrot, vrotd)
              veffd(1) = vinfd(1) + vrotd(1)
              veff(1) = vinf(1) + vrot(1)
              veffd(2) = vinfd(2) + vrotd(2)
              veff(2) = vinf(2) + vrot(2)
              veffd(3) = vinfd(3) + vrotd(3)
              veff(3) = vinf(3) + vrot(3)
C
C---------- set VEFF sensitivities to freestream,rotation components
              DO k=1,3
                veff_ud(1, k) = 0.D0
                veff_u(1, k) = 0.
                veff_ud(2, k) = 0.D0
                veff_u(2, k) = 0.
                veff_ud(3, k) = 0.D0
                veff_u(3, k) = 0.
                veff_ud(k, k) = 0.D0
                veff_u(k, k) = 1.0
              ENDDO
              DO k=4,6
                wrot_u(1) = 0.
                wrot_u(2) = 0.
                wrot_u(3) = 0.
                wrot_u(k-3) = 1.0
                DO ii1=1,3
                  wrot_ud(ii1) = 0.D0
                ENDDO
                CALL CROSS_D(rrot, rrotd, wrot_u, wrot_ud, vrot_u, 
     +                       vrot_ud)
                veff_ud(1, k) = vrot_ud(1)
                veff_u(1, k) = vrot_u(1)
                veff_ud(2, k) = vrot_ud(2)
                veff_u(2, k) = vrot_u(2)
                veff_ud(3, k) = vrot_ud(3)
                veff_u(3, k) = vrot_u(3)
              ENDDO
C
C---------- Force coefficient on vortex segment is 2(Veff x Gamma)
              CALL CROSS_D(veff, veffd, g, gd, f, fd)
C
              DO n=1,numax
                CALL CROSS_D(veff_u(1, n), veff_ud(1, n), g, gd, f_u(1, 
     +                       n), f_ud(1, n))
              ENDDO
C
              fgamd(1) = 2.0*(f(1)*gamd(i)+gam(i)*fd(1))
              fgam(1) = 2.0*gam(i)*f(1)
              fgamd(2) = 2.0*(f(2)*gamd(i)+gam(i)*fd(2))
              fgam(2) = 2.0*gam(i)*f(2)
              fgamd(3) = 2.0*(f(3)*gamd(i)+gam(i)*fd(3))
              fgam(3) = 2.0*gam(i)*f(3)
              DO n=1,numax
                fgam_ud(1, n) = gam_u(i, n)*2.0*fd(1) + 2.0*(f_u(1, n)*
     +            gamd(i)+gam(i)*f_ud(1, n))
                fgam_u(1, n) = 2.0*gam_u(i, n)*f(1) + 2.0*gam(i)*f_u(1, 
     +            n)
                fgam_ud(2, n) = gam_u(i, n)*2.0*fd(2) + 2.0*(f_u(2, n)*
     +            gamd(i)+gam(i)*f_ud(2, n))
                fgam_u(2, n) = 2.0*gam_u(i, n)*f(2) + 2.0*gam(i)*f_u(2, 
     +            n)
                fgam_ud(3, n) = gam_u(i, n)*2.0*fd(3) + 2.0*(f_u(3, n)*
     +            gamd(i)+gam(i)*f_ud(3, n))
                fgam_u(3, n) = 2.0*gam_u(i, n)*f(3) + 2.0*gam(i)*f_u(3, 
     +            n)
              ENDDO
              DO n=1,ncontrol
                fgam_dd(1, n) = gam_d(i, n)*2.0*fd(1)
                fgam_d(1, n) = 2.0*gam_d(i, n)*f(1)
                fgam_dd(2, n) = gam_d(i, n)*2.0*fd(2)
                fgam_d(2, n) = 2.0*gam_d(i, n)*f(2)
                fgam_dd(3, n) = gam_d(i, n)*2.0*fd(3)
                fgam_d(3, n) = 2.0*gam_d(i, n)*f(3)
              ENDDO
              DO n=1,ndesign
                fgam_g(1, n) = 2.0*gam_g(i, n)*f(1)
                fgam_g(2, n) = 2.0*gam_g(i, n)*f(2)
                fgam_g(3, n) = 2.0*gam_g(i, n)*f(3)
              ENDDO
C
CC---------- Delta Cp (loading across lifting surface) due to vortex 
C            FNV = DOT(ENV(1,I),FGAM)
C            DCP(I) = FNV / (DXV(I)*WSTRIP(J))
CC
C            DO N = 1, NUMAX
C              FNV_U = DOT(ENV(1,I),FGAM_U(1,N))
C              DCP_U(I,N) = FNV_U / (DXV(I)*WSTRIP(J))
C            ENDDO
CC
C            DO N = 1, NCONTROL
C              FNV_D = DOT(ENV(1,I),FGAM_D(1,N)) + DOT(ENV_D(1,I,N),FGAM)
C              DCP_D(I,N) = FNV_D / (DXV(I)*WSTRIP(J))
C            ENDDO
CC
C            DO N = 1, NDESIGN
C              FNV_G = DOT(ENV(1,I),FGAM_G(1,N)) + DOT(ENV_G(1,I,N),FGAM)
C              DCP_G(I,N) = FNV_G / (DXV(I)*WSTRIP(J))
C            ENDDO
C
C
C---------- vortex contribution to strip forces
              temp = fgam(1)/sr
              dcfxd = (fgamd(1)-temp*srd)/sr
              dcfx = temp
              temp = fgam(2)/sr
              dcfyd = (fgamd(2)-temp*srd)/sr
              dcfy = temp
              temp = fgam(3)/sr
              dcfzd = (fgamd(3)-temp*srd)/sr
              dcfz = temp
C
C---------- forces normalized by strip area
              cfxd = cfxd + dcfxd
              cfx = cfx + dcfx
              cfyd = cfyd + dcfyd
              cfy = cfy + dcfy
              cfzd = cfzd + dcfzd
              cfz = cfz + dcfz
C
C---------- moments referred to strip c/4 pt., normalized by strip chord and area
              temp = (dcfz*r(2)-dcfy*r(3))/cr
              cmxd = cmxd + (r(2)*dcfzd+dcfz*rd(2)-r(3)*dcfyd-dcfy*rd(3)
     +          -temp*crd)/cr
              cmx = cmx + temp
              temp = (dcfx*r(3)-dcfz*r(1))/cr
              cmyd = cmyd + (r(3)*dcfxd+dcfx*rd(3)-r(1)*dcfzd-dcfz*rd(1)
     +          -temp*crd)/cr
              cmy = cmy + temp
              temp = (dcfy*r(1)-dcfx*r(2))/cr
              cmzd = cmzd + (r(1)*dcfyd+dcfy*rd(1)-r(2)*dcfxd-dcfx*rd(2)
     +          -temp*crd)/cr
              cmz = cmz + temp
C
C---------- accumulate strip spanloading = c*CN
              cnc(j) = cnc(j) + cr*(ensy(j)*dcfy+ensz(j)*dcfz)
C
C---------- freestream and rotation derivatives
              DO n=1,numax
                temp = fgam_u(1, n)/sr
                dcfx_ud = (fgam_ud(1, n)-temp*srd)/sr
                dcfx_u = temp
                temp = fgam_u(2, n)/sr
                dcfy_ud = (fgam_ud(2, n)-temp*srd)/sr
                dcfy_u = temp
                temp = fgam_u(3, n)/sr
                dcfz_ud = (fgam_ud(3, n)-temp*srd)/sr
                dcfz_u = temp
C
                cfx_ud(n) = cfx_ud(n) + dcfx_ud
                cfx_u(n) = cfx_u(n) + dcfx_u
                cfy_ud(n) = cfy_ud(n) + dcfy_ud
                cfy_u(n) = cfy_u(n) + dcfy_u
                cfz_ud(n) = cfz_ud(n) + dcfz_ud
                cfz_u(n) = cfz_u(n) + dcfz_u
                temp = (dcfz_u*r(2)-dcfy_u*r(3))/cr
                cmx_ud(n) = cmx_ud(n) + (r(2)*dcfz_ud+dcfz_u*rd(2)-r(3)*
     +            dcfy_ud-dcfy_u*rd(3)-temp*crd)/cr
                cmx_u(n) = cmx_u(n) + temp
                temp = (dcfx_u*r(3)-dcfz_u*r(1))/cr
                cmy_ud(n) = cmy_ud(n) + (r(3)*dcfx_ud+dcfx_u*rd(3)-r(1)*
     +            dcfz_ud-dcfz_u*rd(1)-temp*crd)/cr
                cmy_u(n) = cmy_u(n) + temp
                temp = (dcfy_u*r(1)-dcfx_u*r(2))/cr
                cmz_ud(n) = cmz_ud(n) + (r(1)*dcfy_ud+dcfy_u*rd(1)-r(2)*
     +            dcfx_ud-dcfx_u*rd(2)-temp*crd)/cr
                cmz_u(n) = cmz_u(n) + temp
C
                cnc_u(j, n) = cnc_u(j, n) + cr*(ensy(j)*dcfy_u+ensz(j)*
     +            dcfz_u)
              ENDDO
C
C---------- control derivatives
              DO n=1,ncontrol
                temp = fgam_d(1, n)/sr
                dcfx_dd = (fgam_dd(1, n)-temp*srd)/sr
                dcfx_d = temp
                temp = fgam_d(2, n)/sr
                dcfy_dd = (fgam_dd(2, n)-temp*srd)/sr
                dcfy_d = temp
                temp = fgam_d(3, n)/sr
                dcfz_dd = (fgam_dd(3, n)-temp*srd)/sr
                dcfz_d = temp
C  
                cfx_dd(n) = cfx_dd(n) + dcfx_dd
                cfx_d(n) = cfx_d(n) + dcfx_d
                cfy_dd(n) = cfy_dd(n) + dcfy_dd
                cfy_d(n) = cfy_d(n) + dcfy_d
                cfz_dd(n) = cfz_dd(n) + dcfz_dd
                cfz_d(n) = cfz_d(n) + dcfz_d
                temp = (dcfz_d*r(2)-dcfy_d*r(3))/cr
                cmx_dd(n) = cmx_dd(n) + (r(2)*dcfz_dd+dcfz_d*rd(2)-r(3)*
     +            dcfy_dd-dcfy_d*rd(3)-temp*crd)/cr
                cmx_d(n) = cmx_d(n) + temp
                temp = (dcfx_d*r(3)-dcfz_d*r(1))/cr
                cmy_dd(n) = cmy_dd(n) + (r(3)*dcfx_dd+dcfx_d*rd(3)-r(1)*
     +            dcfz_dd-dcfz_d*rd(1)-temp*crd)/cr
                cmy_d(n) = cmy_d(n) + temp
                temp = (dcfy_d*r(1)-dcfx_d*r(2))/cr
                cmz_dd(n) = cmz_dd(n) + (r(1)*dcfy_dd+dcfy_d*rd(1)-r(2)*
     +            dcfx_dd-dcfx_d*rd(2)-temp*crd)/cr
                cmz_d(n) = cmz_d(n) + temp
C  
                cnc_d(j, n) = cnc_d(j, n) + cr*(ensy(j)*dcfy_d+ensz(j)*
     +            dcfz_d)
              ENDDO
C
C---------- design derivatives
              DO n=1,ndesign
                dcfx_g = fgam_g(1, n)/sr
                dcfy_g = fgam_g(2, n)/sr
                dcfz_g = fgam_g(3, n)/sr
C
                cfx_g(n) = cfx_g(n) + dcfx_g
                cfy_g(n) = cfy_g(n) + dcfy_g
                cfz_g(n) = cfz_g(n) + dcfz_g
                cmx_g(n) = cmx_g(n) + (dcfz_g*r(2)-dcfy_g*r(3))/cr
                cmy_g(n) = cmy_g(n) + (dcfx_g*r(3)-dcfz_g*r(1))/cr
                cmz_g(n) = cmz_g(n) + (dcfy_g*r(1)-dcfx_g*r(2))/cr
C
                cnc_g(j, n) = cnc_g(j, n) + cr*(ensy(j)*dcfy_g+ensz(j)*
     +            dcfz_g)
              ENDDO
            ENDDO
          ENDDO
        END IF
C
CC---------- hinge moments
C            DO L=1, NCONTROL
C              RH(1) = RV(1,I) - PHINGE(1,J,L)
C              RH(2) = RV(2,I) - PHINGE(2,J,L)
C              RH(3) = RV(3,I) - PHINGE(3,J,L)
CC
C              DFAC = DCONTROL(I,L) / (SREF * CREF)
CC
C              CALL CROSS(RH,FGAM,MH)
C              CHINGE(L) = CHINGE(L) + DOT(MH,VHINGE(1,J,L))*DFAC
CC
C              DO N = 1, NUMAX
C                CALL CROSS(RH,FGAM_U(1,N),MH)
C                CHINGE_U(L,N) = CHINGE_U(L,N) + DOT(MH,VHINGE(1,J,L))*DFAC
C              ENDDO
C              DO N = 1, NCONTROL
C                CALL CROSS(RH,FGAM_D(1,N),MH)
C                CHINGE_D(L,N) = CHINGE_D(L,N) + DOT(MH,VHINGE(1,J,L))*DFAC
C              ENDDO
C              DO N = 1, NDESIGN
C                CALL CROSS(RH,FGAM_G(1,N),MH)
C                CHINGE_G(L,N) = CHINGE_G(L,N) + DOT(MH,VHINGE(1,J,L))*DFAC
C              ENDDO
C            ENDDO
C
C
C
C*******************************************************************
C--- Drag terms due to viscous effects
C    Drag forces are assumed to be characterized by velocity at the c/4 
C    point and are assumed to act thru the same point. CD is defined by 
C    user-specified CD(CL) polar.  Drag comes from function lookup on 
C    section polar drag using local lift coefficient.  
C
        cdv_lstrp(j) = 0.0
C
        IF (lvisc .AND. lviscstrp(j)) THEN
C--- local moment reference vector from ref point to c/4 point
C         R(1) = XR - XR
C         R(2) = YR - YR
C         R(3) = ZR - ZR
C--- Get rotational velocity at strip 1/4 chord reference point 
          rrotd(1) = xrd - xyzrefd(1)
          rrot(1) = xr - xyzref(1)
          rrotd(2) = yrd - xyzrefd(2)
          rrot(2) = yr - xyzref(2)
          rrotd(3) = zrd - xyzrefd(3)
          rrot(3) = zr - xyzref(3)
C--- Onset velocity at strip c/4 = freestream + rotation
          CALL CROSS_D(rrot, rrotd, wrot, wrotd, vrot, vrotd)
          veffd(1) = vinfd(1) + vrotd(1)
          veff(1) = vinf(1) + vrot(1)
          veffd(2) = vinfd(2) + vrotd(2)
          veff(2) = vinf(2) + vrot(2)
          veffd(3) = vinfd(3) + vrotd(3)
          veff(3) = vinf(3) + vrot(3)
          arg1d = 2*veff(1)*veffd(1) + 2*veff(2)*veffd(2) + 2*veff(3)*
     +      veffd(3)
          arg1 = veff(1)**2 + veff(2)**2 + veff(3)**2
          temp = SQRT(arg1)
          IF (arg1 .EQ. 0.D0) THEN
            veffmagd = 0.D0
          ELSE
            veffmagd = arg1d/(2.0*temp)
          END IF
          veffmag = temp
C
C------- set sensitivities to freestream,rotation components
          DO k=1,3
            veff_ud(1, k) = 0.D0
            veff_u(1, k) = 0.
            veff_ud(2, k) = 0.D0
            veff_u(2, k) = 0.
            veff_ud(3, k) = 0.D0
            veff_u(3, k) = 0.
          ENDDO
          veff_ud(1, 1) = 0.D0
          veff_u(1, 1) = 1.0
          veff_ud(2, 2) = 0.D0
          veff_u(2, 2) = 1.0
          veff_ud(3, 3) = 0.D0
          veff_u(3, 3) = 1.0
          DO k=4,6
            wrot_u(1) = 0.
            wrot_u(2) = 0.
            wrot_u(3) = 0.
            wrot_u(k-3) = 1.0
            DO ii1=1,3
              wrot_ud(ii1) = 0.D0
            ENDDO
            CALL CROSS_D(rrot, rrotd, wrot_u, wrot_ud, vrot_u, vrot_ud)
            veff_ud(1, k) = vrot_ud(1)
            veff_u(1, k) = vrot_u(1)
            veff_ud(2, k) = vrot_ud(2)
            veff_u(2, k) = vrot_u(2)
            veff_ud(3, k) = vrot_ud(3)
            veff_u(3, k) = vrot_u(3)
          ENDDO
C
C--- Generate CD from stored function using strip CL as parameter
          clvd = cfx*uliftd(1) + ulift(1)*cfxd + cfy*uliftd(2) + ulift(2
     +      )*cfyd + cfz*uliftd(3) + ulift(3)*cfzd
          clv = ulift(1)*cfx + ulift(2)*cfy + ulift(3)*cfz
          DO n=1,numax
            temp = cfz_u(n)*cosa - cfx_u(n)*sina
            clv_ud(n) = cfy_u(n)*ensyd(j) + ensy(j)*cfy_ud(n) + temp*
     +        enszd(j) + ensz(j)*(cosa*cfz_ud(n)+cfz_u(n)*cosad-sina*
     +        cfx_ud(n)-cfx_u(n)*sinad)
            clv_u(n) = ensy(j)*cfy_u(n) + ensz(j)*temp
          ENDDO
C
          DO n=1,ncontrol
            temp = cfz_d(n)*cosa - cfx_d(n)*sina
            clv_dd(n) = cfy_d(n)*ensyd(j) + ensy(j)*cfy_dd(n) + temp*
     +        enszd(j) + ensz(j)*(cosa*cfz_dd(n)+cfz_d(n)*cosad-sina*
     +        cfx_dd(n)-cfx_d(n)*sinad)
            clv_d(n) = ensy(j)*cfy_d(n) + ensz(j)*temp
          ENDDO
C
          DO n=1,ndesign
            clv_g(n) = ensy(j)*cfy_g(n) + ensz(j)*(cfz_g(n)*cosa-cfx_g(n
     +        )*sina)
          ENDDO
C
          CALL CDCL_D(j, clv, clvd, cdv, cdvd, cdv_clv, cdv_clvd)
C
C--- Strip viscous force contribution (per unit strip area)
          dcvfxd = veffmag*cdv*veffd(1) + veff(1)*(cdv*veffmagd+veffmag*
     +      cdvd)
          dcvfx = veff(1)*veffmag*cdv
          dcvfyd = veffmag*cdv*veffd(2) + veff(2)*(cdv*veffmagd+veffmag*
     +      cdvd)
          dcvfy = veff(2)*veffmag*cdv
          dcvfzd = veffmag*cdv*veffd(3) + veff(3)*(cdv*veffmagd+veffmag*
     +      cdvd)
          dcvfz = veff(3)*veffmag*cdv
C
C--- Add viscous terms to strip forces and moments
          cfxd = cfxd + dcvfxd
          cfx = cfx + dcvfx
          cfyd = cfyd + dcvfyd
          cfy = cfy + dcvfy
          cfzd = cfzd + dcvfzd
          cfz = cfz + dcvfz
C--- Viscous forces acting at c/4 have no effect on moments at c/4 pt.
C         CMX = CMX + (DCVFZ*R(2) - DCVFY*R(3))/CR
C         CMY = CMY + (DCVFX*R(3) - DCVFZ*R(1))/CR
C         CMZ = CMZ + (DCVFY*R(1) - DCVFX*R(2))/CR
C
          cdv_lstrp(j) = udrag(1)*dcvfx + udrag(2)*dcvfy + udrag(3)*
     +      dcvfz
C
C--- Add the sensitivity of viscous forces to the flow conditions
          DO n=1,numax
            temp = veff(1)*veff(1)/veffmag
            temp0 = veff_u(1, n)*cdv
            temp1 = veff(1)*clv_u(n)
            dcvfx_ud = (veffmag+temp)*(cdv*veff_ud(1, n)+veff_u(1, n)*
     +        cdvd) + temp0*(veffmagd+(2*veff(1)*veffd(1)-temp*veffmagd)
     +        /veffmag) + temp1*(cdv_clv*veffmagd+veffmag*cdv_clvd) + 
     +        veffmag*cdv_clv*(clv_u(n)*veffd(1)+veff(1)*clv_ud(n))
            dcvfx_u = temp0*(veffmag+temp) + veffmag*cdv_clv*temp1
            temp1 = veff(2)*veff(2)/veffmag
            temp0 = veff_u(2, n)*cdv
            temp = veff(2)*clv_u(n)
            dcvfy_ud = (veffmag+temp1)*(cdv*veff_ud(2, n)+veff_u(2, n)*
     +        cdvd) + temp0*(veffmagd+(2*veff(2)*veffd(2)-temp1*veffmagd
     +        )/veffmag) + temp*(cdv_clv*veffmagd+veffmag*cdv_clvd) + 
     +        veffmag*cdv_clv*(clv_u(n)*veffd(2)+veff(2)*clv_ud(n))
            dcvfy_u = temp0*(veffmag+temp1) + veffmag*cdv_clv*temp
            temp1 = veff(3)*veff(3)/veffmag
            temp0 = veff_u(3, n)*cdv
            temp = veff(3)*clv_u(n)
            dcvfz_ud = (veffmag+temp1)*(cdv*veff_ud(3, n)+veff_u(3, n)*
     +        cdvd) + temp0*(veffmagd+(2*veff(3)*veffd(3)-temp1*veffmagd
     +        )/veffmag) + temp*(cdv_clv*veffmagd+veffmag*cdv_clvd) + 
     +        veffmag*cdv_clv*(clv_u(n)*veffd(3)+veff(3)*clv_ud(n))
            dcvfz_u = temp0*(veffmag+temp1) + veffmag*cdv_clv*temp
C
            cfx_ud(n) = cfx_ud(n) + dcvfx_ud
            cfx_u(n) = cfx_u(n) + dcvfx_u
            cfy_ud(n) = cfy_ud(n) + dcvfy_ud
            cfy_u(n) = cfy_u(n) + dcvfy_u
            cfz_ud(n) = cfz_ud(n) + dcvfz_ud
            cfz_u(n) = cfz_u(n) + dcvfz_u
C--- Viscous forces acting at c/4 have no effect on moments at c/4 pt.
C           CMX_U(N) = CMX_U(N) + (DCVFZ_U*R(2) - DCVFY_U*R(3))/CR
C           CMY_U(N) = CMY_U(N) + (DCVFX_U*R(3) - DCVFZ_U*R(1))/CR
C           CMZ_U(N) = CMZ_U(N) + (DCVFY_U*R(1) - DCVFX_U*R(2))/CR
C
            cnc_u(j, n) = cnc_u(j, n) + cr*(ensy(j)*dcvfy_u+ensz(j)*
     +        dcvfz_u)
          ENDDO
C
          DO n=1,ncontrol
            temp1 = veff(1)*clv_d(n)
            dcvfx_dd = temp1*(cdv_clv*veffmagd+veffmag*cdv_clvd) + 
     +        veffmag*cdv_clv*(clv_d(n)*veffd(1)+veff(1)*clv_dd(n))
            dcvfx_d = veffmag*cdv_clv*temp1
            temp1 = veff(2)*clv_d(n)
            dcvfy_dd = temp1*(cdv_clv*veffmagd+veffmag*cdv_clvd) + 
     +        veffmag*cdv_clv*(clv_d(n)*veffd(2)+veff(2)*clv_dd(n))
            dcvfy_d = veffmag*cdv_clv*temp1
            temp1 = veff(3)*clv_d(n)
            dcvfz_dd = temp1*(cdv_clv*veffmagd+veffmag*cdv_clvd) + 
     +        veffmag*cdv_clv*(clv_d(n)*veffd(3)+veff(3)*clv_dd(n))
            dcvfz_d = veffmag*cdv_clv*temp1
C
            cfx_dd(n) = cfx_dd(n) + dcvfx_dd
            cfx_d(n) = cfx_d(n) + dcvfx_d
            cfy_dd(n) = cfy_dd(n) + dcvfy_dd
            cfy_d(n) = cfy_d(n) + dcvfy_d
            cfz_dd(n) = cfz_dd(n) + dcvfz_dd
            cfz_d(n) = cfz_d(n) + dcvfz_d
C--- Viscous forces acting at c/4 have no effect on moments at c/4 pt.
C           CMX_D(N) = CMX_D(N) + (DCVFZ_D*R(2) - DCVFY_D*R(3))/CR
C           CMY_D(N) = CMY_D(N) + (DCVFX_D*R(3) - DCVFZ_D*R(1))/CR
C           CMZ_D(N) = CMZ_D(N) + (DCVFY_D*R(1) - DCVFX_D*R(2))/CR
C
            cnc_d(j, n) = cnc_d(j, n) + cr*(ensy(j)*dcvfy_d+ensz(j)*
     +        dcvfz_d)
          ENDDO
C
          DO n=1,ndesign
            dcvfx_g = veff(1)*veffmag*cdv_clv*clv_g(n)
            dcvfy_g = veff(2)*veffmag*cdv_clv*clv_g(n)
            dcvfz_g = veff(3)*veffmag*cdv_clv*clv_g(n)
C
            cfx_g(n) = cfx_g(n) + dcvfx_g
            cfy_g(n) = cfy_g(n) + dcvfy_g
            cfz_g(n) = cfz_g(n) + dcvfz_g
C--- Viscous forces acting at c/4 have no effect on moments at c/4 pt.
C           CMX_G(N) = CMX_G(N) + (DCVFZ_G*R(2) - DCVFY_G*R(3))/CR
C           CMY_G(N) = CMY_G(N) + (DCVFX_G*R(3) - DCVFZ_G*R(1))/CR
C           CMZ_G(N) = CMZ_G(N) + (DCVFY_G*R(1) - DCVFX_G*R(2))/CR
C
            cnc_g(j, n) = cnc_g(j, n) + cr*(ensy(j)*dcvfy_g+ensz(j)*
     +        dcvfz_g)
          ENDDO
        END IF
C
C
C*******************************************************************
C
C...Store strip X,Y,Z body axes forces 
C   (these are normalized by strip area and moments are referred to
C    c/4 point and are normalized by strip chord and area)
        cf_strp(1, j) = cfx
        cf_strp(2, j) = cfy
        cf_strp(3, j) = cfz
        cm_strp(1, j) = cmx
        cm_strp(2, j) = cmy
        cm_strp(3, j) = cmz
C
C...Transform strip body axes forces into stability axes
        cdstrp(j) = cfx*cosa + cfz*sina
        clstrpd(j) = cosa*cfzd + cfz*cosad - sina*cfxd - cfx*sinad
        clstrp(j) = -(cfx*sina) + cfz*cosa
        cxstrp(j) = cfx
        cystrpd(j) = cfyd
        cystrp(j) = cfy
        czstrp(j) = cfz
C
        cdst_a(j) = -(cfx*sina) + cfz*cosa
        clst_ad(j) = -(cosa*cfxd) - cfx*cosad - sina*cfzd - cfz*sinad
        clst_a(j) = -(cfx*cosa) - cfz*sina
C
        DO n=1,numax
          cdst_u(j, n) = cfx_u(n)*cosa + cfz_u(n)*sina
          clst_ud(j, n) = cosa*cfz_ud(n) + cfz_u(n)*cosad - sina*cfx_ud(
     +      n) - cfx_u(n)*sinad
          clst_u(j, n) = -(cfx_u(n)*sina) + cfz_u(n)*cosa
          cxst_u(j, n) = cfx_u(n)
          cyst_ud(j, n) = cfy_ud(n)
          cyst_u(j, n) = cfy_u(n)
          czst_u(j, n) = cfz_u(n)
        ENDDO
C
        DO n=1,ncontrol
          cdst_d(j, n) = cfx_d(n)*cosa + cfz_d(n)*sina
          clst_dd(j, n) = cosa*cfz_dd(n) + cfz_d(n)*cosad - sina*cfx_dd(
     +      n) - cfx_d(n)*sinad
          clst_d(j, n) = -(cfx_d(n)*sina) + cfz_d(n)*cosa
          cxst_d(j, n) = cfx_d(n)
          cyst_dd(j, n) = cfy_dd(n)
          cyst_d(j, n) = cfy_d(n)
          czst_d(j, n) = cfz_d(n)
        ENDDO
C
        DO n=1,ndesign
          cdst_g(j, n) = cfx_g(n)*cosa + cfz_g(n)*sina
          clst_g(j, n) = -(cfx_g(n)*sina) + cfz_g(n)*cosa
          cxst_g(j, n) = cfx_g(n)
          cyst_g(j, n) = cfy_g(n)
          czst_g(j, n) = cfz_g(n)
        ENDDO
C
C... Set strip moments about the overall moment reference point XYZREF 
C     (still normalized by strip area and chord)
        rd(1) = xrd - xyzrefd(1)
        r(1) = xr - xyzref(1)
        rd(2) = yrd - xyzrefd(2)
        r(2) = yr - xyzref(2)
        rd(3) = zrd - xyzrefd(3)
        r(3) = zr - xyzref(3)
        temp1 = (cfz*r(2)-cfy*r(3))/cr
        crstrpd(j) = cmxd + (r(2)*cfzd+cfz*rd(2)-r(3)*cfyd-cfy*rd(3)-
     +    temp1*crd)/cr
        crstrp(j) = cmx + temp1
        temp1 = (cfx*r(3)-cfz*r(1))/cr
        cmstrpd(j) = cmyd + (r(3)*cfxd+cfx*rd(3)-r(1)*cfzd-cfz*rd(1)-
     +    temp1*crd)/cr
        cmstrp(j) = cmy + temp1
        temp1 = (cfy*r(1)-cfx*r(2))/cr
        cnstrpd(j) = cmzd + (r(1)*cfyd+cfy*rd(1)-r(2)*cfxd-cfx*rd(2)-
     +    temp1*crd)/cr
        cnstrp(j) = cmz + temp1
C
        DO n=1,numax
          temp1 = (cfz_u(n)*r(2)-cfy_u(n)*r(3))/cr
          crst_ud(j, n) = cmx_ud(n) + (r(2)*cfz_ud(n)+cfz_u(n)*rd(2)-r(3
     +      )*cfy_ud(n)-cfy_u(n)*rd(3)-temp1*crd)/cr
          crst_u(j, n) = cmx_u(n) + temp1
          temp1 = (cfx_u(n)*r(3)-cfz_u(n)*r(1))/cr
          cmst_ud(j, n) = cmy_ud(n) + (r(3)*cfx_ud(n)+cfx_u(n)*rd(3)-r(1
     +      )*cfz_ud(n)-cfz_u(n)*rd(1)-temp1*crd)/cr
          cmst_u(j, n) = cmy_u(n) + temp1
          temp1 = (cfy_u(n)*r(1)-cfx_u(n)*r(2))/cr
          cnst_ud(j, n) = cmz_ud(n) + (r(1)*cfy_ud(n)+cfy_u(n)*rd(1)-r(2
     +      )*cfx_ud(n)-cfx_u(n)*rd(2)-temp1*crd)/cr
          cnst_u(j, n) = cmz_u(n) + temp1
        ENDDO
C
        DO n=1,ncontrol
          temp1 = (cfz_d(n)*r(2)-cfy_d(n)*r(3))/cr
          crst_dd(j, n) = cmx_dd(n) + (r(2)*cfz_dd(n)+cfz_d(n)*rd(2)-r(3
     +      )*cfy_dd(n)-cfy_d(n)*rd(3)-temp1*crd)/cr
          crst_d(j, n) = cmx_d(n) + temp1
          temp1 = (cfx_d(n)*r(3)-cfz_d(n)*r(1))/cr
          cmst_dd(j, n) = cmy_dd(n) + (r(3)*cfx_dd(n)+cfx_d(n)*rd(3)-r(1
     +      )*cfz_dd(n)-cfz_d(n)*rd(1)-temp1*crd)/cr
          cmst_d(j, n) = cmy_d(n) + temp1
          temp1 = (cfy_d(n)*r(1)-cfx_d(n)*r(2))/cr
          cnst_dd(j, n) = cmz_dd(n) + (r(1)*cfy_dd(n)+cfy_d(n)*rd(1)-r(2
     +      )*cfx_dd(n)-cfx_d(n)*rd(2)-temp1*crd)/cr
          cnst_d(j, n) = cmz_d(n) + temp1
        ENDDO
C
        DO n=1,ndesign
          crst_g(j, n) = cmx_g(n) + (cfz_g(n)*r(2)-cfy_g(n)*r(3))/cr
          cmst_g(j, n) = cmy_g(n) + (cfx_g(n)*r(3)-cfz_g(n)*r(1))/cr
          cnst_g(j, n) = cmz_g(n) + (cfy_g(n)*r(1)-cfx_g(n)*r(2))/cr
        ENDDO
C
C...Take components of X,Y,Z forces in local strip axes 
C   (axial/normal and lift/drag)
C    in plane normal to (possibly dihedralled) strip
        cl_lstrp(j) = ulift(1)*cfx + ulift(2)*cfy + ulift(3)*cfz
        cd_lstrp(j) = udrag(1)*cfx + udrag(2)*cfy + udrag(3)*cfz
        caxlstrp(j) = cfx
        cnrmstrp(j) = ensy(j)*cfy + ensz(j)*cfz
        cmc4(j) = ensz(j)*cmy - ensy(j)*cmz
C
C------ vector at chord reference point from rotation axes
        rrotd(1) = -xyzrefd(1)
        rrot(1) = xsref(j) - xyzref(1)
        rrotd(2) = -xyzrefd(2)
        rrot(2) = ysref(j) - xyzref(2)
        rrotd(3) = -xyzrefd(3)
        rrot(3) = zsref(j) - xyzref(3)
C
C------ set total effective velocity = freestream + rotation
        CALL CROSS_D(rrot, rrotd, wrot, wrotd, vrot, vrotd)
        veffd(1) = vinfd(1) + vrotd(1)
        veff(1) = vinf(1) + vrot(1)
        veffd(2) = vinfd(2) + vrotd(2)
        veff(2) = vinf(2) + vrot(2)
        veffd(3) = vinfd(3) + vrotd(3)
        veff(3) = vinf(3) + vrot(3)
C
        vsq = veff(1)**2 + veff(2)**2 + veff(3)**2
        IF (vsq .EQ. 0.0) THEN
          vsqi = 1.0
        ELSE
          vsqi = 1.0/vsq
        END IF
C
C------ spanwise and perpendicular velocity components
        vspan = veff(1)*ess(1, j) + veff(2)*ess(2, j) + veff(3)*ess(3, j
     +    )
        vperp(1) = veff(1) - ess(1, j)*vspan
        vperp(2) = veff(2) - ess(2, j)*vspan
        vperp(3) = veff(3) - ess(3, j)*vspan
C
        vpsq = vperp(1)**2 + vperp(2)**2 + vperp(3)**2
        IF (vpsq .EQ. 0.0) THEN
          vpsqi = 1.0
        ELSE
          vpsqi = 1.0/vpsq
        END IF
Ccc     CLTSTRP(J) = CNRMSTRP(J) * VPSQI
        cltstrp(j) = cl_lstrp(j)*vpsqi
        clastrp(j) = cl_lstrp(j)*vsqi
C
C--- Moment about strip LE midpoint in direction of LE segment
        rd(1) = xrd - rled(1, j)
        r(1) = xr - rle(1, j)
        rd(2) = yrd - rled(2, j)
        r(2) = yr - rle(2, j)
        rd(3) = zrd - rled(3, j)
        r(3) = zr - rle(3, j)
        delx = rle2(1, j) - rle1(1, j)
        dely = rle2(2, j) - rle1(2, j)
        delz = rle2(3, j) - rle1(3, j)
C
        IF (imags(nsurfs(j)) .LT. 0) THEN
          delx = -delx
          dely = -dely
          delz = -delz
        END IF
        arg1 = delx**2 + dely**2 + delz**2
        dmag = SQRT(arg1)
        cmle(j) = 0.0
        IF (dmag .NE. 0.0) cmle(j) = delx/dmag*(cmx+(cfz*r(2)-cfy*r(3))/
     +      cr) + dely/dmag*(cmy+(cfx*r(3)-cfz*r(1))/cr) + delz/dmag*(
     +      cmz+(cfy*r(1)-cfx*r(2))/cr)
      ENDDO
      cltotd = 0.D0
      cytotd = 0.D0
      crtotd = 0.D0
      cmtotd = 0.D0
      cntotd = 0.D0
      cltot_ad = 0.D0
C
C
C
C
C...Surface forces and moments summed from strip forces...
C   XXSURF values normalized to configuration reference quantities
C   XX_SRF values normalized to each surface reference quantities
      DO is=1,nsurf
        cdsurf(is) = 0.
        clsurfd(is) = 0.D0
        clsurf(is) = 0.
        cxsurf(is) = 0.
        cysurfd(is) = 0.D0
        cysurf(is) = 0.
        czsurf(is) = 0.
        crsurfd(is) = 0.D0
        crsurf(is) = 0.
        cmsurfd(is) = 0.D0
        cmsurf(is) = 0.
        cnsurfd(is) = 0.D0
        cnsurf(is) = 0.
        cdvsurf(is) = 0.
C
        cds_a(is) = 0.
        cls_ad(is) = 0.D0
        cls_a(is) = 0.
        DO n=1,numax
          cds_u(is, n) = 0.
          cls_ud(is, n) = 0.D0
          cls_u(is, n) = 0.
          cxs_u(is, n) = 0.
          cys_ud(is, n) = 0.D0
          cys_u(is, n) = 0.
          czs_u(is, n) = 0.
          crs_ud(is, n) = 0.D0
          crs_u(is, n) = 0.
          cms_ud(is, n) = 0.D0
          cms_u(is, n) = 0.
          cns_ud(is, n) = 0.D0
          cns_u(is, n) = 0.
        ENDDO
        DO n=1,ncontrol
          cds_d(is, n) = 0.
          cls_dd(is, n) = 0.D0
          cls_d(is, n) = 0.
          cxs_d(is, n) = 0.
          cys_dd(is, n) = 0.D0
          cys_d(is, n) = 0.
          czs_d(is, n) = 0.
          crs_dd(is, n) = 0.D0
          crs_d(is, n) = 0.
          cms_dd(is, n) = 0.D0
          cms_d(is, n) = 0.
          cns_dd(is, n) = 0.D0
          cns_d(is, n) = 0.
        ENDDO
        DO n=1,ndesign
          cds_g(is, n) = 0.
          cls_g(is, n) = 0.
          cxs_g(is, n) = 0.
          cys_g(is, n) = 0.
          czs_g(is, n) = 0.
          crs_g(is, n) = 0.
          cms_g(is, n) = 0.
          cns_g(is, n) = 0.
        ENDDO
C
C--- Surface body axes forces and moments
        DO l=1,3
          cf_srf(l, is) = 0.0
          cm_srf(l, is) = 0.0
          enave(l) = 0.0
        ENDDO
C
        nstrps = nj(is)
        DO jj=1,nstrps
          j = jfrst(is) + jj - 1
          srd = wstrip(j)*chordd(j) + chord(j)*wstripd(j)
          sr = chord(j)*wstrip(j)
          crd = chordd(j)
          cr = chord(j)
          xr = rle(1, j) + 0.25*chord(j)
          yr = rle(2, j)
          zr = rle(3, j)
C
          enave(1) = 0.0
          enave(2) = enave(2) + sr*ensy(j)
          enave(3) = enave(3) + sr*ensz(j)
C
          cdsurf(is) = cdsurf(is) + cdstrp(j)*sr/sref
          clsurfd(is) = clsurfd(is) + sr*clstrpd(j)/sref + clstrp(j)*srd
     +      /sref
          clsurf(is) = clsurf(is) + clstrp(j)*sr/sref
C
          cxsurf(is) = cxsurf(is) + cxstrp(j)*sr/sref
          cysurfd(is) = cysurfd(is) + sr*cystrpd(j)/sref + cystrp(j)*srd
     +      /sref
          cysurf(is) = cysurf(is) + cystrp(j)*sr/sref
          czsurf(is) = czsurf(is) + czstrp(j)*sr/sref
C
          crsurfd(is) = crsurfd(is) + (sr*cr*crstrpd(j)+crstrp(j)*(cr*
     +      srd+sr*crd))/(sref*bref)
          crsurf(is) = crsurf(is) + crstrp(j)*(sr/sref)*(cr/bref)
          cmsurfd(is) = cmsurfd(is) + (sr*cr*cmstrpd(j)+cmstrp(j)*(cr*
     +      srd+sr*crd))/(sref*cref)
          cmsurf(is) = cmsurf(is) + cmstrp(j)*(sr/sref)*(cr/cref)
          cnsurfd(is) = cnsurfd(is) + (sr*cr*cnstrpd(j)+cnstrp(j)*(cr*
     +      srd+sr*crd))/(sref*bref)
          cnsurf(is) = cnsurf(is) + cnstrp(j)*(sr/sref)*(cr/bref)
C
C--- Bug fix, HHY/S.Allmaras 
          cdvsurf(is) = cdvsurf(is) + cdv_lstrp(j)*(sr/sref)
C
          cds_a(is) = cds_a(is) + cdst_a(j)*sr/sref
          cls_ad(is) = cls_ad(is) + sr*clst_ad(j)/sref + clst_a(j)*srd/
     +      sref
          cls_a(is) = cls_a(is) + clst_a(j)*sr/sref
C
          DO n=1,numax
            cds_u(is, n) = cds_u(is, n) + cdst_u(j, n)*sr/sref
            cls_ud(is, n) = cls_ud(is, n) + sr*clst_ud(j, n)/sref + 
     +        clst_u(j, n)*srd/sref
            cls_u(is, n) = cls_u(is, n) + clst_u(j, n)*sr/sref
C
            cxs_u(is, n) = cxs_u(is, n) + cxst_u(j, n)*sr/sref
            cys_ud(is, n) = cys_ud(is, n) + sr*cyst_ud(j, n)/sref + 
     +        cyst_u(j, n)*srd/sref
            cys_u(is, n) = cys_u(is, n) + cyst_u(j, n)*sr/sref
            czs_u(is, n) = czs_u(is, n) + czst_u(j, n)*sr/sref
C
            crs_ud(is, n) = crs_ud(is, n) + (sr*cr*crst_ud(j, n)+crst_u(
     +        j, n)*(cr*srd+sr*crd))/(sref*bref)
            crs_u(is, n) = crs_u(is, n) + crst_u(j, n)*(sr/sref)*(cr/
     +        bref)
            cms_ud(is, n) = cms_ud(is, n) + (sr*cr*cmst_ud(j, n)+cmst_u(
     +        j, n)*(cr*srd+sr*crd))/(sref*cref)
            cms_u(is, n) = cms_u(is, n) + cmst_u(j, n)*(sr/sref)*(cr/
     +        cref)
            cns_ud(is, n) = cns_ud(is, n) + (sr*cr*cnst_ud(j, n)+cnst_u(
     +        j, n)*(cr*srd+sr*crd))/(sref*bref)
            cns_u(is, n) = cns_u(is, n) + cnst_u(j, n)*(sr/sref)*(cr/
     +        bref)
          ENDDO
C
          DO n=1,ncontrol
            cds_d(is, n) = cds_d(is, n) + cdst_d(j, n)*sr/sref
            cls_dd(is, n) = cls_dd(is, n) + sr*clst_dd(j, n)/sref + 
     +        clst_d(j, n)*srd/sref
            cls_d(is, n) = cls_d(is, n) + clst_d(j, n)*sr/sref
C
            cxs_d(is, n) = cxs_d(is, n) + cxst_d(j, n)*sr/sref
            cys_dd(is, n) = cys_dd(is, n) + sr*cyst_dd(j, n)/sref + 
     +        cyst_d(j, n)*srd/sref
            cys_d(is, n) = cys_d(is, n) + cyst_d(j, n)*sr/sref
            czs_d(is, n) = czs_d(is, n) + czst_d(j, n)*sr/sref
C
            crs_dd(is, n) = crs_dd(is, n) + (sr*cr*crst_dd(j, n)+crst_d(
     +        j, n)*(cr*srd+sr*crd))/(sref*bref)
            crs_d(is, n) = crs_d(is, n) + crst_d(j, n)*(sr/sref)*(cr/
     +        bref)
            cms_dd(is, n) = cms_dd(is, n) + (sr*cr*cmst_dd(j, n)+cmst_d(
     +        j, n)*(cr*srd+sr*crd))/(sref*cref)
            cms_d(is, n) = cms_d(is, n) + cmst_d(j, n)*(sr/sref)*(cr/
     +        cref)
            cns_dd(is, n) = cns_dd(is, n) + (sr*cr*cnst_dd(j, n)+cnst_d(
     +        j, n)*(cr*srd+sr*crd))/(sref*bref)
            cns_d(is, n) = cns_d(is, n) + cnst_d(j, n)*(sr/sref)*(cr/
     +        bref)
          ENDDO
C
          DO n=1,ndesign
            cds_g(is, n) = cds_g(is, n) + cdst_g(j, n)*sr/sref
            cls_g(is, n) = cls_g(is, n) + clst_g(j, n)*sr/sref
C
            cxs_g(is, n) = cxs_g(is, n) + cxst_g(j, n)*sr/sref
            cys_g(is, n) = cys_g(is, n) + cyst_g(j, n)*sr/sref
            czs_g(is, n) = czs_g(is, n) + czst_g(j, n)*sr/sref
C
            crs_g(is, n) = crs_g(is, n) + crst_g(j, n)*(sr/sref)*(cr/
     +        bref)
            cms_g(is, n) = cms_g(is, n) + cmst_g(j, n)*(sr/sref)*(cr/
     +        cref)
            cns_g(is, n) = cns_g(is, n) + cnst_g(j, n)*(sr/sref)*(cr/
     +        bref)
          ENDDO
C
C--- reference point for surface LE (hinge) moments
C    defined by surface hinge vector direction thru first strip LE point
          IF (imags(is) .GE. 0) THEN
            r(1) = xr - rle1(1, jfrst(is))
            r(2) = yr - rle1(2, jfrst(is))
            r(3) = zr - rle1(3, jfrst(is))
          ELSE
            r(1) = xr - rle2(1, jfrst(is))
            r(2) = yr - rle2(2, jfrst(is))
            r(3) = zr - rle2(3, jfrst(is))
          END IF
C--- Surface forces and moments (about LE ref point, normalized locally) 
          DO l=1,3
            l1 = MOD(l, 3) + 1
            l2 = MOD(l1, 3) + 1
C
            cf_srf(l, is) = cf_srf(l, is) + cf_strp(l, j)*sr/ssurf(is)
C
            dcm = sr/ssurf(is)*cr/cavesurf(is)*(cm_strp(l, j)+cf_strp(l2
     +        , j)*r(l1)/cr-cf_strp(l1, j)*r(l2)/cr)
C
            cm_srf(l, is) = cm_srf(l, is) + dcm
          ENDDO
        ENDDO
C
C
C--- To define surface CL and CD we need local lift and drag directions...
C--- Define drag and lift directions for surface using average strip normal
        enave(1) = enave(1)/ssurf(is)
        enave(2) = enave(2)/ssurf(is)
        enave(3) = enave(3)/ssurf(is)
        result1 = DOT(enave, enave)
        enmag = SQRT(result1)
        IF (enmag .EQ. 0.) THEN
          enave(3) = 1.0
        ELSE
          enave(1) = enave(1)/enmag
          enave(2) = enave(2)/enmag
          enave(3) = enave(3)/enmag
        END IF
C--- Define a "spanwise" vector with cross product of average surface normal 
C    with chordline (x direction)
        spn(1) = 0.0
        spn(2) = enave(3)
        spn(3) = -enave(2)
C--- Stability axes stream vector defines drag direction
        udrag(1) = cosa
        udrag(2) = 0.0
        udrag(3) = sina
C--- Lift direction is vector product of "stream" and spanwise vector
        CALL CROSS(udrag, spn, ulift)
        result1 = DOT(ulift, ulift)
        ulmag = SQRT(result1)
        IF (ulmag .EQ. 0.) THEN
          ulift(3) = 1.0
        ELSE
          ulift(1) = ulift(1)/ulmag
          ulift(2) = ulift(2)/ulmag
          ulift(3) = ulift(3)/ulmag
        END IF
        cl_srf(is) = DOT(ulift, cf_srf(1, is))
        cd_srf(is) = DOT(udrag, cf_srf(1, is))
C--- Surface hinge moments defined by surface LE moment about hinge vector 
Ccc        CMLE_SRF(IS) = DOT(CM_SRF(1,IS),VHINGE(1,IS))
C
C
C-------------------------------------------------
        IF (lfload(is)) THEN
C------- Total forces summed from surface forces...
C-         normalized to configuration reference quantities
          cdtot = cdtot + cdsurf(is)
          cltotd = cltotd + clsurfd(is)
          cltot = cltot + clsurf(is)
          cxtot = cxtot + cxsurf(is)
          cytotd = cytotd + cysurfd(is)
          cytot = cytot + cysurf(is)
          cztot = cztot + czsurf(is)
          crtotd = crtotd + crsurfd(is)
          crtot = crtot + crsurf(is)
          cmtotd = cmtotd + cmsurfd(is)
          cmtot = cmtot + cmsurf(is)
          cntotd = cntotd + cnsurfd(is)
          cntot = cntot + cnsurf(is)
          cdvtot = cdvtot + cdvsurf(is)
C
          cdtot_a = cdtot_a + cds_a(is)
          cltot_ad = cltot_ad + cls_ad(is)
          cltot_a = cltot_a + cls_a(is)
C
          DO n=1,numax
            cdtot_u(n) = cdtot_u(n) + cds_u(is, n)
            cltot_ud(n) = cltot_ud(n) + cls_ud(is, n)
            cltot_u(n) = cltot_u(n) + cls_u(is, n)
            cxtot_u(n) = cxtot_u(n) + cxs_u(is, n)
            cytot_ud(n) = cytot_ud(n) + cys_ud(is, n)
            cytot_u(n) = cytot_u(n) + cys_u(is, n)
            cztot_u(n) = cztot_u(n) + czs_u(is, n)
            crtot_ud(n) = crtot_ud(n) + crs_ud(is, n)
            crtot_u(n) = crtot_u(n) + crs_u(is, n)
            cmtot_ud(n) = cmtot_ud(n) + cms_ud(is, n)
            cmtot_u(n) = cmtot_u(n) + cms_u(is, n)
            cntot_ud(n) = cntot_ud(n) + cns_ud(is, n)
            cntot_u(n) = cntot_u(n) + cns_u(is, n)
          ENDDO
C
          DO n=1,ncontrol
            cdtot_d(n) = cdtot_d(n) + cds_d(is, n)
            cltot_dd(n) = cltot_dd(n) + cls_dd(is, n)
            cltot_d(n) = cltot_d(n) + cls_d(is, n)
            cxtot_d(n) = cxtot_d(n) + cxs_d(is, n)
            cytot_dd(n) = cytot_dd(n) + cys_dd(is, n)
            cytot_d(n) = cytot_d(n) + cys_d(is, n)
            cztot_d(n) = cztot_d(n) + czs_d(is, n)
            crtot_dd(n) = crtot_dd(n) + crs_dd(is, n)
            crtot_d(n) = crtot_d(n) + crs_d(is, n)
            cmtot_dd(n) = cmtot_dd(n) + cms_dd(is, n)
            cmtot_d(n) = cmtot_d(n) + cms_d(is, n)
            cntot_dd(n) = cntot_dd(n) + cns_dd(is, n)
            cntot_d(n) = cntot_d(n) + cns_d(is, n)
          ENDDO
C
          DO n=1,ndesign
            cdtot_g(n) = cdtot_g(n) + cds_g(is, n)
            cltot_g(n) = cltot_g(n) + cls_g(is, n)
            cxtot_g(n) = cxtot_g(n) + cxs_g(is, n)
            cytot_g(n) = cytot_g(n) + cys_g(is, n)
            cztot_g(n) = cztot_g(n) + czs_g(is, n)
            crtot_g(n) = crtot_g(n) + crs_g(is, n)
            cmtot_g(n) = cmtot_g(n) + cms_g(is, n)
            cntot_g(n) = cntot_g(n) + cns_g(is, n)
          ENDDO
        END IF
      ENDDO
C-------------------------------------------------
C
C
C--- If case is XZ symmetric (IYSYM=1), add contributions from images,
C    zero out the asymmetric forces and double the symmetric ones
      IF (iysym .EQ. 1) THEN
        cdtot = 2.0*cdtot
        cltotd = 2.0*cltotd
        cltot = 2.0*cltot
        cxtot = 2.0*cxtot
        cytot = 0.
        cztot = 2.0*cztot
        crtot = 0.
        cmtotd = 2.0*cmtotd
        cmtot = 2.0*cmtot
        cntot = 0.
        cdvtot = 2.0*cdvtot
C
        cdtot_a = 2.0*cdtot_a
        cltot_ad = 2.0*cltot_ad
        cltot_a = 2.0*cltot_a
C
        DO n=1,numax
          cdtot_u(n) = 2.0*cdtot_u(n)
          cltot_ud(n) = 2.0*cltot_ud(n)
          cltot_u(n) = 2.0*cltot_u(n)
          cxtot_u(n) = 2.0*cxtot_u(n)
          cytot_ud(n) = 0.D0
          cytot_u(n) = 0.
          cztot_u(n) = 2.0*cztot_u(n)
          crtot_ud(n) = 0.D0
          crtot_u(n) = 0.
          cmtot_ud(n) = 2.0*cmtot_ud(n)
          cmtot_u(n) = 2.0*cmtot_u(n)
          cntot_ud(n) = 0.D0
          cntot_u(n) = 0.
        ENDDO
C
        DO n=1,ncontrol
          cdtot_d(n) = 2.0*cdtot_d(n)
          cltot_dd(n) = 2.0*cltot_dd(n)
          cltot_d(n) = 2.0*cltot_d(n)
          cxtot_d(n) = 2.0*cxtot_d(n)
          cytot_dd(n) = 0.D0
          cytot_d(n) = 0.
          cztot_d(n) = 2.0*cztot_d(n)
          crtot_dd(n) = 0.D0
          crtot_d(n) = 0.
          cmtot_dd(n) = 2.0*cmtot_dd(n)
          cmtot_d(n) = 2.0*cmtot_d(n)
          cntot_dd(n) = 0.D0
          cntot_d(n) = 0.
        ENDDO
C
        DO n=1,ndesign
          cdtot_g(n) = 2.0*cdtot_g(n)
          cltot_g(n) = 2.0*cltot_g(n)
          cxtot_g(n) = 2.0*cxtot_g(n)
          cytot_g(n) = 0.
          cztot_g(n) = 2.0*cztot_g(n)
          crtot_g(n) = 0.
          cmtot_g(n) = 2.0*cmtot_g(n)
          cntot_g(n) = 0.
        ENDDO
        cytotd = 0.D0
        crtotd = 0.D0
        cntotd = 0.D0
      END IF
C
      RETURN
      END

C  Differentiation of bdforc in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: cltot cytot crtot cmtot cntot
C                cltot_u cytot_u crtot_u cmtot_u cntot_u clbdy
C                cybdy crbdy cnbdy cmbdy
C   with respect to varying inputs: alfa vinf wrot xyzref cltot
C                cytot crtot cmtot cntot cltot_u cytot_u crtot_u
C                cmtot_u cntot_u clbdy cybdy crbdy cnbdy cmbdy
C SFFORC
C
C
C
      SUBROUTINE BDFORC_D()
      IMPLICIT NONE
      INCLUDE 'AVL_d.inc'
C
      REAL rrot(3)
      REAL rrotd(3)
      REAL veff(3), vrot(3), veff_u(3, 6), vrot_u(3), wrot_u(3)
      REAL veffd(3), vrotd(3), veff_ud(3, 6), vrot_ud(3), wrot_ud(3)
      REAL drl(3), esl(3), fb(3), fb_u(3, numax), mb(3), mb_u(3, numax)
      REAL fbd(3), fb_ud(3, numax), mbd(3), mb_ud(3, numax)
      REAL cdbdy_u(numax), clbdy_u(numax), cxbdy_u(numax), cybdy_u(numax
     +     ), czbdy_u(numax), crbdy_u(numax), cmbdy_u(numax), cnbdy_u(
     +     numax)
      REAL clbdy_ud(numax), cybdy_ud(numax), crbdy_ud(numax), cmbdy_ud(
     +     numax), cnbdy_ud(numax)
      REAL betm
      INTRINSIC SQRT
      REAL sina
      REAL sinad
      INTRINSIC SIN
      REAL cosa
      REAL cosad
      INTRINSIC COS
      INTEGER ib
      INTEGER iu
      INTEGER ilseg
      INTEGER l1
      INTEGER l2
      INTEGER l
      REAL drlmag
      REAL drlmi
      REAL dia
      REAL dinv
      INTEGER k
      REAL us
      REAL usd
      REAL un
      REAL und
      REAL un_u
      REAL un_ud
      REAL arg1
      INTEGER ii1
      INTEGER ii2
C
C
      arg1 = 1.0 - mach**2
      betm = SQRT(arg1)
C
      sinad = COS(alfa)*alfad
      sina = SIN(alfa)
      cosad = -(SIN(alfa)*alfad)
      cosa = COS(alfa)
      DO ii1=1,6
        DO ii2=1,3
          veff_ud(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,numax
        clbdy_ud(ii1) = 0.D0
      ENDDO
      DO ii1=1,numax
        cnbdy_ud(ii1) = 0.D0
      ENDDO
      DO ii1=1,numax
        crbdy_ud(ii1) = 0.D0
      ENDDO
      DO ii1=1,numax
        DO ii2=1,3
          fb_ud(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,3
        vrotd(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        vrot_ud(ii1) = 0.D0
      ENDDO
      DO ii1=1,numax
        DO ii2=1,3
          mb_ud(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,3
        fbd(ii1) = 0.D0
      ENDDO
      DO ii1=1,numax
        cmbdy_ud(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        veffd(ii1) = 0.D0
      ENDDO
      DO ii1=1,numax
        cybdy_ud(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        mbd(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        rrotd(ii1) = 0.D0
      ENDDO
C
C
C---- add on body force contributions
      DO ib=1,nbody
        cdbdy(ib) = 0.0
        clbdyd(ib) = 0.D0
        clbdy(ib) = 0.0
        cxbdy(ib) = 0.0
        cybdyd(ib) = 0.D0
        cybdy(ib) = 0.0
        czbdy(ib) = 0.0
        crbdyd(ib) = 0.D0
        crbdy(ib) = 0.0
        cmbdyd(ib) = 0.D0
        cmbdy(ib) = 0.0
        cnbdyd(ib) = 0.D0
        cnbdy(ib) = 0.0
C
        DO iu=1,6
          cdbdy_u(iu) = 0.0
          clbdy_ud(iu) = 0.D0
          clbdy_u(iu) = 0.0
          cxbdy_u(iu) = 0.0
          cybdy_ud(iu) = 0.D0
          cybdy_u(iu) = 0.0
          czbdy_u(iu) = 0.0
          crbdy_ud(iu) = 0.D0
          crbdy_u(iu) = 0.0
          cmbdy_ud(iu) = 0.D0
          cmbdy_u(iu) = 0.0
          cnbdy_ud(iu) = 0.D0
          cnbdy_u(iu) = 0.0
        ENDDO
C
        DO ilseg=1,nl(ib)-1
          l1 = lfrst(ib) + ilseg - 1
          l2 = lfrst(ib) + ilseg
C
          l = l1
C
          drl(1) = (rl(1, l2)-rl(1, l1))/betm
          drl(2) = rl(2, l2) - rl(2, l1)
          drl(3) = rl(3, l2) - rl(3, l1)
          arg1 = drl(1)**2 + drl(2)**2 + drl(3)**2
          drlmag = SQRT(arg1)
          IF (drlmag .EQ. 0.0) THEN
            drlmi = 0.0
          ELSE
            drlmi = 1.0/drlmag
          END IF
C
          dia = radl(l1) + radl(l2)
          IF (dia .LE. 0.0) THEN
            dinv = 0.0
          ELSE
            dinv = 1.0/dia
          END IF
C
C-------- unit vector along line segment
          esl(1) = drl(1)*drlmi
          esl(2) = drl(2)*drlmi
          esl(3) = drl(3)*drlmi
C
          rrotd(1) = -xyzrefd(1)
          rrot(1) = 0.5*(rl(1, l2)+rl(1, l1)) - xyzref(1)
          rrotd(2) = -xyzrefd(2)
          rrot(2) = 0.5*(rl(2, l2)+rl(2, l1)) - xyzref(2)
          rrotd(3) = -xyzrefd(3)
          rrot(3) = 0.5*(rl(3, l2)+rl(3, l1)) - xyzref(3)
C
C-------- go over freestream velocity and rotation components
          CALL CROSS_D(rrot, rrotd, wrot, wrotd, vrot, vrotd)
C
          veffd(1) = (vinfd(1)+vrotd(1))/betm
          veff(1) = (vinf(1)+vrot(1))/betm
          veffd(2) = vinfd(2) + vrotd(2)
          veff(2) = vinf(2) + vrot(2)
          veffd(3) = vinfd(3) + vrotd(3)
          veff(3) = vinf(3) + vrot(3)
C
C-------- set VEFF sensitivities to freestream,rotation components
          DO k=1,3
            veff_ud(1, k) = 0.D0
            veff_u(1, k) = 0.
            veff_ud(2, k) = 0.D0
            veff_u(2, k) = 0.
            veff_ud(3, k) = 0.D0
            veff_u(3, k) = 0.
            veff_ud(k, k) = 0.D0
            veff_u(k, k) = 1.0
          ENDDO
C
          DO k=4,6
            wrot_u(1) = 0.
            wrot_u(2) = 0.
            wrot_u(3) = 0.
            wrot_u(k-3) = 1.0
            DO ii1=1,3
              wrot_ud(ii1) = 0.D0
            ENDDO
            CALL CROSS_D(rrot, rrotd, wrot_u, wrot_ud, vrot_u, vrot_ud)
C
            veff_ud(1, k) = vrot_ud(1)
            veff_u(1, k) = vrot_u(1)
            veff_ud(2, k) = vrot_ud(2)
            veff_u(2, k) = vrot_u(2)
            veff_ud(3, k) = vrot_ud(3)
            veff_u(3, k) = vrot_u(3)
          ENDDO
C
C-------- U.es
          usd = esl(1)*veffd(1) + esl(2)*veffd(2) + esl(3)*veffd(3)
          us = veff(1)*esl(1) + veff(2)*esl(2) + veff(3)*esl(3)
C
C
C-------- velocity projected on normal plane = U - (U.es) es
          DO k=1,3
            und = veffd(k) - esl(k)*usd
            un = veff(k) - us*esl(k)
            fbd(k) = src(l)*und
            fb(k) = un*src(l)
C
            DO iu=1,6
              un_ud = veff_ud(k, iu) - esl(k)*(esl(1)*veff_ud(1, iu)+esl
     +          (2)*veff_ud(2, iu)+esl(3)*veff_ud(3, iu))
              un_u = veff_u(k, iu) - (veff_u(1, iu)*esl(1)+veff_u(2, iu)
     +          *esl(2)+veff_u(3, iu)*esl(3))*esl(k)
              fb_ud(k, iu) = src_u(l, iu)*und + src(l)*un_ud
              fb_u(k, iu) = un*src_u(l, iu) + un_u*src(l)
            ENDDO
C
            dcpb(k, l) = fb(k)*2.0*dinv*drlmi
          ENDDO
C
          CALL CROSS_D(rrot, rrotd, fb, fbd, mb, mbd)
          DO iu=1,6
            CALL CROSS_D(rrot, rrotd, fb_u(1, iu), fb_ud(1, iu), mb_u(1
     +                   , iu), mb_ud(1, iu))
          ENDDO
C
          cdbdy(ib) = cdbdy(ib) + (fb(1)*cosa+fb(3)*sina)*2.0/sref
          clbdyd(ib) = clbdyd(ib) + 2.0*(cosa*fbd(3)+fb(3)*cosad-sina*
     +      fbd(1)-fb(1)*sinad)/sref
          clbdy(ib) = clbdy(ib) + (-(fb(1)*sina)+fb(3)*cosa)*2.0/sref
C
          cxbdy(ib) = cxbdy(ib) + fb(1)*2.0/sref
          cybdyd(ib) = cybdyd(ib) + 2.0*fbd(2)/sref
          cybdy(ib) = cybdy(ib) + fb(2)*2.0/sref
          czbdy(ib) = czbdy(ib) + fb(3)*2.0/sref
C
          crbdyd(ib) = crbdyd(ib) + 2.0*mbd(1)/(sref*bref)
          crbdy(ib) = crbdy(ib) + mb(1)*2.0/sref/bref
          cmbdyd(ib) = cmbdyd(ib) + 2.0*mbd(2)/(sref*cref)
          cmbdy(ib) = cmbdy(ib) + mb(2)*2.0/sref/cref
          cnbdyd(ib) = cnbdyd(ib) + 2.0*mbd(3)/(sref*bref)
          cnbdy(ib) = cnbdy(ib) + mb(3)*2.0/sref/bref
C
          DO iu=1,6
            cdbdy_u(iu) = cdbdy_u(iu) + (fb_u(1, iu)*cosa+fb_u(3, iu)*
     +        sina)*2.0/sref
            clbdy_ud(iu) = clbdy_ud(iu) + 2.0*(cosa*fb_ud(3, iu)+fb_u(3
     +        , iu)*cosad-sina*fb_ud(1, iu)-fb_u(1, iu)*sinad)/sref
            clbdy_u(iu) = clbdy_u(iu) + (-(fb_u(1, iu)*sina)+fb_u(3, iu)
     +        *cosa)*2.0/sref
C
            cxbdy_u(iu) = cxbdy_u(iu) + fb_u(1, iu)*2.0/sref
            cybdy_ud(iu) = cybdy_ud(iu) + 2.0*fb_ud(2, iu)/sref
            cybdy_u(iu) = cybdy_u(iu) + fb_u(2, iu)*2.0/sref
            czbdy_u(iu) = czbdy_u(iu) + fb_u(3, iu)*2.0/sref
C
            crbdy_ud(iu) = crbdy_ud(iu) + 2.0*mb_ud(1, iu)/(sref*bref)
            crbdy_u(iu) = crbdy_u(iu) + mb_u(1, iu)*2.0/sref/bref
            cmbdy_ud(iu) = cmbdy_ud(iu) + 2.0*mb_ud(2, iu)/(sref*cref)
            cmbdy_u(iu) = cmbdy_u(iu) + mb_u(2, iu)*2.0/sref/cref
            cnbdy_ud(iu) = cnbdy_ud(iu) + 2.0*mb_ud(3, iu)/(sref*bref)
            cnbdy_u(iu) = cnbdy_u(iu) + mb_u(3, iu)*2.0/sref/bref
          ENDDO
        ENDDO
C
C---- add body forces and sensitivities to totals
        cdtot = cdtot + cdbdy(ib)
        cltotd = cltotd + clbdyd(ib)
        cltot = cltot + clbdy(ib)
C
        cxtot = cxtot + cxbdy(ib)
        cytotd = cytotd + cybdyd(ib)
        cytot = cytot + cybdy(ib)
        cztot = cztot + czbdy(ib)
C
        crtotd = crtotd + crbdyd(ib)
        crtot = crtot + crbdy(ib)
        cmtotd = cmtotd + cmbdyd(ib)
        cmtot = cmtot + cmbdy(ib)
        cntotd = cntotd + cnbdyd(ib)
        cntot = cntot + cnbdy(ib)
C
        DO iu=1,6
          cdtot_u(iu) = cdtot_u(iu) + cdbdy_u(iu)
          cltot_ud(iu) = cltot_ud(iu) + clbdy_ud(iu)
          cltot_u(iu) = cltot_u(iu) + clbdy_u(iu)
C
          cxtot_u(iu) = cxtot_u(iu) + cxbdy_u(iu)
Cccc      CXTOT_U(IU) = CYTOT_U(IU) + CYBDY_U(IU)   <<< BUG  5 Dec 10  MD
          cytot_ud(iu) = cytot_ud(iu) + cybdy_ud(iu)
          cytot_u(iu) = cytot_u(iu) + cybdy_u(iu)
          cztot_u(iu) = cztot_u(iu) + czbdy_u(iu)
C
          crtot_ud(iu) = crtot_ud(iu) + crbdy_ud(iu)
          crtot_u(iu) = crtot_u(iu) + crbdy_u(iu)
          cmtot_ud(iu) = cmtot_ud(iu) + cmbdy_ud(iu)
          cmtot_u(iu) = cmtot_u(iu) + cmbdy_u(iu)
          cntot_ud(iu) = cntot_ud(iu) + cnbdy_ud(iu)
          cntot_u(iu) = cntot_u(iu) + cnbdy_u(iu)
        ENDDO
      ENDDO
C
      RETURN
      END

C  Differentiation of vinfab in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: vinf vinf_a vinf_b
C   with respect to varying inputs: alfa beta vinf vinf_a vinf_b
C BDFORC
C
C
C
      SUBROUTINE VINFAB_D()
      IMPLICIT NONE
      INCLUDE 'AVL_d.inc'
      REAL sina
      REAL sinad
      INTRINSIC SIN
      REAL cosa
      REAL cosad
      INTRINSIC COS
      REAL sinb
      REAL sinbd
      REAL cosb
      REAL cosbd
C
      sinad = COS(alfa)*alfad
      sina = SIN(alfa)
      cosad = -(SIN(alfa)*alfad)
      cosa = COS(alfa)
      sinbd = COS(beta)*betad
      sinb = SIN(beta)
      cosbd = -(SIN(beta)*betad)
      cosb = COS(beta)
C
      vinfd(1) = cosb*cosad + cosa*cosbd
      vinf(1) = cosa*cosb
      vinfd(2) = -sinbd
      vinf(2) = -sinb
      vinfd(3) = cosb*sinad + sina*cosbd
      vinf(3) = sina*cosb
C
      vinf_ad(1) = -(cosb*sinad+sina*cosbd)
      vinf_a(1) = -(sina*cosb)
      vinf_ad(2) = 0.D0
      vinf_a(2) = 0.
      vinf_ad(3) = cosb*cosad + cosa*cosbd
      vinf_a(3) = cosa*cosb
C
      vinf_bd(1) = -(sinb*cosad+cosa*sinbd)
      vinf_b(1) = -(cosa*sinb)
      vinf_bd(2) = -cosbd
      vinf_b(2) = -cosb
      vinf_bd(3) = -(sinb*sinad+sina*sinbd)
      vinf_b(3) = -(sina*sinb)
C
      RETURN
      END
C VINFAB

