C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 15 Jan 2021 14:26
C
C  Differentiation of exec in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: alfa vinf xyzref cltot
C   with respect to varying inputs: alfa vinf xyzref rle chord
C                wstrip ensy ensz rv1 rv2 gam
C   RW status of diff variables: alfa:in-out vinf:in-out xyzref:in-out
C                cltot:out rle:in chord:in wstrip:in ensy:in ensz:in
C                rv1:in rv2:in gam:in
C CONSET
C
C
C
C
C
      SUBROUTINE EXEC_D(niter, info, ir)
      IMPLICIT NONE
C
      INCLUDE 'AVL_d.inc'
      REAL vsys(ivmax, ivmax), vres(ivmax), ddc(ndmax), work(ivmax)
      REAL vsysd(ivmax, ivmax), vresd(ivmax), ddcd(ndmax), workd(ivmax)
      INTEGER ivsys(ivmax)
      REAL dir
      EXTERNAL SETUP
      EXTERNAL GUCALC
      EXTERNAL GDCALC
      EXTERNAL GAMSUM
      EXTERNAL VELSUM
      INTEGER iter
      REAL ca
      REAL cad
      INTRINSIC COS
      REAL sa
      REAL sad
      INTRINSIC SIN
      REAL ca_a
      REAL ca_ad
      REAL sa_a
      REAL sa_ad
      INTEGER k
      INTEGER l
      INTEGER iv
      INTEGER ic
      INTEGER n
      INTEGER nv
      INTEGER iccon
      INTEGER ivcon
      EXTERNAL LUDCMP
      EXTERNAL LUDCMP_D
      EXTERNAL BAKSUB
      EXTERNAL BAKSUB_D
      REAL dal
      REAL dald
      REAL dbe
      REAL dbed
      REAL dwx
      REAL dwxd
      REAL dwy
      REAL dwyd
      REAL dwz
      REAL dwzd
      REAL dmaxa
      REAL dmaxr
      INTRINSIC ABS
      REAL delmax
      INTRINSIC MAX
      INTRINSIC IABS
      REAL y1
      REAL abs0
      REAL abs1
      REAL abs2
      REAL abs3
      REAL abs4
      REAL abs5
      REAL abs6
      REAL abs7
      REAL abs8
      REAL abs9
      INTEGER ii1
      INTEGER ii2
      REAL temp
      REAL temp0
      INTEGER info
      REAL eps
      INTEGER ir
      REAL dmax
      INTEGER niter
C
C---- convergence epsilon, max angle limit (radians)
      DATA eps, dmax /0.00002, 1.0/
C
C
      IF (lnasa_sa) THEN
C----- NASA Std. Stability axes, X fwd, Z down
        dir = -1.0
      ELSE
C----- Geometric Stability axes, X aft, Z up
        dir = 1.0
      END IF
C
      xyzrefd(1) = 0.D0
      xyzref(1) = parval(ipxcg, ir)
      xyzrefd(2) = 0.D0
      xyzref(2) = parval(ipycg, ir)
      xyzrefd(3) = 0.D0
      xyzref(3) = parval(ipzcg, ir)
C
      cdref = parval(ipcd0, ir)
C
      mach = parval(ipmach, ir)
C
      IF (mach .NE. amach) THEN
C----- new Mach number invalidates close to everything that's stored
        laic = .false.
        lsrd = .false.
        lsol = .false.
        lsen = .false.
      END IF
C
C---- set, factor AIC matrix and induced-velocity matrix (if they don't exist)
      CALL SETUP()
C
      IF (niter .GT. 0) THEN
C----- might as well directly set operating variables if they are known
        IF (icon(ivalfa, ir) .EQ. icalfa) THEN
          alfa = conval(icalfa, ir)*dtr
          alfad = 0.D0
        END IF
        IF (icon(ivbeta, ir) .EQ. icbeta) beta = conval(icbeta, ir)*dtr
        IF (icon(ivrotx, ir) .EQ. icrotx) wrot(1) = conval(icrotx, ir)*
     +      2./bref
        IF (icon(ivroty, ir) .EQ. icroty) wrot(2) = conval(icroty, ir)*
     +      2./cref
        IF (icon(ivrotz, ir) .EQ. icrotz) wrot(3) = conval(icrotz, ir)*
     +      2./bref
      END IF
C
C----- set GAM_U
Ccc       WRITE(*,*) ' Solving for unit-freestream vortex circulations...'
      CALL GUCALC()
C
C-------------------------------------------------------------
C---- calculate initial operating state
C
C---- set VINF() vector from initial ALFA,BETA
      DO ii1=1,3
        vinf_bd(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        vinf_ad(ii1) = 0.D0
      ENDDO
      betad = 0.D0
      CALL VINFAB_D()
C
      IF (ncontrol .GT. 0) THEN
C----- set GAM_D
        IF (lverbose) WRITE(*, *) 
     +                ' Solving for vortex control-var sensitivities...'
        CALL GDCALC(ncontrol, lcondef, enc_d, gam_d)
      END IF
C
      IF (ndesign .GT. 0) THEN
C----- set GAM_G
        IF (lverbose) WRITE(*, *) 
     +                ' Solving for vortex  design-var sensitivities...'
        CALL GDCALC(ndesign, ldesdef, enc_g, gam_g)
      END IF
C
C---- sum AIC matrices to get GAM,SRC,DBL
      CALL GAMSUM()
C
C---- sum AIC matrices to get WC,WV
      CALL VELSUM()
C
C---- compute forces
      DO ii1=1,nbmax
        cmbdyd(ii1) = 0.D0
      ENDDO
      DO ii1=1,nbmax
        cnbdyd(ii1) = 0.D0
      ENDDO
      DO ii1=1,nbmax
        crbdyd(ii1) = 0.D0
      ENDDO
      DO ii1=1,nbmax
        cybdyd(ii1) = 0.D0
      ENDDO
      DO ii1=1,nbmax
        clbdyd(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nsmax
          cmst_dd(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nsmax
          cnst_dd(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nsmax
          crst_dd(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nsmax
          cyst_dd(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nsmax
          clst_dd(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,numax
        DO ii2=1,nsmax
          cmst_ud(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,numax
        DO ii2=1,nsmax
          cnst_ud(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,numax
        DO ii2=1,nsmax
          crst_ud(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,numax
        DO ii2=1,nsmax
          cyst_ud(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,numax
        DO ii2=1,nsmax
          clst_ud(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nsmax
        clst_ad(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        cmstrpd(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        cnstrpd(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        crstrpd(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        cystrpd(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        clstrpd(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nfmax
          cms_dd(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nfmax
          cns_dd(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nfmax
          crs_dd(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nfmax
          cys_dd(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nfmax
          cls_dd(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,numax
        DO ii2=1,nfmax
          cms_ud(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,numax
        DO ii2=1,nfmax
          cns_ud(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,numax
        DO ii2=1,nfmax
          crs_ud(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,numax
        DO ii2=1,nfmax
          cys_ud(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,numax
        DO ii2=1,nfmax
          cls_ud(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nfmax
        cls_ad(ii1) = 0.D0
      ENDDO
      DO ii1=1,nfmax
        cmsurfd(ii1) = 0.D0
      ENDDO
      DO ii1=1,nfmax
        cnsurfd(ii1) = 0.D0
      ENDDO
      DO ii1=1,nfmax
        crsurfd(ii1) = 0.D0
      ENDDO
      DO ii1=1,nfmax
        cysurfd(ii1) = 0.D0
      ENDDO
      DO ii1=1,nfmax
        clsurfd(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        cntot_dd(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        cmtot_dd(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        crtot_dd(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        cytot_dd(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        cltot_dd(ii1) = 0.D0
      ENDDO
      DO ii1=1,numax
        cntot_ud(ii1) = 0.D0
      ENDDO
      DO ii1=1,numax
        cmtot_ud(ii1) = 0.D0
      ENDDO
      DO ii1=1,numax
        crtot_ud(ii1) = 0.D0
      ENDDO
      DO ii1=1,numax
        cytot_ud(ii1) = 0.D0
      ENDDO
      DO ii1=1,numax
        cltot_ud(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        wrotd(ii1) = 0.D0
      ENDDO
      CALL AERO_D()
      betad = 0.D0
      DO ii1=1,3
        wrotd(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        delcond(ii1) = 0.D0
      ENDDO
      DO ii1=1,ivmax
        DO ii2=1,ivmax
          vsysd(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ivmax
        vresd(ii1) = 0.D0
      ENDDO
      DO ii1=1,ivmax
        workd(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        ddcd(ii1) = 0.D0
      ENDDO
C
C---- Newton loop for operating variables
      DO iter=1,niter
C
        IF (lsa_rates) THEN
C-------- rates specified in NASA stability-axes, transform to body axes
          cad = -(SIN(alfa)*alfad)
          ca = COS(alfa)
          sad = COS(alfa)*alfad
          sa = SIN(alfa)
          ca_ad = -sad
          ca_a = -sa
          sa_ad = cad
          sa_a = ca
        ELSE
C-------- rates specified in body-axes, no transformation
          ca = 1.0
          sa = 0.0
          ca_a = 0.
          sa_a = 0.
          sa_ad = 0.D0
          sad = 0.D0
          cad = 0.D0
          ca_ad = 0.D0
        END IF
C
        DO k=1,ivmax
          DO l=1,ivmax
            vsysd(k, l) = 0.D0
            vsys(k, l) = 0.
          ENDDO
        ENDDO
C
C------ set up Newton system:  set constraints for all parameters
        DO 100 iv=1,nvtot
C
C-------- set index and value of constraint for this parameter
          ic = icon(iv, ir)
C
C------------------------------------
          IF (ic .EQ. icalfa) THEN
            vresd(iv) = alfad
            vres(iv) = alfa - conval(ic, ir)*dtr
            vsysd(iv, ivalfa) = 0.D0
            vsys(iv, ivalfa) = 1.0
C
C------------------------------------
          ELSE IF (ic .EQ. icbeta) THEN
            vresd(iv) = betad
            vres(iv) = beta - conval(ic, ir)*dtr
            vsysd(iv, ivbeta) = 0.D0
            vsys(iv, ivbeta) = 1.0
C
C------------------------------------
          ELSE IF (ic .EQ. icrotx) THEN
            vresd(iv) = dir*(ca*wrotd(1)+wrot(1)*cad+sa*wrotd(3)+wrot(3)
     +        *sad)
            vres(iv) = (wrot(1)*ca+wrot(3)*sa)*dir - conval(ic, ir)*2.0/
     +        bref
            vsysd(iv, ivrotx) = dir*cad
            vsys(iv, ivrotx) = ca*dir
            vsysd(iv, ivrotz) = dir*sad
            vsys(iv, ivrotz) = sa*dir
            vsysd(iv, ivalfa) = dir*(ca_a*wrotd(1)+wrot(1)*ca_ad+sa_a*
     +        wrotd(3)+wrot(3)*sa_ad)
            vsys(iv, ivalfa) = (wrot(1)*ca_a+wrot(3)*sa_a)*dir
C
C------------------------------------
          ELSE IF (ic .EQ. icroty) THEN
            vresd(iv) = wrotd(2)
            vres(iv) = wrot(2) - conval(ic, ir)*2.0/cref
            vsysd(iv, ivroty) = 0.D0
            vsys(iv, ivroty) = 1.0
C
C------------------------------------
          ELSE IF (ic .EQ. icrotz) THEN
            vresd(iv) = dir*(ca*wrotd(3)+wrot(3)*cad-sa*wrotd(1)-wrot(1)
     +        *sad)
            vres(iv) = (wrot(3)*ca-wrot(1)*sa)*dir - conval(ic, ir)*2.0/
     +        bref
            vsysd(iv, ivrotx) = -(dir*sad)
            vsys(iv, ivrotx) = -(sa*dir)
            vsysd(iv, ivrotz) = dir*cad
            vsys(iv, ivrotz) = ca*dir
            vsysd(iv, ivalfa) = dir*(ca_a*wrotd(3)+wrot(3)*ca_ad-sa_a*
     +        wrotd(1)-wrot(1)*sa_ad)
            vsys(iv, ivalfa) = (wrot(3)*ca_a-wrot(1)*sa_a)*dir
C
C------------------------------------
          ELSE IF (ic .EQ. iccl) THEN
            vresd(iv) = cltotd
            vres(iv) = cltot - conval(ic, ir)
            vsysd(iv, ivalfa) = vinf_a(1)*cltot_ud(1) + cltot_u(1)*
     +        vinf_ad(1) + vinf_a(2)*cltot_ud(2) + cltot_u(2)*vinf_ad(2)
     +        + vinf_a(3)*cltot_ud(3) + cltot_u(3)*vinf_ad(3) + cltot_ad
            vsys(iv, ivalfa) = cltot_u(1)*vinf_a(1) + cltot_u(2)*vinf_a(
     +        2) + cltot_u(3)*vinf_a(3) + cltot_a
            vsysd(iv, ivbeta) = vinf_b(1)*cltot_ud(1) + cltot_u(1)*
     +        vinf_bd(1) + vinf_b(2)*cltot_ud(2) + cltot_u(2)*vinf_bd(2)
     +        + vinf_b(3)*cltot_ud(3) + cltot_u(3)*vinf_bd(3)
            vsys(iv, ivbeta) = cltot_u(1)*vinf_b(1) + cltot_u(2)*vinf_b(
     +        2) + cltot_u(3)*vinf_b(3)
            vsysd(iv, ivrotx) = cltot_ud(4)
            vsys(iv, ivrotx) = cltot_u(4)
            vsysd(iv, ivroty) = cltot_ud(5)
            vsys(iv, ivroty) = cltot_u(5)
            vsysd(iv, ivrotz) = cltot_ud(6)
            vsys(iv, ivrotz) = cltot_u(6)
C
            DO n=1,ncontrol
              nv = ivtot + n
              vsysd(iv, nv) = cltot_dd(n)
              vsys(iv, nv) = cltot_d(n)
            ENDDO
          ELSE IF (ic .EQ. iccy) THEN
C
C------------------------------------
            vresd(iv) = cytotd
            vres(iv) = cytot - conval(ic, ir)
            vsysd(iv, ivalfa) = vinf_a(1)*cytot_ud(1) + cytot_u(1)*
     +        vinf_ad(1) + vinf_a(2)*cytot_ud(2) + cytot_u(2)*vinf_ad(2)
     +        + vinf_a(3)*cytot_ud(3) + cytot_u(3)*vinf_ad(3)
            vsys(iv, ivalfa) = cytot_u(1)*vinf_a(1) + cytot_u(2)*vinf_a(
     +        2) + cytot_u(3)*vinf_a(3)
            vsysd(iv, ivbeta) = vinf_b(1)*cytot_ud(1) + cytot_u(1)*
     +        vinf_bd(1) + vinf_b(2)*cytot_ud(2) + cytot_u(2)*vinf_bd(2)
     +        + vinf_b(3)*cytot_ud(3) + cytot_u(3)*vinf_bd(3)
            vsys(iv, ivbeta) = cytot_u(1)*vinf_b(1) + cytot_u(2)*vinf_b(
     +        2) + cytot_u(3)*vinf_b(3)
            vsysd(iv, ivrotx) = cytot_ud(4)
            vsys(iv, ivrotx) = cytot_u(4)
            vsysd(iv, ivroty) = cytot_ud(5)
            vsys(iv, ivroty) = cytot_u(5)
            vsysd(iv, ivrotz) = cytot_ud(6)
            vsys(iv, ivrotz) = cytot_u(6)
C
            DO n=1,ncontrol
              nv = ivtot + n
              vsysd(iv, nv) = cytot_dd(n)
              vsys(iv, nv) = cytot_d(n)
            ENDDO
          ELSE IF (ic .EQ. icmomx) THEN
C
C------------------------------------
            vresd(iv) = dir*(ca*crtotd+crtot*cad+sa*cntotd+cntot*sad)
            vres(iv) = (crtot*ca+cntot*sa)*dir - conval(ic, ir)
            temp = crtot_u(1)*vinf_a(1) + crtot_u(2)*vinf_a(2) + crtot_u
     +        (3)*vinf_a(3)
            temp0 = cntot_u(1)*vinf_a(1) + cntot_u(2)*vinf_a(2) + 
     +        cntot_u(3)*vinf_a(3)
            vsysd(iv, ivalfa) = dir*(ca*(vinf_a(1)*crtot_ud(1)+crtot_u(1
     +        )*vinf_ad(1)+vinf_a(2)*crtot_ud(2)+crtot_u(2)*vinf_ad(2)+
     +        vinf_a(3)*crtot_ud(3)+crtot_u(3)*vinf_ad(3))+temp*cad) + 
     +        dir*(sa*(vinf_a(1)*cntot_ud(1)+cntot_u(1)*vinf_ad(1)+
     +        vinf_a(2)*cntot_ud(2)+cntot_u(2)*vinf_ad(2)+vinf_a(3)*
     +        cntot_ud(3)+cntot_u(3)*vinf_ad(3))+temp0*sad) + dir*(ca_a*
     +        crtotd+crtot*ca_ad+sa_a*cntotd+cntot*sa_ad)
            vsys(iv, ivalfa) = dir*(temp*ca) + dir*(temp0*sa) + dir*(
     +        crtot*ca_a+cntot*sa_a)
            temp0 = crtot_u(1)*vinf_b(1) + crtot_u(2)*vinf_b(2) + 
     +        crtot_u(3)*vinf_b(3)
            temp = cntot_u(1)*vinf_b(1) + cntot_u(2)*vinf_b(2) + cntot_u
     +        (3)*vinf_b(3)
            vsysd(iv, ivbeta) = dir*(ca*(vinf_b(1)*crtot_ud(1)+crtot_u(1
     +        )*vinf_bd(1)+vinf_b(2)*crtot_ud(2)+crtot_u(2)*vinf_bd(2)+
     +        vinf_b(3)*crtot_ud(3)+crtot_u(3)*vinf_bd(3))+temp0*cad) + 
     +        dir*(sa*(vinf_b(1)*cntot_ud(1)+cntot_u(1)*vinf_bd(1)+
     +        vinf_b(2)*cntot_ud(2)+cntot_u(2)*vinf_bd(2)+vinf_b(3)*
     +        cntot_ud(3)+cntot_u(3)*vinf_bd(3))+temp*sad)
            vsys(iv, ivbeta) = dir*(temp0*ca) + dir*(temp*sa)
            vsysd(iv, ivrotx) = dir*(ca*crtot_ud(4)+crtot_u(4)*cad+sa*
     +        cntot_ud(4)+cntot_u(4)*sad)
            vsys(iv, ivrotx) = (crtot_u(4)*ca+cntot_u(4)*sa)*dir
            vsysd(iv, ivroty) = dir*(ca*crtot_ud(5)+crtot_u(5)*cad+sa*
     +        cntot_ud(5)+cntot_u(5)*sad)
            vsys(iv, ivroty) = (crtot_u(5)*ca+cntot_u(5)*sa)*dir
            vsysd(iv, ivrotz) = dir*(ca*crtot_ud(6)+crtot_u(6)*cad+sa*
     +        cntot_ud(6)+cntot_u(6)*sad)
            vsys(iv, ivrotz) = (crtot_u(6)*ca+cntot_u(6)*sa)*dir
C
            DO n=1,ncontrol
              nv = ivtot + n
              vsysd(iv, nv) = dir*(ca*crtot_dd(n)+crtot_d(n)*cad+sa*
     +          cntot_dd(n)+cntot_d(n)*sad)
              vsys(iv, nv) = (crtot_d(n)*ca+cntot_d(n)*sa)*dir
            ENDDO
          ELSE IF (ic .EQ. icmomy) THEN
C
C------------------------------------
            vresd(iv) = cmtotd
            vres(iv) = cmtot - conval(ic, ir)
            vsysd(iv, ivalfa) = vinf_a(1)*cmtot_ud(1) + cmtot_u(1)*
     +        vinf_ad(1) + vinf_a(2)*cmtot_ud(2) + cmtot_u(2)*vinf_ad(2)
     +        + vinf_a(3)*cmtot_ud(3) + cmtot_u(3)*vinf_ad(3)
            vsys(iv, ivalfa) = cmtot_u(1)*vinf_a(1) + cmtot_u(2)*vinf_a(
     +        2) + cmtot_u(3)*vinf_a(3)
            vsysd(iv, ivbeta) = vinf_b(1)*cmtot_ud(1) + cmtot_u(1)*
     +        vinf_bd(1) + vinf_b(2)*cmtot_ud(2) + cmtot_u(2)*vinf_bd(2)
     +        + vinf_b(3)*cmtot_ud(3) + cmtot_u(3)*vinf_bd(3)
            vsys(iv, ivbeta) = cmtot_u(1)*vinf_b(1) + cmtot_u(2)*vinf_b(
     +        2) + cmtot_u(3)*vinf_b(3)
            vsysd(iv, ivrotx) = cmtot_ud(4)
            vsys(iv, ivrotx) = cmtot_u(4)
            vsysd(iv, ivroty) = cmtot_ud(5)
            vsys(iv, ivroty) = cmtot_u(5)
            vsysd(iv, ivrotz) = cmtot_ud(6)
            vsys(iv, ivrotz) = cmtot_u(6)
C
            DO n=1,ncontrol
              nv = ivtot + n
              vsysd(iv, nv) = cmtot_dd(n)
              vsys(iv, nv) = cmtot_d(n)
            ENDDO
          ELSE IF (ic .EQ. icmomz) THEN
C
C------------------------------------
            vresd(iv) = dir*(ca*cntotd+cntot*cad-sa*crtotd-crtot*sad)
            vres(iv) = (cntot*ca-crtot*sa)*dir - conval(ic, ir)
            temp0 = cntot_u(1)*vinf_a(1) + cntot_u(2)*vinf_a(2) + 
     +        cntot_u(3)*vinf_a(3)
            temp = crtot_u(1)*vinf_a(1) + crtot_u(2)*vinf_a(2) + crtot_u
     +        (3)*vinf_a(3)
            vsysd(iv, ivalfa) = dir*(ca*(vinf_a(1)*cntot_ud(1)+cntot_u(1
     +        )*vinf_ad(1)+vinf_a(2)*cntot_ud(2)+cntot_u(2)*vinf_ad(2)+
     +        vinf_a(3)*cntot_ud(3)+cntot_u(3)*vinf_ad(3))+temp0*cad) - 
     +        dir*(sa*(vinf_a(1)*crtot_ud(1)+crtot_u(1)*vinf_ad(1)+
     +        vinf_a(2)*crtot_ud(2)+crtot_u(2)*vinf_ad(2)+vinf_a(3)*
     +        crtot_ud(3)+crtot_u(3)*vinf_ad(3))+temp*sad) + dir*(ca_a*
     +        cntotd+cntot*ca_ad-sa_a*crtotd-crtot*sa_ad)
            vsys(iv, ivalfa) = dir*(temp0*ca) - dir*(temp*sa) + dir*(
     +        cntot*ca_a-crtot*sa_a)
            temp0 = cntot_u(1)*vinf_b(1) + cntot_u(2)*vinf_b(2) + 
     +        cntot_u(3)*vinf_b(3)
            temp = crtot_u(1)*vinf_b(1) + crtot_u(2)*vinf_b(2) + crtot_u
     +        (3)*vinf_b(3)
            vsysd(iv, ivbeta) = dir*(ca*(vinf_b(1)*cntot_ud(1)+cntot_u(1
     +        )*vinf_bd(1)+vinf_b(2)*cntot_ud(2)+cntot_u(2)*vinf_bd(2)+
     +        vinf_b(3)*cntot_ud(3)+cntot_u(3)*vinf_bd(3))+temp0*cad) - 
     +        dir*(sa*(vinf_b(1)*crtot_ud(1)+crtot_u(1)*vinf_bd(1)+
     +        vinf_b(2)*crtot_ud(2)+crtot_u(2)*vinf_bd(2)+vinf_b(3)*
     +        crtot_ud(3)+crtot_u(3)*vinf_bd(3))+temp*sad)
            vsys(iv, ivbeta) = dir*(temp0*ca) - dir*(temp*sa)
            vsysd(iv, ivrotx) = dir*(ca*cntot_ud(4)+cntot_u(4)*cad-sa*
     +        crtot_ud(4)-crtot_u(4)*sad)
            vsys(iv, ivrotx) = (cntot_u(4)*ca-crtot_u(4)*sa)*dir
            vsysd(iv, ivroty) = dir*(ca*cntot_ud(5)+cntot_u(5)*cad-sa*
     +        crtot_ud(5)-crtot_u(5)*sad)
            vsys(iv, ivroty) = (cntot_u(5)*ca-crtot_u(5)*sa)*dir
            vsysd(iv, ivrotz) = dir*(ca*cntot_ud(6)+cntot_u(6)*cad-sa*
     +        crtot_ud(6)-crtot_u(6)*sad)
            vsys(iv, ivrotz) = (cntot_u(6)*ca-crtot_u(6)*sa)*dir
C
            DO n=1,ncontrol
              nv = ivtot + n
              vsysd(iv, nv) = dir*(ca*cntot_dd(n)+cntot_d(n)*cad-sa*
     +          crtot_dd(n)-crtot_d(n)*sad)
              vsys(iv, nv) = (cntot_d(n)*ca-crtot_d(n)*sa)*dir
            ENDDO
          ELSE
C
C------------------------------------
            DO n=1,ncontrol
              iccon = ictot + n
              ivcon = ivtot + n
              IF (ic .EQ. iccon) GOTO 110
            ENDDO
C
            WRITE(*, *) '? Illegal constraint index: ', ic
            GOTO 100
 110        vresd(iv) = delcond(n)
            vres(iv) = delcon(n) - conval(iccon, ir)
            vsysd(iv, ivcon) = 0.D0
            vsys(iv, ivcon) = 1.0
          END IF
 100    CONTINUE
C
C
C
C------ LU-factor,  and back-substitute RHS
        CALL LUDCMP_D(ivmax, nvtot, vsys, vsysd, ivsys, work, workd)
        CALL BAKSUB_D(ivmax, nvtot, vsys, vsysd, ivsys, vres, vresd)
C
C------ set Newton deltas
        dald = -vresd(ivalfa)
        dal = -vres(ivalfa)
        dbed = -vresd(ivbeta)
        dbe = -vres(ivbeta)
        dwxd = -vresd(ivrotx)
        dwx = -vres(ivrotx)
        dwyd = -vresd(ivroty)
        dwy = -vres(ivroty)
        dwzd = -vresd(ivrotz)
        dwz = -vres(ivrotz)
        DO n=1,ncontrol
          iv = ivtot + n
          ddcd(n) = -vresd(iv)
          ddc(n) = -vres(iv)
        ENDDO
C
        IF (info .GE. 1) THEN
C------- display Newton deltas
          IF (iter .EQ. 1) THEN
            IF (lverbose) THEN
              WRITE(*, *) 
              WRITE(*, 1902) 'iter', ' d(alpha)  ', ' d(beta)   ', 
     +              ' d(pb/2V)  ', ' d(qc/2V)  ', ' d(rb/2V)  ', (dname(
     +              k), k=1,ncontrol)
            END IF
          END IF
          IF (lverbose) WRITE(*, 1905) iter, dal/dtr, dbe/dtr, dwx*bref/
     +                        2.0, dwy*cref/2.0, dwz*bref/2.0, (ddc(k), 
     +                        k=1,ncontrol)
        END IF
C
C------ limits on angles and rates
        dmaxa = dmax
        dmaxr = 5.0*dmax/bref
        IF (alfa + dal .GE. 0.) THEN
          abs0 = alfa + dal
        ELSE
          abs0 = -(alfa+dal)
        END IF
C
C------ if changes are too big, configuration is probably untrimmable
        IF (abs0 .GT. dmaxa) THEN
          GOTO 120
        ELSE
          IF (beta + dbe .GE. 0.) THEN
            abs1 = beta + dbe
          ELSE
            abs1 = -(beta+dbe)
          END IF
C
          IF (abs1 .GT. dmaxa) THEN
            GOTO 130
          ELSE
            IF (wrot(1) + dwx .GE. 0.) THEN
              abs2 = wrot(1) + dwx
            ELSE
              abs2 = -(wrot(1)+dwx)
            END IF
C
            IF (abs2 .GT. dmaxr) THEN
              GOTO 140
            ELSE
              IF (wrot(2) + dwy .GE. 0.) THEN
                abs3 = wrot(2) + dwy
              ELSE
                abs3 = -(wrot(2)+dwy)
              END IF
C
              IF (abs3 .GT. dmaxr) THEN
                GOTO 150
              ELSE
                IF (wrot(3) + dwz .GE. 0.) THEN
                  abs4 = wrot(3) + dwz
                ELSE
                  abs4 = -(wrot(3)+dwz)
                END IF
C
                IF (abs4 .GT. dmaxr) THEN
                  GOTO 160
                ELSE
C
C------ update
                  alfad = alfad + dald
                  alfa = alfa + dal
                  betad = betad + dbed
                  beta = beta + dbe
                  wrotd(1) = wrotd(1) + dwxd
                  wrot(1) = wrot(1) + dwx
                  wrotd(2) = wrotd(2) + dwyd
                  wrot(2) = wrot(2) + dwy
                  wrotd(3) = wrotd(3) + dwzd
                  wrot(3) = wrot(3) + dwz
                  DO k=1,ncontrol
                    delcond(k) = delcond(k) + ddcd(k)
                    delcon(k) = delcon(k) + ddc(k)
                  ENDDO
C
C
C------ set VINF() vector from new ALFA,BETA
                  CALL VINFAB_D()
C
                  IF (ncontrol .GT. 0) THEN
C------- set new GAM_D
                    CALL GDCALC(ncontrol, lcondef, enc_d, gam_d)
                  END IF
C
                  IF (ndesign .GT. 0) THEN
C------- set new GAM_G
                    CALL GDCALC(ndesign, ldesdef, enc_g, gam_g)
                  END IF
C
C------ sum AIC matrices to get GAM,SRC,DBL
                  CALL GAMSUM()
C
C------ sum AIC matrices to get WC,WV
                  CALL VELSUM()
C
C------ compute forces
                  CALL AERO_D()
                  IF (dal .GE. 0.) THEN
                    abs5 = dal
                  ELSE
                    abs5 = -dal
                  END IF
                  IF (dbe .GE. 0.) THEN
                    abs6 = dbe
                  ELSE
                    abs6 = -dbe
                  END IF
                  IF (dwx*bref/2.0 .GE. 0.) THEN
                    abs7 = dwx*bref/2.0
                  ELSE
                    abs7 = -(dwx*bref/2.0)
                  END IF
                  IF (dwy*cref/2.0 .GE. 0.) THEN
                    abs8 = dwy*cref/2.0
                  ELSE
                    abs8 = -(dwy*cref/2.0)
                  END IF
                  IF (dwz*bref/2.0 .GE. 0.) THEN
                    abs9 = dwz*bref/2.0
                  ELSE
                    abs9 = -(dwz*bref/2.0)
                  END IF
C
C
C------ convergence check
                  delmax = MAX(abs5, abs6, abs7, abs8, abs9)
                  DO k=1,ncontrol
                    IF (ddc(k) .GE. 0.) THEN
                      y1 = ddc(k)
                    ELSE
                      y1 = -ddc(k)
                    END IF
                    IF (delmax .LT. y1) THEN
                      delmax = y1
                    ELSE
                      delmax = delmax
                    END IF
                  ENDDO
C
                  IF (delmax .LT. eps) GOTO 170
                END IF
              END IF
            END IF
          END IF
        END IF
      ENDDO
C
      IF (niter .GT. 0) THEN
        WRITE(*, *) 'Trim convergence failed'
        lsol = .false.
        RETURN
      ELSE
        GOTO 191
      END IF
 120  WRITE(*, *) 'Cannot trim.  Alpha too large.  a =', (alfa+dal)/dtr
      RETURN
 130  WRITE(*, *) 'Cannot trim.  Beta too large.  b =', (beta+dbe)/dtr
      RETURN
 140  WRITE(*, *) 'Cannot trim.  Roll rate too large.  pb/2V =', (wrot(1
     +      )+dwx)*bref*0.5
      RETURN
 150  WRITE(*, *) 'Cannot trim.  Pitch rate too large.  qc/2V =', (wrot(
     +      2)+dwy)*cref*0.5
      RETURN
 160  WRITE(*, *) 'Cannot trim.  Yaw rate too large.  rb/2V =', (wrot(3)
     +      +dwz)*bref*0.5
      RETURN
 170  lsol = .true.
      IF (itrim(ir) .GE. 0) THEN
        itrim(ir) = itrim(ir)
      ELSE
        itrim(ir) = -itrim(ir)
      END IF
C
 191  parval(ipalfa, ir) = alfa/dtr
      parval(ipbeta, ir) = beta/dtr
      parval(iprotx, ir) = wrot(1)*0.5*bref
      parval(iproty, ir) = wrot(2)*0.5*cref
      parval(iprotz, ir) = wrot(3)*0.5*bref
      parval(ipcl, ir) = cltot
C
C
C       WRITE(*,*)  'ALFA: ', ALFA
C       WRITE(*,*) 'PARVAL(IPALFA,IR): ', PARVAL(IPALFA,IR)
C
      lsen = .true.
      RETURN
 1902 FORMAT(1x,a4,5a11,1x,30a11)
 1905 FORMAT(1x,i3,20e11.3)
      END

