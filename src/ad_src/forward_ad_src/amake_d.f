C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 15 Jan 2021 14:26
C
C  Differentiation of update_surfaces in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: enc env
C   with respect to varying inputs: addinc
C   RW status of diff variables: addinc:in enc:out env:out
C MAKESURF
      SUBROUTINE UPDATE_SURFACES_D()
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
      INTEGER isurf
      INTEGER ii2
      INTEGER ii1
      nstrip = 0
      nvor = 0
      DO ii1=1,nsmax
        ainc_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,ngmax
        DO ii2=1,nsmax
          ainc_g_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO 100 isurf=1,nsurf
        IF (lverbose) WRITE(*, *) 'Updating surface ', isurf
        IF (isurf .NE. 1) THEN
          IF (ldupl(isurf-1)) THEN
            GOTO 100
          ELSE
C this surface has already been created
            CALL MAKESURF_D(isurf)
          END IF
        ELSE
          CALL MAKESURF_D(isurf)
        END IF
        IF (ldupl(isurf)) CALL SDUPL_D(isurf, ydupl(isurf), 'ydup')
 100  CONTINUE
      CALL ENCALC_D()
      laic = .false.
      lsrd = .false.
      lvel = .false.
      lsol = .false.
      lsen = .false.
      END

C  Differentiation of makesurf in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: ainc ainc_g
C   with respect to varying inputs: addinc ainc ainc_g
C***********************************************************************
C    Module:  amake.f
C 
C    Copyright (C) 2002 Mark Drela, Harold Youngren
C 
C    This program is free software; you can redistribute it and/or modify
C    it under the terms of the GNU General Public License as published by
C    the Free Software Foundation; either version 2 of the License, or
C    (at your option) any later version.
C
C    This program is distributed in the hope that it will be useful,
C    but WITHOUT ANY WARRANTY; without even the implied warranty of
C    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C    GNU General Public License for more details.
C
C    You should have received a copy of the GNU General Public License
C    along with this program; if not, write to the Free Software
C    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
C***********************************************************************
C
      SUBROUTINE MAKESURF_D(isurf)
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
C
C
      REAL xyzlel(3), xyzler(3)
      INTEGER kcmax
      INTEGER ksmax
      PARAMETER (kcmax=50, ksmax=500)
      REAL xpt0(kcmax), xcp0(kcmax), xvr0(kcmax), xsr0(kcmax), xpt1(
     +     kcmax), xcp1(kcmax), xvr1(kcmax), xsr1(kcmax), xpt2(kcmax), 
     +     xcp2(kcmax), xvr2(kcmax), xsr2(kcmax)
      REAL xpt(kcmax), xcp(kcmax), xvr(kcmax), xsr(kcmax), ypt(ksmax), 
     +     ycp(ksmax)
      REAL yzlen(ksmax)
      INTEGER iptloc(ksmax)
      INTEGER kpmax
      PARAMETER (kpmax=2*kcmax+2*ksmax)
      REAL fspace(kpmax)
C
      REAL chsinl_g(ngmax), chcosl_g(ngmax), chsinr_g(ngmax), chcosr_g(
     +     ngmax)
      REAL chsinl_g_diff(ngmax), chcosl_g_diff(ngmax), chsinr_g_diff(
     +     ngmax), chcosr_g_diff(ngmax)
      INTEGER isconl(ndmax), isconr(ndmax)
      REAL xled(ndmax), xted(ndmax), gainda(ndmax)
      INTEGER isec
      REAL dy
      REAL dz
      INTRINSIC SQRT
      REAL dyzlen
      INTEGER nvint
      INTEGER nspace
      EXTERNAL SPACER
      INTEGER n
      INTEGER ivs
      INTEGER npt
      REAL yptloc
      INTEGER ipt
      REAL yptdel
      INTRINSIC ABS
      INTEGER ipt1
      INTEGER ipt2
      REAL ypt1
      REAL yscale
      REAL width
      REAL chordl
      REAL chordr
      REAL clafl
      REAL clafr
      REAL aincl
      REAL aincl_diff
      REAL aincr
      REAL aincr_diff
      REAL chsinl
      REAL chsinl_diff
      INTRINSIC SIN
      REAL chsinr
      REAL chsinr_diff
      REAL chcosl
      REAL chcosl_diff
      INTRINSIC COS
      REAL chcosr
      REAL chcosr_diff
      INTEGER iscon
      INTEGER isdes
      INTEGER iptl
      INTEGER iptr
      INTEGER nspan
      INTEGER ispan
      REAL f1
      REAL f2
      REAL fc
      REAL chsin
      REAL chsin_diff
      REAL chcos
      REAL chcos_diff
      INTRINSIC ATAN2
      REAL chsin_g
      REAL chsin_g_diff
      REAL chcos_g
      REAL chcos_g_diff
      INTEGER icl
      INTEGER icr
      REAL xhd
      REAL vhx
      REAL vhy
      REAL vhz
      REAL vsq
      REAL vmod
      INTEGER l
      INTEGER nsl
      INTEGER nsr
      REAL chordc
      REAL clafc
      EXTERNAL CSPACER
      INTEGER ivc
      REAL slopel
      REAL dsdx
      EXTERNAL AKIMA
      REAL sloper
      REAL dxoc
      REAL fracle
      REAL fracte
      INTRINSIC MAX
      INTRINSIC MIN
      REAL sum
      REAL wtot
      INTEGER jj
      INTEGER j
      REAL astrp
      INTEGER nst
      EXTERNAL STRIP
      REAL y1
      REAL y2
      REAL abs0
      REAL(kind=avl_real) abs1
      REAL(kind=avl_real) abs2
      REAL arg1
      REAL result1
      REAL temp
      REAL temp0
      INTEGER ii1
      INTEGER isurf
C
C
      IF (nsec(isurf) .LT. 2) THEN
        WRITE(*, *) '*** Need at least 2 sections per surface.'
        STOP
      ELSE
C
C
        IF (nvc(isurf) .GT. kcmax) THEN
          WRITE(*, *) '* MAKESURF: Array overflow.  Increase KCMAX to', 
     +          nvc(isurf)
          nvc(isurf) = kcmax
        END IF
C
        IF (nvs(isurf) .GT. ksmax) THEN
          WRITE(*, *) '* MAKESURF: Array overflow.  Increase KSMAX to', 
     +          nvs(isurf)
          nvs(isurf) = ksmax
        END IF
C
C--- Image flag set to indicate section definition direction
C    IMAGS= 1  defines edge 1 located at surface root edge 
C    IMAGS=-1  defines edge 2 located at surface root edge (reflected surfaces)
        imags(isurf) = 1
        ifrst(isurf) = nvor + 1
        jfrst(isurf) = nstrip + 1
        nk(isurf) = nvc(isurf)
C
C-----------------------------------------------------------------
C---- section arc lengths of wing trace in y-z plane
        yzlen(1) = 0.
        DO isec=2,nsec(isurf)
          dy = xyzles(2, isec, isurf) - xyzles(2, isec-1, isurf)
          dz = xyzles(3, isec, isurf) - xyzles(3, isec-1, isurf)
          arg1 = dy*dy + dz*dz
          result1 = SQRT(arg1)
          yzlen(isec) = yzlen(isec-1) + result1
        ENDDO
C
C
        IF (nvs(isurf) .EQ. 0) THEN
C----- set spanwise spacing using spacing parameters for each section interval
          DO isec=1,nsec(isurf)-1
            nvs(isurf) = nvs(isurf) + nspans(isec, isurf)
          ENDDO
          IF (nvs(isurf) .GT. ksmax) THEN
            WRITE(*, *) 
     +            '*** MAKESURF: Array overflow. Increase KSMAX to', nvs
     +            (isurf)
            STOP
          ELSE
C
            nvs(isurf) = 0
            ypt(1) = yzlen(1)
            iptloc(1) = 1
C
            DO isec=1,nsec(isurf)-1
              dyzlen = yzlen(isec+1) - yzlen(isec)
C
              nvint = nspans(isec, isurf)
C
C------- set spanwise spacing array
              nspace = 2*nvint + 1
              IF (nspace .GT. kpmax) THEN
                GOTO 100
              ELSE
                CALL SPACER(nspace, sspaces(isec, isurf), fspace)
C
                DO n=1,nvint
                  ivs = nvs(isurf) + n
                  ycp(ivs) = ypt(nvs(isurf)+1) + dyzlen*fspace(2*n)
                  ypt(ivs+1) = ypt(nvs(isurf)+1) + dyzlen*fspace(2*n+1)
                ENDDO
                iptloc(isec+1) = nvs(isurf) + nvint + 1
C
                nvs(isurf) = nvs(isurf) + nvint
              END IF
            ENDDO
            GOTO 130
 100        WRITE(*, *) 
     +            '*** MAKESURF: Array overflow. Increase KPMAX to', 
     +            nspace
            STOP
          END IF
        ELSE
C
C----- set spanwise spacing using overall parameters NVS(ISURF), SSPACE
C
          nspace = 2*nvs(isurf) + 1
          IF (nspace .GT. kpmax) THEN
            WRITE(*, *) 
     +            '*** MAKESURF: Array overflow. Increase KPMAX to', 
     +            nspace
            STOP
          ELSE
            CALL SPACER(nspace, sspace(isurf), fspace)
C
            ypt(1) = yzlen(1)
            DO ivs=1,nvs(isurf)
              ycp(ivs) = yzlen(1) + (yzlen(nsec(isurf))-yzlen(1))*fspace
     +          (2*ivs)
              ypt(ivs+1) = yzlen(1) + (yzlen(nsec(isurf))-yzlen(1))*
     +          fspace(2*ivs+1)
            ENDDO
C
            npt = nvs(isurf) + 1
C
C----- find node nearest each section
            DO isec=2,nsec(isurf)-1
              yptloc = 1.0e9
              iptloc(isec) = 1
              DO ipt=1,npt
                IF (yzlen(isec) - ypt(ipt) .GE. 0.) THEN
                  yptdel = yzlen(isec) - ypt(ipt)
                ELSE
                  yptdel = -(yzlen(isec)-ypt(ipt))
                END IF
                IF (yptdel .LT. yptloc) THEN
                  yptloc = yptdel
                  iptloc(isec) = ipt
                END IF
              ENDDO
            ENDDO
            iptloc(1) = 1
            iptloc(nsec(isurf)) = npt
C
C----- fudge Glauert angles to make nodes match up exactly with interior sections
            DO isec=2,nsec(isurf)-1
              ipt1 = iptloc(isec-1)
              ipt2 = iptloc(isec)
              IF (ipt1 .EQ. ipt2) THEN
                GOTO 110
              ELSE
C
                ypt1 = ypt(ipt1)
                yscale = (yzlen(isec)-yzlen(isec-1))/(ypt(ipt2)-ypt(ipt1
     +            ))
                DO ipt=ipt1,ipt2-1
                  ypt(ipt) = yzlen(isec-1) + yscale*(ypt(ipt)-ypt1)
                ENDDO
                DO ivs=ipt1,ipt2-1
                  ycp(ivs) = yzlen(isec-1) + yscale*(ycp(ivs)-ypt1)
                ENDDO
C
                ipt1 = iptloc(isec)
                ipt2 = iptloc(isec+1)
                IF (ipt1 .EQ. ipt2) THEN
                  GOTO 120
                ELSE
C
                  ypt1 = ypt(ipt1)
                  yscale = (ypt(ipt2)-yzlen(isec))/(ypt(ipt2)-ypt(ipt1))
                  DO ipt=ipt1,ipt2-1
                    ypt(ipt) = yzlen(isec) + yscale*(ypt(ipt)-ypt1)
                  ENDDO
                  DO ivs=ipt1,ipt2-1
                    ycp(ivs) = yzlen(isec) + yscale*(ycp(ivs)-ypt1)
                  ENDDO
                END IF
              END IF
            ENDDO
            GOTO 130
 110        CALL STRIP(stitle(isurf), nst)
            WRITE(*, 7000) isec, stitle(isurf)(1:nst)
            STOP
 120        CALL STRIP(stitle(isurf), nst)
            WRITE(*, 7000) isec, stitle(isurf)(1:nst)
            STOP
          END IF
        END IF
C
C
C
C====================================================
C---- define strips between input sections
C
 130    nj(isurf) = 0
C
        IF (ncontrol .GT. ndmax) THEN
          WRITE(*, *) 
     +          '*** Too many control variables.  Increase NDMAX to', 
     +          ncontrol
          STOP
        ELSE IF (ndesign .GT. ngmax) THEN
C
          WRITE(*, *) 
     +          '*** Too many design variables.  Increase NGMAX to', 
     +          ndesign
          STOP
        ELSE
          DO ii1=1,ngmax
            chcosl_g_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ngmax
            chsinr_g_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ngmax
            chsinl_g_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ngmax
            chcosr_g_diff(ii1) = 0.D0
          ENDDO
C
C---- go over section intervals
          DO isec=1,nsec(isurf)-1
            xyzlel(1) = xyzscal(1, isurf)*xyzles(1, isec, isurf) + 
     +        xyztran(1, isurf)
            xyzlel(2) = xyzscal(2, isurf)*xyzles(2, isec, isurf) + 
     +        xyztran(2, isurf)
            xyzlel(3) = xyzscal(3, isurf)*xyzles(3, isec, isurf) + 
     +        xyztran(3, isurf)
            xyzler(1) = xyzscal(1, isurf)*xyzles(1, isec+1, isurf) + 
     +        xyztran(1, isurf)
            xyzler(2) = xyzscal(2, isurf)*xyzles(2, isec+1, isurf) + 
     +        xyztran(2, isurf)
            xyzler(3) = xyzscal(3, isurf)*xyzles(3, isec+1, isurf) + 
     +        xyztran(3, isurf)
C
            arg1 = (xyzler(2)-xyzlel(2))**2 + (xyzler(3)-xyzlel(3))**2
            width = SQRT(arg1)
C
            chordl = xyzscal(1, isurf)*chords(isec, isurf)
            chordr = xyzscal(1, isurf)*chords(isec+1, isurf)
C
            clafl = claf(isec, isurf)
            clafr = claf(isec+1, isurf)
C
C------ removed CLAF influence on zero-lift angle  (MD  21 Mar 08)
            aincl_diff = addinc_diff(isurf)
            aincl = aincs(isec, isurf) + addinc(isurf)
            aincr_diff = addinc_diff(isurf)
            aincr = aincs(isec+1, isurf) + addinc(isurf)
Cc      AINCL = AINCS(ISEC)   + ADDINC(ISURF) - 4.0*DTR*(CLAFL-1.0)
Cc      AINCR = AINCS(ISEC+1) + ADDINC(ISURF) - 4.0*DTR*(CLAFR-1.0)
C
            chsinl_diff = chordl*COS(aincl)*aincl_diff
            chsinl = chordl*SIN(aincl)
            chsinr_diff = chordr*COS(aincr)*aincr_diff
            chsinr = chordr*SIN(aincr)
            chcosl_diff = -(chordl*SIN(aincl)*aincl_diff)
            chcosl = chordl*COS(aincl)
            chcosr_diff = -(chordr*SIN(aincr)*aincr_diff)
            chcosr = chordr*COS(aincr)
C
C------ set control-declaration lines for each control variable
            DO n=1,ncontrol
              isconl(n) = 0
              isconr(n) = 0
              DO iscon=1,nscon(isec, isurf)
                IF (icontd(iscon, isec, isurf) .EQ. n) isconl(n) = iscon
              ENDDO
              DO iscon=1,nscon(isec+1, isurf)
                IF (icontd(iscon, isec+1, isurf) .EQ. n) isconr(n) = 
     +              iscon
              ENDDO
            ENDDO
C
C------ set design-variable sensitivities of CHSIN and CHCOS
            DO n=1,ndesign
              chsinl_g_diff(n) = 0.D0
              chsinl_g(n) = 0.
              chsinr_g_diff(n) = 0.D0
              chsinr_g(n) = 0.
              chcosl_g_diff(n) = 0.D0
              chcosl_g(n) = 0.
              chcosr_g_diff(n) = 0.D0
              chcosr_g(n) = 0.
C
              DO isdes=1,nsdes(isec, isurf)
                IF (idestd(isdes, isec, isurf) .EQ. n) THEN
                  chsinl_g_diff(n) = gaing(isdes, isec, isurf)*dtr*
     +              chcosl_diff
                  chsinl_g(n) = chcosl*gaing(isdes, isec, isurf)*dtr
                  chcosl_g_diff(n) = -(gaing(isdes, isec, isurf)*dtr*
     +              chsinl_diff)
                  chcosl_g(n) = -(chsinl*gaing(isdes, isec, isurf)*dtr)
                END IF
              ENDDO
C
              DO isdes=1,nsdes(isec+1, isurf)
                IF (idestd(isdes, isec+1, isurf) .EQ. n) THEN
                  chsinr_g_diff(n) = gaing(isdes, isec+1, isurf)*dtr*
     +              chcosr_diff
                  chsinr_g(n) = chcosr*gaing(isdes, isec+1, isurf)*dtr
                  chcosr_g_diff(n) = -(gaing(isdes, isec+1, isurf)*dtr*
     +              chsinr_diff)
                  chcosr_g(n) = -(chsinr*gaing(isdes, isec+1, isurf)*dtr
     +              )
                END IF
              ENDDO
            ENDDO
C
C
C------ go over chord strips
            iptl = iptloc(isec)
            iptr = iptloc(isec+1)
            nspan = iptr - iptl
            DO ispan=1,nspan
C-------- define left and right edges of vortex strip
C-          note that incidence angle is set by ATAN of chord projections,
C-          not by linear interpolation of AINC
              ipt1 = iptl + ispan - 1
              ipt2 = iptl + ispan
              ivs = iptl + ispan - 1
              f1 = (ypt(ipt1)-ypt(iptl))/(ypt(iptr)-ypt(iptl))
              f2 = (ypt(ipt2)-ypt(iptl))/(ypt(iptr)-ypt(iptl))
              fc = (ycp(ivs)-ypt(iptl))/(ypt(iptr)-ypt(iptl))
C
C-------- store strip in global data arrays
              nstrip = nstrip + 1
              nj(isurf) = nj(isurf) + 1
C
              rle1(1, nstrip) = (1.0-f1)*xyzlel(1) + f1*xyzler(1)
              rle1(2, nstrip) = (1.0-f1)*xyzlel(2) + f1*xyzler(2)
              rle1(3, nstrip) = (1.0-f1)*xyzlel(3) + f1*xyzler(3)
              chord1(nstrip) = (1.0-f1)*chordl + f1*chordr
C
              rle2(1, nstrip) = (1.0-f2)*xyzlel(1) + f2*xyzler(1)
              rle2(2, nstrip) = (1.0-f2)*xyzlel(2) + f2*xyzler(2)
              rle2(3, nstrip) = (1.0-f2)*xyzlel(3) + f2*xyzler(3)
              chord2(nstrip) = (1.0-f2)*chordl + f2*chordr
C
              rle(1, nstrip) = (1.0-fc)*xyzlel(1) + fc*xyzler(1)
              rle(2, nstrip) = (1.0-fc)*xyzlel(2) + fc*xyzler(2)
              rle(3, nstrip) = (1.0-fc)*xyzlel(3) + fc*xyzler(3)
              chord(nstrip) = (1.0-fc)*chordl + fc*chordr
              IF (f2 - f1 .GE. 0.) THEN
                abs0 = f2 - f1
              ELSE
                abs0 = -(f2-f1)
              END IF
C
              wstrip(nstrip) = abs0*width
              tanle(nstrip) = (xyzler(1)-xyzlel(1))/width
              tante(nstrip) = (xyzler(1)+chordr-xyzlel(1)-chordl)/width
C
              chsin_diff = chsinl_diff + fc*(chsinr_diff-chsinl_diff)
              chsin = chsinl + fc*(chsinr-chsinl)
              chcos_diff = chcosl_diff + fc*(chcosr_diff-chcosl_diff)
              chcos = chcosl + fc*(chcosr-chcosl)
              ainc_diff(nstrip) = chcos*chsin_diff/(chsin**2+chcos**2) -
     +          chsin*chcos_diff/(chsin**2+chcos**2)
              ainc(nstrip) = ATAN2(chsin, chcos)
C
              DO n=1,ndesign
                chsin_g_diff = (1.0-fc)*chsinl_g_diff(n) + fc*
     +            chsinr_g_diff(n)
                chsin_g = (1.0-fc)*chsinl_g(n) + fc*chsinr_g(n)
                chcos_g_diff = (1.0-fc)*chcosl_g_diff(n) + fc*
     +            chcosr_g_diff(n)
                chcos_g = (1.0-fc)*chcosl_g(n) + fc*chcosr_g(n)
                temp = chsin*chsin + chcos*chcos
                temp0 = (chcos*chsin_g-chsin*chcos_g)/temp
                ainc_g_diff(nstrip, n) = (chsin_g*chcos_diff+chcos*
     +            chsin_g_diff-chcos_g*chsin_diff-chsin*chcos_g_diff-
     +            temp0*(2*chsin*chsin_diff+2*chcos*chcos_diff))/temp
                ainc_g(nstrip, n) = temp0
              ENDDO
C
              DO n=1,ncontrol
                icl = isconl(n)
                icr = isconr(n)
C
                IF (icl .EQ. 0 .OR. icr .EQ. 0) THEN
C----------- no control effect here
                  gainda(n) = 0.
                  xled(n) = 0.
                  xted(n) = 0.
C
                  vhinge(1, nstrip, n) = 0.
                  vhinge(2, nstrip, n) = 0.
                  vhinge(3, nstrip, n) = 0.
C
                  vrefl(nstrip, n) = 0.
C
                  phinge(1, nstrip, n) = 0.
                  phinge(2, nstrip, n) = 0.
                  phinge(3, nstrip, n) = 0.
C
                ELSE
C----------- control variable # N is active here
                  gainda(n) = gaind(icl, isec, isurf)*(1.0-fc) + gaind(
     +              icr, isec+1, isurf)*fc
C
                  xhd = chordl*xhinged(icl, isec, isurf)*(1.0-fc) + 
     +              chordr*xhinged(icr, isec+1, isurf)*fc
                  IF (xhd .GE. 0.0) THEN
C------------ TE control surface, with hinge at XHD
                    xled(n) = xhd
                    xted(n) = chord(nstrip)
                  ELSE
C------------ LE control surface, with hinge at -XHD
                    xled(n) = 0.0
                    xted(n) = -xhd
                  END IF
C
                  vhx = vhinged(1, icl, isec, isurf)*xyzscal(1, isurf)
                  vhy = vhinged(2, icl, isec, isurf)*xyzscal(2, isurf)
                  vhz = vhinged(3, icl, isec, isurf)*xyzscal(3, isurf)
                  vsq = vhx**2 + vhy**2 + vhz**2
                  IF (vsq .EQ. 0.0) THEN
                    IF (chordr*xhinged(icr, isec+1, isurf) .GE. 0.) THEN
                      abs1 = chordr*xhinged(icr, isec+1, isurf)
                    ELSE
                      abs1 = -(chordr*xhinged(icr, isec+1, isurf))
                    END IF
                    IF (chordl*xhinged(icl, isec, isurf) .GE. 0.) THEN
                      abs2 = chordl*xhinged(icl, isec, isurf)
                    ELSE
                      abs2 = -(chordl*xhinged(icl, isec, isurf))
                    END IF
C------------ default: set hinge vector along hingeline
                    vhx = xyzles(1, isec+1, isurf) + abs1 - xyzles(1, 
     +                isec, isurf) - abs2
                    vhy = xyzles(2, isec+1, isurf) - xyzles(2, isec, 
     +                isurf)
                    vhz = xyzles(3, isec+1, isurf) - xyzles(3, isec, 
     +                isurf)
                    vhx = vhx*xyzscal(1, isurf)
                    vhy = vhy*xyzscal(2, isurf)
                    vhz = vhz*xyzscal(3, isurf)
                    vsq = vhx**2 + vhy**2 + vhz**2
                  END IF
C
                  vmod = SQRT(vsq)
                  vhinge(1, nstrip, n) = vhx/vmod
                  vhinge(2, nstrip, n) = vhy/vmod
                  vhinge(3, nstrip, n) = vhz/vmod
C
                  vrefl(nstrip, n) = refld(icl, isec, isurf)
C
                  IF (xhd .GE. 0.0) THEN
                    phinge(1, nstrip, n) = rle(1, nstrip) + xhd
                    phinge(2, nstrip, n) = rle(2, nstrip)
                    phinge(3, nstrip, n) = rle(3, nstrip)
                  ELSE
                    phinge(1, nstrip, n) = rle(1, nstrip) - xhd
                    phinge(2, nstrip, n) = rle(2, nstrip)
                    phinge(3, nstrip, n) = rle(3, nstrip)
                  END IF
                END IF
              ENDDO
C
C
C--- Interpolate CD-CL polar defining data from input sections to strips
              DO l=1,6
                clcd(l, nstrip) = (1.0-fc)*clcdsec(l, isec, isurf) + fc*
     +            clcdsec(l, isec+1, isurf)
              ENDDO
C--- If the min drag is zero flag the strip as no-viscous data
              lviscstrp(nstrip) = clcd(4, nstrip) .NE. 0.0
C
C
              ijfrst(nstrip) = nvor + 1
              nvstrp(nstrip) = nvc(isurf)
C
              nsurfs(nstrip) = isurf
C
              nsl = nasec(isec, isurf)
              nsr = nasec(isec+1, isurf)
C
              chordc = chord(nstrip)
C
              clafc = (1.-fc)*(chordl/chordc)*clafl + fc*(chordr/chordc)
     +          *clafr
C
C-------- set chordwise spacing fraction arrays
              CALL CSPACER(nvc(isurf), cspace(isurf), clafc, xpt, xvr, 
     +                     xsr, xcp)
C
C-------- go over vortices in this strip
              DO ivc=1,nvc(isurf)
                nvor = nvor + 1
C
                rv1(1, nvor) = rle1(1, nstrip) + xvr(ivc)*chord1(nstrip)
                rv1(2, nvor) = rle1(2, nstrip)
                rv1(3, nvor) = rle1(3, nstrip)
C
                rv2(1, nvor) = rle2(1, nstrip) + xvr(ivc)*chord2(nstrip)
                rv2(2, nvor) = rle2(2, nstrip)
                rv2(3, nvor) = rle2(3, nstrip)
C
                rv(1, nvor) = rle(1, nstrip) + xvr(ivc)*chordc
                rv(2, nvor) = rle(2, nstrip)
                rv(3, nvor) = rle(3, nstrip)
C
                rc(1, nvor) = rle(1, nstrip) + xcp(ivc)*chordc
                rc(2, nvor) = rle(2, nstrip)
                rc(3, nvor) = rle(3, nstrip)
C
                rs(1, nvor) = rle(1, nstrip) + xsr(ivc)*chordc
                rs(2, nvor) = rle(2, nstrip)
                rs(3, nvor) = rle(3, nstrip)
C
                CALL AKIMA(xasec(1, isec, isurf), sasec(1, isec, isurf)
     +                     , nsl, xcp(ivc), slopel, dsdx)
                CALL AKIMA(xasec(1, isec+1, isurf), sasec(1, isec+1, 
     +                     isurf), nsr, xcp(ivc), sloper, dsdx)
                slopec(nvor) = (1.-fc)*(chordl/chordc)*slopel + fc*(
     +            chordr/chordc)*sloper
C
                CALL AKIMA(xasec(1, isec, isurf), sasec(1, isec, isurf)
     +                     , nsl, xvr(ivc), slopel, dsdx)
                CALL AKIMA(xasec(1, isec+1, isurf), sasec(1, isec+1, 
     +                     isurf), nsr, xvr(ivc), sloper, dsdx)
                slopev(nvor) = (1.-fc)*(chordl/chordc)*slopel + fc*(
     +            chordr/chordc)*sloper
C
                dxoc = xpt(ivc+1) - xpt(ivc)
                dxv(nvor) = dxoc*chordc
                chordv(nvor) = chordc
                nsurfv(nvor) = lscomp(isurf)
C
                lvnc(nvor) = .true.
C
C---------- element inherits alpha,beta flag from surface
                lvalbe(nvor) = lfalbe(isurf)
C
                DO n=1,ncontrol
C------------ scale control gain by factor 0..1, (fraction of element on control surface)
                  fracle = (xled(n)/chordc-xpt(ivc))/dxoc
                  fracte = (xted(n)/chordc-xpt(ivc))/dxoc
                  IF (0.0 .LT. fracle) THEN
                    y1 = fracle
                  ELSE
                    y1 = 0.0
                  END IF
                  IF (1.0 .GT. y1) THEN
                    fracle = y1
                  ELSE
                    fracle = 1.0
                  END IF
                  IF (0.0 .LT. fracte) THEN
                    y2 = fracte
                  ELSE
                    y2 = 0.0
                  END IF
                  IF (1.0 .GT. y2) THEN
                    fracte = y2
                  ELSE
                    fracte = 1.0
                  END IF
C
                  dcontrol(nvor, n) = gainda(n)*(fracte-fracle)
                ENDDO
C
C---------- TE control point used only if surface sheds a wake
                lvnc(nvor) = lfwake(isurf)
              ENDDO
            ENDDO
          ENDDO
C
C
C
C
C---- Find wetted surface area (one side)
          sum = 0.0
          wtot = 0.0
          DO jj=1,nj(isurf)
            j = jfrst(isurf) + jj - 1
            astrp = wstrip(j)*chord(j)
            sum = sum + astrp
            wtot = wtot + wstrip(j)
          ENDDO
          ssurf(isurf) = sum
C
          IF (wtot .EQ. 0.0) THEN
            cavesurf(isurf) = 0.0
          ELSE
            cavesurf(isurf) = sum/wtot
          END IF
C
          RETURN
        END IF
      END IF
C
 7000 FORMAT(/' *** Cannot adjust spanwise spacing at section',i3,
     +       ', on surface ',a/
     +      ' *** Insufficient number of spanwise vortices to work with'
     +      )
      END

C  Differentiation of sdupl in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: ainc ainc_g
C   with respect to varying inputs: ainc ainc_g
C MAKEBODY
C
C
C
C
      SUBROUTINE SDUPL_D(nn, ypt, msg)
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
      CHARACTER*(*) msg
      INTEGER nni
      INTEGER klen
      INTRINSIC LEN
      INTEGER k
      REAL yoff
      INTEGER ivs
      INTEGER jji
      INTEGER jj
      INTEGER n
      INTEGER l
      INTEGER ivc
      INTEGER iii
      INTEGER ii
      REAL rsgn
      INTEGER nn
      REAL ypt
C
      nni = nsurf + 1
      IF (nni .GT. nfmax) THEN
        WRITE(*, *) 'SDUPL: Surface array overflow. Increase NFMAX.'
        STOP
      ELSE
C
        klen = LEN(stitle(nn))
        DO k=klen,1,-1
          IF (stitle(nn)(k:k) .NE. ' ') EXIT
        ENDDO
        stitle(nni) = stitle(nn)(1:k)//' ('//msg//')'
        IF (lverbose) THEN
          WRITE(*, *) ' '
          WRITE(*, *) '  Building duplicate image-surface: ', stitle(nni
     +          )
        END IF
C
C---- duplicate surface is assumed to be the same logical component surface
        lscomp(nni) = lscomp(nn)
C
C---- same various logical flags
        lfwake(nni) = lfwake(nn)
        lfalbe(nni) = lfalbe(nn)
        lfload(nni) = lfload(nn)
C
C---- accumulate stuff for new image surface 
        ifrst(nni) = nvor + 1
        jfrst(nni) = nstrip + 1
        nj(nni) = nj(nn)
        nk(nni) = nk(nn)
C
        nvc(nni) = nk(nni)
        nvs(nni) = nj(nni)
C
        ssurf(nni) = ssurf(nn)
        cavesurf(nni) = cavesurf(nn)
C--- Note hinge axis is flipped to reverse the Y component of the hinge
C    vector.   This means that deflections need to be reversed for image
C    surfaces.
C
C--- Image flag reversed (set to -IMAGS) for imaged surfaces
        imags(nni) = -imags(nn)
C
        yoff = 2.0*ypt
C
C--- Create image strips, to maintain the same sense of positive GAMMA
C    these have the 1 and 2 strip edges reversed (i.e. root is edge 2, 
C    not edge 1 as for a strip with IMAGS=1
        DO ivs=1,nvs(nni)
          nstrip = nstrip + 1
          IF (nstrip .GT. nsmax) THEN
            GOTO 110
          ELSE
C
            jji = jfrst(nni) + ivs - 1
            jj = jfrst(nn) + ivs - 1
            rle1(1, jji) = rle2(1, jj)
            rle1(2, jji) = -rle2(2, jj) + yoff
            rle1(3, jji) = rle2(3, jj)
            chord1(jji) = chord2(jj)
            rle2(1, jji) = rle1(1, jj)
            rle2(2, jji) = -rle1(2, jj) + yoff
            rle2(3, jji) = rle1(3, jj)
            chord2(jji) = chord1(jj)
            rle(1, jji) = rle(1, jj)
            rle(2, jji) = -rle(2, jj) + yoff
            rle(3, jji) = rle(3, jj)
            chord(jji) = chord(jj)
            wstrip(jji) = wstrip(jj)
            tanle(jji) = -tanle(jj)
            ainc_diff(jji) = ainc_diff(jj)
            ainc(jji) = ainc(jj)
C
            nsurfs(nstrip) = nni
C
            DO n=1,ndesign
              ainc_g_diff(jji, n) = ainc_g_diff(jj, n)
              ainc_g(jji, n) = ainc_g(jj, n)
            ENDDO
C
            DO n=1,ncontrol
              vrefl(jji, n) = vrefl(jj, n)
C
              vhinge(1, jji, n) = vhinge(1, jj, n)
              vhinge(2, jji, n) = -vhinge(2, jj, n)
              vhinge(3, jji, n) = vhinge(3, jj, n)
C
              phinge(1, jji, n) = phinge(1, jj, n)
              phinge(2, jji, n) = -phinge(2, jj, n) + yoff
              phinge(3, jji, n) = phinge(3, jj, n)
            ENDDO
C
C--- The defined section for image strip is flagged with (-)
            ijfrst(jji) = nvor + 1
            nvstrp(jji) = nvc(nni)
            DO l=1,6
              clcd(l, jji) = clcd(l, jj)
            ENDDO
            lviscstrp(jji) = lviscstrp(jj)
C
            DO ivc=1,nvc(nni)
              nvor = nvor + 1
              IF (nvor .GT. nvmax) THEN
                GOTO 120
              ELSE
C
                iii = ijfrst(jji) + ivc - 1
                ii = ijfrst(jj) + ivc - 1
                rv1(1, iii) = rv2(1, ii)
                rv1(2, iii) = -rv2(2, ii) + yoff
                rv1(3, iii) = rv2(3, ii)
                rv2(1, iii) = rv1(1, ii)
                rv2(2, iii) = -rv1(2, ii) + yoff
                rv2(3, iii) = rv1(3, ii)
                rv(1, iii) = rv(1, ii)
                rv(2, iii) = -rv(2, ii) + yoff
                rv(3, iii) = rv(3, ii)
                rc(1, iii) = rc(1, ii)
                rc(2, iii) = -rc(2, ii) + yoff
                rc(3, iii) = rc(3, ii)
                slopec(iii) = slopec(ii)
                slopev(iii) = slopev(ii)
                dxv(iii) = dxv(ii)
                chordv(iii) = chordv(ii)
                nsurfv(iii) = lscomp(nni)
                lvalbe(iii) = lvalbe(ii)
                lvnc(iii) = lvnc(ii)
C
                DO n=1,ncontrol
Ccc         RSGN = SIGN( 1.0 , VREFL(JJ,N) )
                  rsgn = vrefl(jj, n)
                  dcontrol(iii, n) = -(dcontrol(ii, n)*rsgn)
                ENDDO
              END IF
            ENDDO
          END IF
        ENDDO
C
C
C
C
        RETURN
 110    WRITE(*, *) 'SDUPL: Strip array overflow. Increase NSMAX.'
        STOP
 120    WRITE(*, *) 'SDUPL: Vortex array overflow. Increase NVMAX.'
        STOP
      END IF
      END

C  Differentiation of encalc in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: enc env
C   with respect to varying inputs: ainc ainc_g
C BDUPL
C
C
C
C
      SUBROUTINE ENCALC_D()
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
C
      REAL ep(3), eq(3), es(3), eb(3), ec(3), ecxb(3)
      REAL eb_diff(3), ec_diff(3), ecxb_diff(3)
      REAL ec_g(3, ndmax), ecxb_g(3)
      INTEGER j
      INTEGER i
      REAL dxle
      REAL dyle
      REAL dzle
      REAL axle
      REAL ayle
      REAL azle
      REAL dxte
      REAL dyte
      REAL dzte
      REAL axte
      REAL ayte
      REAL azte
      REAL dxt
      REAL dyt
      REAL dzt
      INTRINSIC SQRT
      INTEGER nv
      INTEGER ii
      INTEGER n
      REAL dxb
      REAL dyb
      REAL dzb
      REAL emag
      REAL emag_diff
      REAL ang
      REAL ang_diff
      INTRINSIC ATAN
      REAL sinc
      REAL sinc_diff
      INTRINSIC SIN
      REAL cosc
      REAL cosc_diff
      INTRINSIC COS
      REAL emag_g
      REAL ang_ddc
      REAL cosd
      REAL sind
      REAL endot
      REAL DOT
      REAL arg1
      REAL arg1_diff
      REAL result1
      INTEGER ii1
      REAL temp
      INTEGER ii2
      DO ii1=1,nvmax
        DO ii2=1,3
          enc_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvmax
        DO ii2=1,3
          env_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,3
        ec_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        ecxb_diff(ii1) = 0.D0
      ENDDO
C
C...Calculate the normal vector at control points and bound vortex midpoints
C
      DO j=1,nstrip
C
C...Calculate normal vector for the strip (normal to X axis)
        i = ijfrst(j)
        dxle = rv2(1, i) - rv1(1, i)
        dyle = rv2(2, i) - rv1(2, i)
        dzle = rv2(3, i) - rv1(3, i)
C       AXLE = (RV2(1,I)+RV1(1,I))*0.5
C       AYLE = (RV2(2,I)+RV1(2,I))*0.5
C       AZLE = (RV2(3,I)+RV1(3,I))*0.5
        axle = rv(1, i)
        ayle = rv(2, i)
        azle = rv(3, i)
C
        i = ijfrst(j) + (nvstrp(j)-1)
        dxte = rv2(1, i) - rv1(1, i)
        dyte = rv2(2, i) - rv1(2, i)
        dzte = rv2(3, i) - rv1(3, i)
C       AXTE = (RV2(1,I)+RV1(1,I))*0.5
C       AYTE = (RV2(2,I)+RV1(2,I))*0.5
C       AZTE = (RV2(3,I)+RV1(3,I))*0.5
        axte = rv(1, i)
        ayte = rv(2, i)
        azte = rv(3, i)
C
        dxt = (1.0-saxfr)*dxle + saxfr*dxte
        dyt = (1.0-saxfr)*dyle + saxfr*dyte
        dzt = (1.0-saxfr)*dzle + saxfr*dzte
C
        arg1 = dxt*dxt + dyt*dyt + dzt*dzt
        result1 = SQRT(arg1)
        ess(1, j) = dxt/result1
        arg1 = dxt*dxt + dyt*dyt + dzt*dzt
        result1 = SQRT(arg1)
        ess(2, j) = dyt/result1
        arg1 = dxt*dxt + dyt*dyt + dzt*dzt
        result1 = SQRT(arg1)
        ess(3, j) = dzt/result1
C
        arg1 = dyt*dyt + dzt*dzt
        result1 = SQRT(arg1)
        ensy(j) = -(dzt/result1)
        arg1 = dyt*dyt + dzt*dzt
        result1 = SQRT(arg1)
        ensz(j) = dyt/result1
C
        xsref(j) = (1.0-saxfr)*axle + saxfr*axte
        ysref(j) = (1.0-saxfr)*ayle + saxfr*ayte
        zsref(j) = (1.0-saxfr)*azle + saxfr*azte
C
C
        es(1) = 0.
        es(2) = ensy(j)
        es(3) = ensz(j)
C
        lstripoff(j) = .false.
C
        nv = nvstrp(j)
        DO ii=1,nv
C
          i = ijfrst(j) + (ii-1)
C
          DO n=1,ncontrol
            env_d(1, i, n) = 0.
            env_d(2, i, n) = 0.
            env_d(3, i, n) = 0.
            enc_d(1, i, n) = 0.
            enc_d(2, i, n) = 0.
            enc_d(3, i, n) = 0.
          ENDDO
C
          DO n=1,ndesign
            env_g(1, i, n) = 0.
            env_g(2, i, n) = 0.
            env_g(3, i, n) = 0.
            enc_g(1, i, n) = 0.
            enc_g(2, i, n) = 0.
            enc_g(3, i, n) = 0.
          ENDDO
C
C...Define unit vector along bound leg
          dxb = rv2(1, i) - rv1(1, i)
          dyb = rv2(2, i) - rv1(2, i)
          dzb = rv2(3, i) - rv1(3, i)
          arg1 = dxb**2 + dyb**2 + dzb**2
          emag = SQRT(arg1)
          eb(1) = dxb/emag
          eb(2) = dyb/emag
          eb(3) = dzb/emag
C
C...Define direction of normal vector at control point 
C   The YZ projection of the normal vector matches the camber slope
C   + section local incidence in the YZ defining plane for the section
          ang_diff = ainc_diff(j)
          ang = ainc(j) - ATAN(slopec(i))
Cc          IF(LDES) THEN
C--------- add design-variable contribution to angle
          DO n=1,ndesign
            ang_diff = ang_diff + deldes(n)*ainc_g_diff(j, n)
            ang = ang + ainc_g(j, n)*deldes(n)
          ENDDO
Cc          ENDIF
C
          sinc_diff = COS(ang)*ang_diff
          sinc = SIN(ang)
          cosc_diff = -(SIN(ang)*ang_diff)
          cosc = COS(ang)
          ec_diff(1) = cosc_diff
          ec(1) = cosc
          ec_diff(2) = -(es(2)*sinc_diff)
          ec(2) = -(sinc*es(2))
          ec_diff(3) = -(es(3)*sinc_diff)
          ec(3) = -(sinc*es(3))
          DO n=1,ndesign
            ec_g(1, n) = -(sinc*ainc_g(j, n))
            ec_g(2, n) = -(cosc*es(2)*ainc_g(j, n))
            ec_g(3, n) = -(cosc*es(3)*ainc_g(j, n))
          ENDDO
C
C...Normal vector is perpendicular to camberline vector and to the bound leg
          DO ii1=1,3
            eb_diff(ii1) = 0.D0
          ENDDO
          CALL CROSS_D(ec, ec_diff, eb, eb_diff, ecxb, ecxb_diff)
          arg1_diff = 2*ecxb(1)*ecxb_diff(1) + 2*ecxb(2)*ecxb_diff(2) + 
     +      2*ecxb(3)*ecxb_diff(3)
          arg1 = ecxb(1)**2 + ecxb(2)**2 + ecxb(3)**2
          temp = SQRT(arg1)
          IF (arg1 .EQ. 0.D0) THEN
            emag_diff = 0.D0
          ELSE
            emag_diff = arg1_diff/(2.0*temp)
          END IF
          emag = temp
          IF (emag .NE. 0.0) THEN
            temp = ecxb(1)/emag
            enc_diff(1, i) = (ecxb_diff(1)-temp*emag_diff)/emag
            enc(1, i) = temp
            temp = ecxb(2)/emag
            enc_diff(2, i) = (ecxb_diff(2)-temp*emag_diff)/emag
            enc(2, i) = temp
            temp = ecxb(3)/emag
            enc_diff(3, i) = (ecxb_diff(3)-temp*emag_diff)/emag
            enc(3, i) = temp
            DO n=1,ndesign
              CALL CROSS(ec_g(1, n), eb, ecxb_g)
              emag_g = enc(1, i)*ecxb_g(1) + enc(2, i)*ecxb_g(2) + enc(3
     +          , i)*ecxb_g(3)
              enc_g(1, i, n) = (ecxb_g(1)-enc(1, i)*emag_g)/emag
              enc_g(2, i, n) = (ecxb_g(2)-enc(2, i)*emag_g)/emag
              enc_g(3, i, n) = (ecxb_g(3)-enc(3, i)*emag_g)/emag
            ENDDO
          ELSE
            enc_diff(1, i) = 0.D0
            enc(1, i) = es(1)
            enc_diff(2, i) = 0.D0
            enc(2, i) = es(2)
            enc_diff(3, i) = 0.D0
            enc(3, i) = es(3)
          END IF
C
C
C...Define direction of normal vector at vortex mid-point. 
C   The YZ projection of the normal vector matches the camber slope
C   + section local incidence in the YZ defining plane for the section
          ang_diff = ainc_diff(j)
          ang = ainc(j) - ATAN(slopev(i))
Cc          IF(LDES) THEN
C--------- add design-variable contribution to angle
          DO n=1,ndesign
            ang_diff = ang_diff + deldes(n)*ainc_g_diff(j, n)
            ang = ang + ainc_g(j, n)*deldes(n)
          ENDDO
Cc          ENDIF
C
          sinc_diff = COS(ang)*ang_diff
          sinc = SIN(ang)
          cosc_diff = -(SIN(ang)*ang_diff)
          cosc = COS(ang)
          ec_diff(1) = cosc_diff
          ec(1) = cosc
          ec_diff(2) = -(es(2)*sinc_diff)
          ec(2) = -(sinc*es(2))
          ec_diff(3) = -(es(3)*sinc_diff)
          ec(3) = -(sinc*es(3))
          DO n=1,ndesign
            ec_g(1, n) = -(sinc*ainc_g(j, n))
            ec_g(2, n) = -(cosc*es(2)*ainc_g(j, n))
            ec_g(3, n) = -(cosc*es(3)*ainc_g(j, n))
          ENDDO
C
C...Normal vector is perpendicular to camberline vector and to the bound leg
          DO ii1=1,3
            eb_diff(ii1) = 0.D0
          ENDDO
          CALL CROSS_D(ec, ec_diff, eb, eb_diff, ecxb, ecxb_diff)
          arg1_diff = 2*ecxb(1)*ecxb_diff(1) + 2*ecxb(2)*ecxb_diff(2) + 
     +      2*ecxb(3)*ecxb_diff(3)
          arg1 = ecxb(1)**2 + ecxb(2)**2 + ecxb(3)**2
          temp = SQRT(arg1)
          IF (arg1 .EQ. 0.D0) THEN
            emag_diff = 0.D0
          ELSE
            emag_diff = arg1_diff/(2.0*temp)
          END IF
          emag = temp
          IF (emag .NE. 0.0) THEN
            temp = ecxb(1)/emag
            env_diff(1, i) = (ecxb_diff(1)-temp*emag_diff)/emag
            env(1, i) = temp
            temp = ecxb(2)/emag
            env_diff(2, i) = (ecxb_diff(2)-temp*emag_diff)/emag
            env(2, i) = temp
            temp = ecxb(3)/emag
            env_diff(3, i) = (ecxb_diff(3)-temp*emag_diff)/emag
            env(3, i) = temp
            DO n=1,ndesign
              CALL CROSS(ec_g(1, n), eb, ecxb_g)
              emag_g = enc(1, i)*ecxb_g(1) + enc(2, i)*ecxb_g(2) + enc(3
     +          , i)*ecxb_g(3)
              env_g(1, i, n) = (ecxb_g(1)-env(1, i)*emag_g)/emag
              env_g(2, i, n) = (ecxb_g(2)-env(2, i)*emag_g)/emag
              env_g(3, i, n) = (ecxb_g(3)-env(3, i)*emag_g)/emag
            ENDDO
          ELSE
            env_diff(1, i) = 0.D0
            env(1, i) = es(1)
            env_diff(2, i) = 0.D0
            env(2, i) = es(2)
            env_diff(3, i) = 0.D0
            env(3, i) = es(3)
          END IF
C
C
Ccc       write(*,*) i, dcontrol(i,1), dcontrol(i,2)
C
C=======================================================
C-------- rotate normal vectors for control surface
          DO n=1,ncontrol
C
C---------- skip everything if this element is unaffected by control variable N
            IF (dcontrol(i, n) .NE. 0.0) THEN
C
              ang = dtr*dcontrol(i, n)*delcon(n)
              ang_ddc = dtr*dcontrol(i, n)
C
              cosd = COS(ang)
              sind = SIN(ang)
C
C---------- EP = normal-vector component perpendicular to hinge line
              endot = DOT(enc(1, i), vhinge(1, j, n))
              ep(1) = enc(1, i) - endot*vhinge(1, j, n)
              ep(2) = enc(2, i) - endot*vhinge(2, j, n)
              ep(3) = enc(3, i) - endot*vhinge(3, j, n)
C---------- EQ = unit vector perpendicular to both EP and hinge line
              CALL CROSS(vhinge(1, j, n), ep, eq)
C
C---------- rotated vector would consist of sin,cos parts from EP and EQ,
C-          with hinge-parallel component ENDOT restored 
Cc          ENC(1,I) = EP(1)*COSD + EQ(1)*SIND + ENDOT*VHINGE(1,J,N)
Cc          ENC(2,I) = EP(2)*COSD + EQ(2)*SIND + ENDOT*VHINGE(2,J,N)
Cc          ENC(3,I) = EP(3)*COSD + EQ(3)*SIND + ENDOT*VHINGE(3,J,N)
C
C---------- linearize about zero deflection (COSD=1, SIND=0)
              enc_d(1, i, n) = enc_d(1, i, n) + eq(1)*ang_ddc
              enc_d(2, i, n) = enc_d(2, i, n) + eq(2)*ang_ddc
              enc_d(3, i, n) = enc_d(3, i, n) + eq(3)*ang_ddc
C
C
C---------- repeat for ENV vector
C
C---------- EP = normal-vector component perpendicular to hinge line
              endot = DOT(env(1, i), vhinge(1, j, n))
              ep(1) = env(1, i) - endot*vhinge(1, j, n)
              ep(2) = env(2, i) - endot*vhinge(2, j, n)
              ep(3) = env(3, i) - endot*vhinge(3, j, n)
C---------- EQ = unit vector perpendicular to both EP and hinge line
              CALL CROSS(vhinge(1, j, n), ep, eq)
C
C---------- rotated vector would consist of sin,cos parts from EP and EQ,
C-          with hinge-parallel component ENDOT restored 
Cc          ENV(1,I) = EP(1)*COSD + EQ(1)*SIND + ENDOT*VHINGE(1,J,N)
Cc          ENV(2,I) = EP(2)*COSD + EQ(2)*SIND + ENDOT*VHINGE(2,J,N)
Cc          ENV(3,I) = EP(3)*COSD + EQ(3)*SIND + ENDOT*VHINGE(3,J,N)
C
C---------- linearize about zero deflection (COSD=1, SIND=0)
              env_d(1, i, n) = env_d(1, i, n) + eq(1)*ang_ddc
              env_d(2, i, n) = env_d(2, i, n) + eq(2)*ang_ddc
              env_d(3, i, n) = env_d(3, i, n) + eq(3)*ang_ddc
            END IF
          ENDDO
        ENDDO
      ENDDO
C
C
      lenc = .true.
C
      RETURN
      END
C ENCALC
C

